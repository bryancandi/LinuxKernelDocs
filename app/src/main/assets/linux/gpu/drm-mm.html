<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>DRM Memory Management &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=a152c8ac" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel Mode Setting (KMS)" href="drm-kms.html" />
    <link rel="prev" title="DRM Internals" href="drm-internals.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.11.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/drm-mm.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="drm-memory-management">
<h1>DRM Memory Management<a class="headerlink" href="#drm-memory-management" title="Link to this heading">¶</a></h1>
<p>Modern Linux systems require large amount of graphics memory to store
frame buffers, textures, vertices and other graphics-related data. Given
the very dynamic nature of many of that data, managing graphics memory
efficiently is thus crucial for the graphics stack and plays a central
role in the DRM infrastructure.</p>
<p>The DRM core includes two memory managers, namely Translation Table Manager
(TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
manager to be developed and tried to be a one-size-fits-them all
solution. It provides a single userspace API to accommodate the need of
all hardware, supporting both Unified Memory Architecture (UMA) devices
and devices with dedicated video RAM (i.e. most discrete video cards).
This resulted in a large, complex piece of code that turned out to be
hard to use for driver development.</p>
<p>GEM started as an Intel-sponsored project in reaction to TTM’s
complexity. Its design philosophy is completely different: instead of
providing a solution to every graphics memory-related problems, GEM
identified common code between drivers and created a support library to
share it. GEM has simpler initialization and execution requirements than
TTM, but has no video RAM management capabilities and is thus limited to
UMA devices.</p>
<section id="the-translation-table-manager-ttm">
<h2>The Translation Table Manager (TTM)<a class="headerlink" href="#the-translation-table-manager-ttm" title="Link to this heading">¶</a></h2>
<p>TTM is a memory manager for accelerator devices with dedicated memory.</p>
<p>The basic idea is that resources are grouped together in buffer objects of
certain size and TTM handles lifetime, movement and CPU mappings of those
objects.</p>
<p>TODO: Add more design background and information here.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.ttm_caching">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_caching</span></span></span><a class="headerlink" href="#c.ttm_caching" title="Link to this definition">¶</a><br /></dt>
<dd><p>CPU caching and BUS snooping behavior.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ttm_uncached</span></code></dt><dd><p>Most defensive option for device mappings,
don’t even allow write combining.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ttm_write_combined</span></code></dt><dd><p>Don’t cache read accesses, but allow at least
writes to be combined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ttm_cached</span></code></dt><dd><p>Fully cached like normal system memory, requires that
devices snoop the CPU cache on accesses.</p>
</dd>
</dl>
</div>
<section id="ttm-device-object-reference">
<h3>TTM device object reference<a class="headerlink" href="#ttm-device-object-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_global">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_global</span></span></span><a class="headerlink" href="#c.ttm_global" title="Link to this definition">¶</a><br /></dt>
<dd><p>Buffer object driver global data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_global {
    struct page *dummy_read_page;
    struct list_head device_list;
    atomic_t bo_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dummy_read_page</span></code></dt><dd><p>Pointer to a dummy page used for mapping requests
of unpopulated pages. Constant after init.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_list</span></code></dt><dd><p>List of buffer object devices. Protected by
ttm_global_mutex.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo_count</span></code></dt><dd><p>Number of buffer objects allocated by devices.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_device</span></span></span><a class="headerlink" href="#c.ttm_device" title="Link to this definition">¶</a><br /></dt>
<dd><p>Buffer object driver device-specific data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_device {
    struct list_head device_list;
    const struct ttm_device_funcs *funcs;
    struct ttm_resource_manager sysman;
    struct ttm_resource_manager *man_drv[TTM_NUM_MEM_TYPES];
    struct drm_vma_offset_manager *vma_manager;
    struct ttm_pool pool;
    spinlock_t lru_lock;
    struct list_head pinned;
    struct address_space *dev_mapping;
    struct workqueue_struct *wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">device_list</span></code></dt><dd><p>Our entry in the global device list.
Constant after bo device init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Function table for the device.
Constant after bo device init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysman</span></code></dt><dd><p>Resource manager for the system domain.
Access via ttm_manager_type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">man_drv</span></code></dt><dd><p>An array of resource_managers, one per resource type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vma_manager</span></code></dt><dd><p>Address space manager for finding BOs to mmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pool</span></code></dt><dd><p>page pool for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru_lock</span></code></dt><dd><p>Protection for the per manager LRU and ddestroy lists.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pinned</span></code></dt><dd><p>Buffer objects which are pinned and so not on any LRU list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_mapping</span></code></dt><dd><p>A pointer to the <a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code></a> for invalidating
CPU mappings on buffer move. Protected by load/unload sync.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>Work queue structure for the delayed delete workqueue.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_device_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_device_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_device_funcs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">funcs</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mapping</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma_manager</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">use_dma_alloc</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">use_dma32</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_device_init" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>A pointer to a <a class="reference internal" href="#c.ttm_device" title="ttm_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span></code></a> to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ttm_device_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>Function table for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The core kernel device pointer for DMA mappings and allocations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt><dd><p>The address space to use for this bo.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*vma_manager</span></code></dt><dd><p>A pointer to a vma manager.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_dma_alloc</span></code></dt><dd><p>If coherent DMA allocation API should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_dma32</span></code></dt><dd><p>If we should use GFP_DMA32 for device memory allocations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a <a class="reference internal" href="#c.ttm_device" title="ttm_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span></code></a>:</p>
<p><strong>Return</strong></p>
<p>!0: Failure.</p>
</div>
</section>
<section id="ttm-resource-placement-reference">
<h3>TTM resource placement reference<a class="headerlink" href="#ttm-resource-placement-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_place">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_place</span></span></span><a class="headerlink" href="#c.ttm_place" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_place {
    unsigned fpfn;
    unsigned lpfn;
    uint32_t mem_type;
    uint32_t flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fpfn</span></code></dt><dd><p>first valid page frame number to put the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpfn</span></code></dt><dd><p>last valid page frame number to put the object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_type</span></code></dt><dd><p>One of TTM_PL_* where the resource should be allocated from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>memory domain and caching flags for the object</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure indicating a possible place to put an object.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_placement">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_placement</span></span></span><a class="headerlink" href="#c.ttm_placement" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_placement {
    unsigned num_placement;
    const struct ttm_place  *placement;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_placement</span></code></dt><dd><p>number of preferred placements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placement</span></code></dt><dd><p>preferred placements</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure indicating the placement you request for an object.</p>
</section>
<section id="ttm-resource-object-reference">
<h3>TTM resource object reference<a class="headerlink" href="#ttm-resource-object-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_resource_manager">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager</span></span></span><a class="headerlink" href="#c.ttm_resource_manager" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_resource_manager {
    bool use_type;
    bool use_tt;
    struct ttm_device *bdev;
    uint64_t size;
    const struct ttm_resource_manager_func *func;
    spinlock_t move_lock;
    struct dma_fence *move;
    struct list_head lru[TTM_MAX_BO_PRIORITY];
    uint64_t usage;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">use_type</span></code></dt><dd><p>The memory type is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_tt</span></code></dt><dd><p>If a TT object should be used for the backing store.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bdev</span></code></dt><dd><p>ttm device this manager belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the managed region.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>structure pointer implementing the range manager. See above</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move_lock</span></code></dt><dd><p>lock for move fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move</span></code></dt><dd><p>The fence of the last pipelined move operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru</span></code></dt><dd><p>The lru list for this memory type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>How much of the resources are used, protected by the
bdev-&gt;lru_lock.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used to identify and manage memory types for a device.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_bus_placement">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_bus_placement</span></span></span><a class="headerlink" href="#c.ttm_bus_placement" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_bus_placement {
    void *addr;
    phys_addr_t offset;
    bool is_iomem;
    enum ttm_caching        caching;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>mapped virtual address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>physical addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_iomem</span></code></dt><dd><p>is this io memory ?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>See <a class="reference internal" href="#c.ttm_caching" title="ttm_caching"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ttm_caching</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure indicating the bus placement of an object.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_resource">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource</span></span></span><a class="headerlink" href="#c.ttm_resource" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_resource {
    unsigned long start;
    size_t size;
    uint32_t mem_type;
    uint32_t placement;
    struct ttm_bus_placement bus;
    struct ttm_buffer_object *bo;
    struct list_head lru;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Start of the allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Actual size of resource in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_type</span></code></dt><dd><p>Resource type of the allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placement</span></code></dt><dd><p>Placement flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>Placement on io bus accessible to the CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bo</span></code></dt><dd><p>weak reference to the BO, protected by ttm_device::lru_lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru</span></code></dt><dd><p>Least recently used list, see <a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_resource_manager.lru</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure indicating the placement and space resources used by a
buffer object.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_resource_cursor">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_cursor</span></span></span><a class="headerlink" href="#c.ttm_resource_cursor" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_resource_cursor {
    unsigned int priority;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>the current priority</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Cursor to iterate over the resources in a manager.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_lru_bulk_move_pos">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_lru_bulk_move_pos</span></span></span><a class="headerlink" href="#c.ttm_lru_bulk_move_pos" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_lru_bulk_move_pos {
    struct ttm_resource *first;
    struct ttm_resource *last;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code></dt><dd><p>first res in the bulk move range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>last res in the bulk move range</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Range of resources for a lru bulk move.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_lru_bulk_move">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_lru_bulk_move</span></span></span><a class="headerlink" href="#c.ttm_lru_bulk_move" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_lru_bulk_move {
    struct ttm_lru_bulk_move_pos pos[TTM_NUM_MEM_TYPES][TTM_MAX_BO_PRIORITY];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>first/last lru entry for resources in the each domain/priority</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Container for the current bulk move state. Should be used with
<a class="reference internal" href="#c.ttm_lru_bulk_move_init" title="ttm_lru_bulk_move_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_lru_bulk_move_init()</span></code></a> and ttm_bo_set_bulk_move().
All BOs in a bulk_move structure need to share the same reservation object to
ensure that the bulk as a whole is locked for eviction even if only one BO of
the bulk is evicted.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_kmap_iter_iomap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_kmap_iter_iomap</span></span></span><a class="headerlink" href="#c.ttm_kmap_iter_iomap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Specialization for a struct io_mapping + struct sg_table backed <a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_kmap_iter_iomap {
    struct ttm_kmap_iter base;
    struct io_mapping *iomap;
    struct sg_table *st;
    resource_size_t start;
    struct {
        struct scatterlist *sg;
        pgoff_t i;
        pgoff_t end;
        pgoff_t offs;
    } cache;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Embedded struct ttm_kmap_iter providing the usage interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iomap</span></code></dt><dd><p>struct io_mapping representing the underlying linear io_memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">st</span></code></dt><dd><p>sg_table into <strong>iomap</strong>, representing the memory of the <a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Offset that needs to be subtracted from <strong>st</strong> to make
sg_dma_address(st-&gt;sgl) - <strong>start</strong> == 0 for <strong>iomap</strong> start.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache</span></code></dt><dd><p>Scatterlist traversal cache for fast lookups.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache.sg</span></code></dt><dd><p>Pointer to the currently cached scatterlist segment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache.i</span></code></dt><dd><p>First index of <strong>sg</strong>. PAGE_SIZE granularity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache.end</span></code></dt><dd><p>Last index + 1 of <strong>sg</strong>. PAGE_SIZE granularity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache.offs</span></code></dt><dd><p>First offset into <strong>iomap</strong> of <strong>sg</strong>. PAGE_SIZE granularity.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_kmap_iter_linear_io">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_kmap_iter_linear_io</span></span></span><a class="headerlink" href="#c.ttm_kmap_iter_linear_io" title="Link to this definition">¶</a><br /></dt>
<dd><p>Iterator specialization for linear io</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_kmap_iter_linear_io {
    struct ttm_kmap_iter base;
    struct iosys_map dmap;
    bool needs_unmap;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>The base iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmap</span></code></dt><dd><p>Points to the starting address of the region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_unmap</span></code></dt><dd><p>Whether we need to unmap on fini</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_set_used">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_set_used</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">used</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_set_used" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>A memory manager object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">used</span></code></dt><dd><p>usage state to set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the manager in use flag. If disabled the manager is no longer
used for object placement.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_used">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_used</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_used" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>Manager to get used state for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the in use flag for a manager.</p>
<p><strong>Return</strong></p>
<p>true is used, false if not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_cleanup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_cleanup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_cleanup" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>A memory manager object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup the move fences from the memory manager object.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.ttm_resource_manager_for_each_res">
<span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_for_each_res</span></span></span><a class="headerlink" href="#c.ttm_resource_manager_for_each_res" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">ttm_resource_manager_for_each_res</span> <span class="pre">(man,</span> <span class="pre">cursor,</span> <span class="pre">res)</span></code></p>
<blockquote>
<div><p>iterate over all resources</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">man</span></code></dt><dd><p>the resource manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p><a class="reference internal" href="#c.ttm_resource_cursor" title="ttm_resource_cursor"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_cursor</span></code></a> for the current position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">res</span></code></dt><dd><p>the current resource</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all the evictable resources in a resource manager.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_lru_bulk_move_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_lru_bulk_move_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_lru_bulk_move" title="ttm_lru_bulk_move"><span class="n"><span class="pre">ttm_lru_bulk_move</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bulk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_lru_bulk_move_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a bulk move structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_lru_bulk_move</span> <span class="pre">*bulk</span></code></dt><dd><p>the structure to init</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For now just memset the structure to zero.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_lru_bulk_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_lru_bulk_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_lru_bulk_move" title="ttm_lru_bulk_move"><span class="n"><span class="pre">ttm_lru_bulk_move</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bulk</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_lru_bulk_move_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>bulk move range of resources to the LRU tail.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_lru_bulk_move</span> <span class="pre">*bulk</span></code></dt><dd><p>bulk move structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Bulk move BOs to the LRU tail, only valid to use when driver makes sure that
resource order never changes. Should be called with <a class="reference internal" href="#c.ttm_device" title="ttm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_device.lru_lock</span></code></a> held.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_buffer_object</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_place" title="ttm_place"><span class="n"><span class="pre">ttm_place</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">place</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><span class="n"><span class="pre">ttm_resource</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>resource object constructure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt><dd><p>buffer object this resources is allocated for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ttm_place</span> <span class="pre">*place</span></code></dt><dd><p>placement of the resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span> <span class="pre">*res</span></code></dt><dd><p>the resource object to inistilize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new resource object. Counterpart of <a class="reference internal" href="#c.ttm_resource_fini" title="ttm_resource_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_resource_fini()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><span class="n"><span class="pre">ttm_resource</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>resource destructor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>the resource manager this resource belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span> <span class="pre">*res</span></code></dt><dd><p>the resource to clean up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be used by resource manager backends to clean up the TTM resource
objects before freeing the underlying structure. Makes sure the resource is
removed from the LRU before destruction.
Counterpart of <a class="reference internal" href="#c.ttm_resource_init" title="ttm_resource_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_resource_init()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_init" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>memory manager object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>ttm device this manager belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt><dd><p>size of managed resources in arbitrary units</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise core parts of a manager object.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_usage">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_usage</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_usage" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>A memory manager object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return how many resources are currently used.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_debug">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_debug</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_debug" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>manager type to dump.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>printer to use for debug.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_kmap_iter_iomap_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_kmap_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ttm_kmap_iter_iomap_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_kmap_iter_iomap" title="ttm_kmap_iter_iomap"><span class="n"><span class="pre">ttm_kmap_iter_iomap</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter_io</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">io_mapping</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iomap</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">st</span></span>, <span class="n"><span class="pre">resource_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_kmap_iter_iomap_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a <a class="reference internal" href="#c.ttm_kmap_iter_iomap" title="ttm_kmap_iter_iomap"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_iomap</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_iomap</span> <span class="pre">*iter_io</span></code></dt><dd><p>The <a class="reference internal" href="#c.ttm_kmap_iter_iomap" title="ttm_kmap_iter_iomap"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_iomap</span></code></a> to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">io_mapping</span> <span class="pre">*iomap</span></code></dt><dd><p>The struct io_mapping representing the underlying linear io_memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*st</span></code></dt><dd><p>sg_table into <strong>iomap</strong>, representing the memory of the <a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">ttm_resource</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt><dd><p>Offset that needs to be subtracted from <strong>st</strong> to make
sg_dma_address(st-&gt;sgl) - <strong>start</strong> == 0 for <strong>iomap</strong> start.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to the embedded struct ttm_kmap_iter.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_resource_manager_create_debugfs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_resource_manager_create_debugfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_resource_manager" title="ttm_resource_manager"><span class="n"><span class="pre">ttm_resource_manager</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">man</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">dentry</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">parent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_resource_manager_create_debugfs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create debugfs entry for specified resource manager.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource_manager</span> <span class="pre">*man</span></code></dt><dd><p>The TTM resource manager for which the debugfs stats file be creates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>debugfs directory in which the file will reside</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>The filename to create.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function setups up a debugfs file that can be used to look
at debug statistics of the specified ttm_resource_manager.</p>
</div>
</section>
<section id="ttm-tt-object-reference">
<h3>TTM TT object reference<a class="headerlink" href="#ttm-tt-object-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_tt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt</span></span></span><a class="headerlink" href="#c.ttm_tt" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is a structure holding the pages, caching- and aperture binding status for a buffer object that isn’t backed by fixed (VRAM / AGP) memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_tt {
    struct page **pages;
#define TTM_TT_FLAG_SWAPPED             BIT(0);
#define TTM_TT_FLAG_ZERO_ALLOC          BIT(1);
#define TTM_TT_FLAG_EXTERNAL            BIT(2);
#define TTM_TT_FLAG_EXTERNAL_MAPPABLE   BIT(3);
#define TTM_TT_FLAG_DECRYPTED           BIT(4);
#define TTM_TT_FLAG_PRIV_POPULATED      BIT(5);
    uint32_t page_flags;
    uint32_t num_pages;
    struct sg_table *sg;
    dma_addr_t *dma_address;
    struct file *swap_storage;
    enum ttm_caching caching;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pages</span></code></dt><dd><p>Array of pages backing the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_flags</span></code></dt><dd><p>The page flags.</p>
<p>Supported values:</p>
<p>TTM_TT_FLAG_SWAPPED: Set by TTM when the pages have been unpopulated
and swapped out by TTM.  Calling <a class="reference internal" href="#c.ttm_tt_populate" title="ttm_tt_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_tt_populate()</span></code></a> will then swap the
pages back in, and unset the flag. Drivers should in general never
need to touch this.</p>
<p>TTM_TT_FLAG_ZERO_ALLOC: Set if the pages will be zeroed on
allocation.</p>
<p>TTM_TT_FLAG_EXTERNAL: Set if the underlying pages were allocated
externally, like with dma-buf or userptr. This effectively disables
TTM swapping out such pages.  Also important is to prevent TTM from
ever directly mapping these pages.</p>
<p>Note that enum ttm_bo_type.ttm_bo_type_sg objects will always enable
this flag.</p>
<p>TTM_TT_FLAG_EXTERNAL_MAPPABLE: Same behaviour as
TTM_TT_FLAG_EXTERNAL, but with the reduced restriction that it is
still valid to use TTM to map the pages directly. This is useful when
implementing a ttm_tt backend which still allocates driver owned
pages underneath(say with shmem).</p>
<p>Note that since this also implies TTM_TT_FLAG_EXTERNAL, the usage
here should always be:</p>
<blockquote>
<div><dl class="simple">
<dt>page_flags = TTM_TT_FLAG_EXTERNAL |</dt><dd><p>TTM_TT_FLAG_EXTERNAL_MAPPABLE;</p>
</dd>
</dl>
</div></blockquote>
<p>TTM_TT_FLAG_DECRYPTED: The mapped ttm pages should be marked as
not encrypted. The framework will try to match what the dma layer
is doing, but note that it is a little fragile because ttm page
fault handling abuses the DMA api a bit and dma_map_attrs can’t be
used to assure pgprot always matches.</p>
<p>TTM_TT_FLAG_PRIV_POPULATED: TTM internal only. DO NOT USE. This is
set by TTM after <a class="reference internal" href="#c.ttm_tt_populate" title="ttm_tt_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_tt_populate()</span></code></a> has successfully returned, and is
then unset when TTM calls <a class="reference internal" href="#c.ttm_tt_unpopulate" title="ttm_tt_unpopulate"><code class="xref c c-func docutils literal notranslate"><span class="pre">ttm_tt_unpopulate()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_pages</span></code></dt><dd><p>Number of pages in the page array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sg</span></code></dt><dd><p>for SG objects via dma-buf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_address</span></code></dt><dd><p>The DMA (bus) addresses of the pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_storage</span></code></dt><dd><p>Pointer to shmem struct file for swap storage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>The current caching state of the pages, see <a class="reference internal" href="#c.ttm_caching" title="ttm_caching"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">ttm_caching</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_kmap_iter_tt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_kmap_iter_tt</span></span></span><a class="headerlink" href="#c.ttm_kmap_iter_tt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Specialization of a mappig iterator for a tt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_kmap_iter_tt {
    struct ttm_kmap_iter base;
    struct ttm_tt *tt;
    pgprot_t prot;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Embedded struct ttm_kmap_iter providing the usage interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tt</span></code></dt><dd><p>Cached <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prot</span></code></dt><dd><p>Cached page protection for mapping.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_buffer_object</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">zero_alloc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_create" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt><dd><p>pointer to a struct ttm_buffer_object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">zero_alloc</span></code></dt><dd><p>true if allocated pages needs to be zeroed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure we have a TTM structure allocated for the given BO.
No pages are actually allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_buffer_object</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">page_flags</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_caching" title="ttm_caching"><span class="n"><span class="pre">ttm_caching</span></span></a><span class="w"> </span><span class="n"><span class="pre">caching</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">extra_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_init" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>The <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt><dd><p>The buffer object we create the ttm for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">page_flags</span></code></dt><dd><p>Page flags as identified by TTM_TT_FLAG_XX flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ttm_caching</span> <span class="pre">caching</span></code></dt><dd><p>the desired caching state of the pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">extra_pages</span></code></dt><dd><p>Extra pages needed for the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a> to back data with system memory pages.
No pages are actually allocated.</p>
<p><strong>Return</strong></p>
<p>NULL: Out of memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_fini" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>the ttm_tt structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory of ttm_tt structure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_destroy" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the ttm_device this object belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>The <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unbind, unpopulate and destroy common <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_swapin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_swapin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_swapin" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>The <a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Swap in a previously swap out ttm_tt.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_populate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_populate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_operation_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_populate" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate pages for a ttm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the ttm_device this object belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>Pointer to the ttm_tt structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_operation_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>operation context for populating the tt object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the driver method to allocate pages for a ttm</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_unpopulate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_unpopulate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_unpopulate" title="Link to this definition">¶</a><br /></dt>
<dd><p>free pages from a ttm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the ttm_device this object belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>Pointer to the ttm_tt structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the driver method to free all pages from a ttm</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_tt_mark_for_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_tt_mark_for_clear</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ttm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_tt_mark_for_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Mark pages for clearing on populate.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*ttm</span></code></dt><dd><p>Pointer to the ttm_tt structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks pages for clearing so that the next time the page vector is
populated, the pages will be cleared.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_agp_tt_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ttm_agp_tt_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_buffer_object</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">agp_bridge_data</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bridge</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">page_flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_agp_tt_create" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt><dd><p>Buffer object we allocate the ttm for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">agp_bridge_data</span> <span class="pre">*bridge</span></code></dt><dd><p>The agp bridge this device is sitting on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">page_flags</span></code></dt><dd><p>Page flags as identified by TTM_TT_FLAG_XX flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a TTM backend that uses the indicated AGP bridge as an aperture
for TT memory. This function uses the linux agpgart interface to
bind and unbind memory backing a ttm_tt.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_kmap_iter_tt_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_kmap_iter</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">ttm_kmap_iter_tt_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_kmap_iter_tt" title="ttm_kmap_iter_tt"><span class="n"><span class="pre">ttm_kmap_iter_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">iter_tt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_kmap_iter_tt_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a <a class="reference internal" href="#c.ttm_kmap_iter_tt" title="ttm_kmap_iter_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_tt</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_tt</span> <span class="pre">*iter_tt</span></code></dt><dd><p>The <a class="reference internal" href="#c.ttm_kmap_iter_tt" title="ttm_kmap_iter_tt"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_kmap_iter_tt</span></code></a> to initialize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*tt</span></code></dt><dd><p>Struct ttm_tt holding page pointers of the <a class="reference internal" href="#c.ttm_resource" title="ttm_resource"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span></code></a>.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to the embedded struct ttm_kmap_iter.</p>
</div>
</section>
<section id="ttm-page-pool-reference">
<h3>TTM page pool reference<a class="headerlink" href="#ttm-page-pool-reference" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_pool_type">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_type</span></span></span><a class="headerlink" href="#c.ttm_pool_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pool for a certain memory type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_pool_type {
    struct ttm_pool *pool;
    unsigned int order;
    enum ttm_caching caching;
    struct list_head shrinker_list;
    spinlock_t lock;
    struct list_head pages;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pool</span></code></dt><dd><p>the pool we belong to, might be NULL for the global ones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">order</span></code></dt><dd><p>the allocation order our pages have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>the caching type our pages have</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shrinker_list</span></code></dt><dd><p>our place on the global shrinker list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protection of the page list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages</span></code></dt><dd><p>the list of pages in the pool</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.ttm_pool">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool</span></span></span><a class="headerlink" href="#c.ttm_pool" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pool for all caching and orders</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ttm_pool {
    struct device *dev;
    int nid;
    bool use_dma_alloc;
    bool use_dma32;
    struct {
        struct ttm_pool_type orders[NR_PAGE_ORDERS];
    } caching[TTM_NUM_CACHING_TYPES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the device we allocate pages for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nid</span></code></dt><dd><p>which numa node to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_dma_alloc</span></code></dt><dd><p>if coherent DMA allocations should be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_dma32</span></code></dt><dd><p>if GFP_DMA32 should be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>pools for each caching/order</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_pool_alloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_pool" title="ttm_pool"><span class="n"><span class="pre">ttm_pool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_operation_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_pool_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Fill a ttm_tt object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_pool</span> <span class="pre">*pool</span></code></dt><dd><p>ttm_pool to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*tt</span></code></dt><dd><p>ttm_tt object to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_operation_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>operation context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill the ttm_tt object with pages and also make sure to DMA map them when
necessary.</p>
<p><strong>Return</strong></p>
<p>0 on successe, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_pool_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_pool" title="ttm_pool"><span class="n"><span class="pre">ttm_pool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_tt" title="ttm_tt"><span class="n"><span class="pre">ttm_tt</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_pool_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free the backing pages from a ttm_tt object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_pool</span> <span class="pre">*pool</span></code></dt><dd><p>Pool to give pages back to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_tt</span> <span class="pre">*tt</span></code></dt><dd><p>ttm_tt object to unpopulate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Give the packing pages back to a pool or free them</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_pool_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_pool" title="ttm_pool"><span class="n"><span class="pre">ttm_pool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nid</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">use_dma_alloc</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">use_dma32</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_pool_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for DMA allocations and mappings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>NUMA node to use for allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_dma_alloc</span></code></dt><dd><p>true if coherent DMA alloc should be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_dma32</span></code></dt><dd><p>true if GFP_DMA32 should be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the pool and its pool types.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_pool_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_pool" title="ttm_pool"><span class="n"><span class="pre">ttm_pool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_pool_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Cleanup a pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool to clean up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all pages in the pool and unregister the types from the global
shrinker.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.ttm_pool_debugfs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ttm_pool_debugfs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_pool" title="ttm_pool"><span class="n"><span class="pre">ttm_pool</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pool</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">seq_file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ttm_pool_debugfs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Debugfs dump function for a pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool to dump the information for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>seq_file to dump to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a debugfs dump with the per pool and global information.</p>
</div>
</section>
</section>
<section id="the-graphics-execution-manager-gem">
<h2>The Graphics Execution Manager (GEM)<a class="headerlink" href="#the-graphics-execution-manager-gem" title="Link to this heading">¶</a></h2>
<p>The GEM design approach has resulted in a memory manager that doesn’t
provide full coverage of all (or even all common) use cases in its
userspace or kernel API. GEM exposes a set of standard memory-related
operations to userspace and a set of helper functions to drivers, and
let drivers implement hardware-specific operations with their own
private API.</p>
<p>The GEM userspace API is described in the <a class="reference external" href="http://lwn.net/Articles/283798/">GEM - the Graphics Execution
Manager</a> article on LWN. While
slightly outdated, the document provides a good overview of the GEM API
principles. Buffer allocation and read and write operations, described
as part of the common GEM API, are currently implemented using
driver-specific ioctls.</p>
<p>GEM is data-agnostic. It manages abstract buffer objects without knowing
what individual buffers contain. APIs that require knowledge of buffer
contents or purpose, such as buffer allocation or synchronization
primitives, are thus outside of the scope of GEM and must be implemented
using driver-specific ioctls.</p>
<p>On a fundamental level, GEM involves several operations:</p>
<ul class="simple">
<li><p>Memory allocation and freeing</p></li>
<li><p>Command execution</p></li>
<li><p>Aperture management at command execution time</p></li>
</ul>
<p>Buffer object allocation is relatively straightforward and largely
provided by Linux’s shmem layer, which provides memory to back each
object.</p>
<p>Device-specific operations, such as command execution, pinning, buffer
read &amp; write, mapping, and domain ownership transfers are left to
driver-specific ioctls.</p>
<section id="gem-initialization">
<h3>GEM Initialization<a class="headerlink" href="#gem-initialization" title="Link to this heading">¶</a></h3>
<p>Drivers that use GEM must set the DRIVER_GEM bit in the struct
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> driver_features
field. The DRM core will then automatically initialize the GEM core
before calling the load operation. Behind the scene, this will create a
DRM Memory Manager object which provides an address space pool for
object allocation.</p>
<p>In a KMS configuration, drivers need to allocate and initialize a
command ring buffer following core GEM initialization if required by the
hardware. UMA devices usually have what is called a “stolen” memory
region, which provides space for the initial framebuffer and large,
contiguous memory regions required by the device. This space is
typically not managed by GEM, and must be initialized separately into
its own DRM MM object.</p>
</section>
<section id="gem-objects-creation">
<h3>GEM Objects Creation<a class="headerlink" href="#gem-objects-creation" title="Link to this heading">¶</a></h3>
<p>GEM splits creation of GEM objects and allocation of the memory that
backs them in two distinct operations.</p>
<p>GEM objects are represented by an instance of struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a>. Drivers usually need to
extend GEM objects with private information and thus create a
driver-specific GEM object structure type that embeds an instance of
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a>.</p>
<p>To create a GEM object, a driver allocates memory for an instance of its
specific GEM object type and initializes the embedded struct
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a> with a call
to <a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a>. The function takes a pointer
to the DRM device, a pointer to the GEM object and the buffer object
size in bytes.</p>
<p>GEM uses shmem to allocate anonymous pageable memory.
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a> will create an shmfs file of the
requested size and store it into the struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a> filp field. The memory is
used as either main storage for the object when the graphics hardware
uses system memory directly or as a backing store otherwise.</p>
<p>Drivers are responsible for the actual physical pages allocation by
calling shmem_read_mapping_page_gfp() for each page.
Note that they can decide to allocate pages when initializing the GEM
object, or to delay allocation until the memory is needed (for instance
when a page fault occurs as a result of a userspace memory access or
when the driver needs to start a DMA transfer involving the memory).</p>
<p>Anonymous pageable memory allocation is not always desired, for instance
when the hardware requires physically contiguous system memory as is
often the case in embedded devices. Drivers can create GEM objects with
no shmfs backing (called private GEM objects) by initializing them with a call
to <a class="reference internal" href="#c.drm_gem_private_object_init" title="drm_gem_private_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_private_object_init()</span></code></a> instead of <a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a>. Storage for
private GEM objects must be managed by drivers.</p>
</section>
<section id="gem-objects-lifetime">
<h3>GEM Objects Lifetime<a class="headerlink" href="#gem-objects-lifetime" title="Link to this heading">¶</a></h3>
<p>All GEM objects are reference-counted by the GEM core. References can be
acquired and release by calling <a class="reference internal" href="#c.drm_gem_object_get" title="drm_gem_object_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_get()</span></code></a> and <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_put()</span></code></a>
respectively.</p>
<p>When the last reference to a GEM object is released the GEM core calls
the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object_funcs</span></code> free
operation. That operation is mandatory for GEM-enabled drivers and must
free the GEM object and all associated resources.</p>
<p>void (*free) (<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a> *obj); Drivers are
responsible for freeing all GEM object resources. This includes the
resources created by the GEM core, which need to be released with
<a class="reference internal" href="#c.drm_gem_object_release" title="drm_gem_object_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_release()</span></code></a>.</p>
</section>
<section id="gem-objects-naming">
<h3>GEM Objects Naming<a class="headerlink" href="#gem-objects-naming" title="Link to this heading">¶</a></h3>
<p>Communication between userspace and the kernel refers to GEM objects
using local handles, global names or, more recently, file descriptors.
All of those are 32-bit integer values; the usual Linux kernel limits
apply to the file descriptors.</p>
<p>GEM handles are local to a DRM file. Applications get a handle to a GEM
object through a driver-specific ioctl, and can use that handle to refer
to the GEM object in other standard or driver-specific ioctls. Closing a
DRM file handle frees all its GEM handles and dereferences the
associated GEM objects.</p>
<p>To create a handle for a GEM object drivers call <a class="reference internal" href="#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_handle_create()</span></code></a>. The
function takes a pointer to the DRM file and the GEM object and returns a
locally unique handle.  When the handle is no longer needed drivers delete it
with a call to <a class="reference internal" href="#c.drm_gem_handle_delete" title="drm_gem_handle_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_handle_delete()</span></code></a>. Finally the GEM object associated with a
handle can be retrieved by a call to <a class="reference internal" href="#c.drm_gem_object_lookup" title="drm_gem_object_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_lookup()</span></code></a>.</p>
<p>Handles don’t take ownership of GEM objects, they only take a reference
to the object that will be dropped when the handle is destroyed. To
avoid leaking GEM objects, drivers must make sure they drop the
reference(s) they own (such as the initial reference taken at object
creation time) as appropriate, without any special consideration for the
handle. For example, in the particular case of combined GEM object and
handle creation in the implementation of the dumb_create operation,
drivers must drop the initial reference to the GEM object before
returning the handle.</p>
<p>GEM names are similar in purpose to handles but are not local to DRM
files. They can be passed between processes to reference a GEM object
globally. Names can’t be used directly to refer to objects in the DRM
API, applications must convert handles to names and names to handles
using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
respectively. The conversion is handled by the DRM core without any
driver-specific support.</p>
<p>GEM also supports buffer sharing with dma-buf file descriptors through
PRIME. GEM-based drivers must use the provided helpers functions to
implement the exporting and importing correctly. See ?. Since sharing
file descriptors is inherently more secure than the easily guessable and
global GEM names it is the preferred buffer sharing mechanism. Sharing
buffers through GEM names is only supported for legacy userspace.
Furthermore PRIME also allows cross-device buffer sharing since it is
based on dma-bufs.</p>
</section>
<section id="gem-objects-mapping">
<h3>GEM Objects Mapping<a class="headerlink" href="#gem-objects-mapping" title="Link to this heading">¶</a></h3>
<p>Because mapping operations are fairly heavyweight GEM favours
read/write-like access to buffers, implemented through driver-specific
ioctls, over mapping buffers to userspace. However, when random access
to the buffer is needed (to perform software rendering for instance),
direct access to the object can be more efficient.</p>
<p>The mmap system call can’t be used directly to map GEM objects, as they
don’t have their own file handle. Two alternative methods currently
co-exist to map GEM objects to userspace. The first method uses a
driver-specific ioctl to perform the mapping operation, calling
do_mmap() under the hood. This is often considered
dubious, seems to be discouraged for new GEM-enabled drivers, and will
thus not be described here.</p>
<p>The second method uses the mmap system call on the DRM file handle. void
*mmap(void *addr, size_t length, int prot, int flags, int fd, off_t
offset); DRM identifies the GEM object to be mapped by a fake offset
passed through the mmap offset argument. Prior to being mapped, a GEM
object must thus be associated with a fake offset. To do so, drivers
must call <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_create_mmap_offset()</span></code></a> on the object.</p>
<p>Once allocated, the fake offset value must be passed to the application
in a driver-specific way and can then be used as the mmap offset
argument.</p>
<p>The GEM core provides a helper method <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a> to
handle object mapping. The method can be set directly as the mmap file
operation handler. It will look up the GEM object based on the offset
value and set the VMA operations to the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> gem_vm_ops field. Note that <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a> doesn’t map memory to
userspace, but relies on the driver-provided fault handler to map pages
individually.</p>
<p>To use <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a>, drivers must fill the struct <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> gem_vm_ops field with a pointer to VM operations.</p>
<p>The VM operations is a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_operations_struct</span></code>
made up of several fields, the more interesting ones being:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_operations_struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_area_struct</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">area</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_area_struct</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">area</span><span class="p">);</span>
<span class="w">        </span><span class="n">vm_fault_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fault</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_fault</span><span class="w"> </span><span class="o">*</span><span class="n">vmf</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The open and close operations must update the GEM object reference
count. Drivers can use the <a class="reference internal" href="#c.drm_gem_vm_open" title="drm_gem_vm_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vm_open()</span></code></a> and <a class="reference internal" href="#c.drm_gem_vm_close" title="drm_gem_vm_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vm_close()</span></code></a> helper
functions directly as open and close handlers.</p>
<p>The fault operation handler is responsible for mapping individual pages
to userspace when a page fault occurs. Depending on the memory
allocation scheme, drivers can allocate pages at fault time, or can
decide to allocate memory for the GEM object at the time the object is
created.</p>
<p>Drivers that want to map the GEM object upfront instead of handling page
faults can implement their own mmap file operation handler.</p>
<p>For platforms without MMU the GEM core provides a helper method
<a class="reference internal" href="#c.drm_gem_dma_get_unmapped_area" title="drm_gem_dma_get_unmapped_area"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_get_unmapped_area()</span></code></a>. The mmap() routines will call this to get a
proposed address for the mapping.</p>
<p>To use <a class="reference internal" href="#c.drm_gem_dma_get_unmapped_area" title="drm_gem_dma_get_unmapped_area"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_get_unmapped_area()</span></code></a>, drivers must fill the struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code> get_unmapped_area field with
a pointer on <a class="reference internal" href="#c.drm_gem_dma_get_unmapped_area" title="drm_gem_dma_get_unmapped_area"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_get_unmapped_area()</span></code></a>.</p>
<p>More detailed information about get_unmapped_area can be found in
<a class="reference internal" href="../admin-guide/mm/nommu-mmap.html"><span class="doc">No-MMU memory mapping support</span></a></p>
</section>
<section id="memory-coherency">
<h3>Memory Coherency<a class="headerlink" href="#memory-coherency" title="Link to this heading">¶</a></h3>
<p>When mapped to the device or used in a command buffer, backing pages for
an object are flushed to memory and marked write combined so as to be
coherent with the GPU. Likewise, if the CPU accesses an object after the
GPU has finished rendering to the object, then the object must be made
coherent with the CPU’s view of memory, usually involving GPU cache
flushing of various kinds. This core CPU&lt;-&gt;GPU coherency management is
provided by a device-specific ioctl, which evaluates an object’s current
domain and performs any necessary flushing or synchronization to put the
object into the desired coherency domain (note that the object may be
busy, i.e. an active render target; in that case, setting the domain
blocks the client and waits for rendering to complete before performing
any necessary flushing operations).</p>
</section>
<section id="command-execution">
<h3>Command Execution<a class="headerlink" href="#command-execution" title="Link to this heading">¶</a></h3>
<p>Perhaps the most important GEM function for GPU devices is providing a
command execution interface to clients. Client programs construct
command buffers containing references to previously allocated memory
objects, and then submit them to GEM. At that point, GEM takes care to
bind all the objects into the GTT, execute the buffer, and provide
necessary synchronization between clients accessing the same buffers.
This often involves evicting some objects from the GTT and re-binding
others (a fairly expensive operation), and providing relocation support
which hides fixed GTT offsets from clients. Clients must take care not
to submit command buffers that reference more objects than can fit in
the GTT; otherwise, GEM will reject them and no rendering will occur.
Similarly, if several objects in the buffer require fence registers to
be allocated for correct rendering (e.g. 2D blits on pre-965 chips),
care must be taken not to require more fence registers than are
available to the client. Such resource management should be abstracted
from the client in libdrm.</p>
</section>
<section id="gem-function-reference">
<h3>GEM Function Reference<a class="headerlink" href="#gem-function-reference" title="Link to this heading">¶</a></h3>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_gem_object_status">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_status</span></span></span><a class="headerlink" href="#c.drm_gem_object_status" title="Link to this definition">¶</a><br /></dt>
<dd><p>bitmask of object state for fdinfo reporting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GEM_OBJECT_RESIDENT</span></code></dt><dd><p>object is resident in memory (ie. not unpinned)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GEM_OBJECT_PURGEABLE</span></code></dt><dd><p>object marked as purgeable by userspace</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Bitmask of status used for fdinfo memory stats, see <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.status</span></code></a>
and <a class="reference internal" href="drm-internals.html#c.drm_show_fdinfo" title="drm_show_fdinfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_show_fdinfo()</span></code></a>.  Note that an object can DRM_GEM_OBJECT_PURGEABLE if
it still active or not resident, in which case <a class="reference internal" href="drm-internals.html#c.drm_show_fdinfo" title="drm_show_fdinfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_show_fdinfo()</span></code></a> will not
account for it as purgeable.  So drivers do not need to check if the buffer
is idle and resident to return this bit.  (Ie. userspace can mark a buffer
as purgeable even while it is still busy on the GPU.. it does not _actually_
become puregeable until it becomes idle.  The status gem object func does
not need to consider this.)</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_object_funcs">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_funcs</span></span></span><a class="headerlink" href="#c.drm_gem_object_funcs" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object functions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_object_funcs {
    void (*free)(struct drm_gem_object *obj);
    int (*open)(struct drm_gem_object *obj, struct drm_file *file);
    void (*close)(struct drm_gem_object *obj, struct drm_file *file);
    void (*print_info)(struct drm_printer *p, unsigned int indent, const struct drm_gem_object *obj);
    struct dma_buf *(*export)(struct drm_gem_object *obj, int flags);
    int (*pin)(struct drm_gem_object *obj);
    void (*unpin)(struct drm_gem_object *obj);
    struct sg_table *(*get_sg_table)(struct drm_gem_object *obj);
    int (*vmap)(struct drm_gem_object *obj, struct iosys_map *map);
    void (*vunmap)(struct drm_gem_object *obj, struct iosys_map *map);
    int (*mmap)(struct drm_gem_object *obj, struct vm_area_struct *vma);
    int (*evict)(struct drm_gem_object *obj);
    enum drm_gem_object_status (*status)(struct drm_gem_object *obj);
    size_t (*rss)(struct drm_gem_object *obj);
    const struct vm_operations_struct *vm_ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>Deconstructor for drm_gem_objects.</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>Called upon GEM handle creation.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p>Called upon GEM handle release.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">print_info</span></code></dt><dd><p>If driver subclasses struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>, it can implement this
optional hook for printing additional driver specific info.</p>
<p><a class="reference internal" href="drm-internals.html#c.drm_printf_indent" title="drm_printf_indent"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_printf_indent()</span></code></a> should be used in the callback passing it the
indent argument.</p>
<p>This callback is called from drm_gem_print_info().</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">export</span></code></dt><dd><p>Export backing buffer as a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>.
If this is not set <a class="reference internal" href="#c.drm_gem_prime_export" title="drm_gem_prime_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_export()</span></code></a> is used.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pin</span></code></dt><dd><p>Pin backing buffer in memory. Used by the <a class="reference internal" href="#c.drm_gem_map_attach" title="drm_gem_map_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_attach()</span></code></a> helper.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unpin</span></code></dt><dd><p>Unpin backing buffer. Used by the <a class="reference internal" href="#c.drm_gem_map_detach" title="drm_gem_map_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_detach()</span></code></a> helper.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_sg_table</span></code></dt><dd><p>Returns a Scatter-Gather table representation of the buffer.
Used when exporting a buffer by the <a class="reference internal" href="#c.drm_gem_map_dma_buf" title="drm_gem_map_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_dma_buf()</span></code></a> helper.
Releasing is done by calling dma_unmap_sg_attrs() and sg_free_table()
in drm_gem_unmap_buf(), therefore these helpers and this callback
here cannot be used for sg tables pointing at driver private memory
ranges.</p>
<p>See also <a class="reference internal" href="#c.drm_prime_pages_to_sg" title="drm_prime_pages_to_sg"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_prime_pages_to_sg()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap</span></code></dt><dd><p>Returns a virtual address for the buffer. Used by the
<a class="reference internal" href="#c.drm_gem_dmabuf_vmap" title="drm_gem_dmabuf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_vmap()</span></code></a> helper.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vunmap</span></code></dt><dd><p>Releases the address previously returned by <strong>vmap</strong>. Used by the
<a class="reference internal" href="#c.drm_gem_dmabuf_vunmap" title="drm_gem_dmabuf_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_vunmap()</span></code></a> helper.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>Handle mmap() of the gem object, setup vma accordingly.</p>
<p>This callback is optional.</p>
<p>The callback is used by both <a class="reference internal" href="#c.drm_gem_mmap_obj" title="drm_gem_mmap_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap_obj()</span></code></a> and
<a class="reference internal" href="#c.drm_gem_prime_mmap" title="drm_gem_prime_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_mmap()</span></code></a>.  When <strong>mmap</strong> is present <strong>vm_ops</strong> is not
used, the <strong>mmap</strong> callback must set vma-&gt;vm_ops instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evict</span></code></dt><dd><p>Evicts gem object out from memory. Used by the drm_gem_object_evict()
helper. Returns 0 on success, -errno otherwise.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>The optional status callback can return additional object state
which determines which stats the object is counted against.  The
callback is called under table_lock.  Racing against object status
change is “harmless”, and the callback can expect to not race
against object destruction.</p>
<p>Called by <a class="reference internal" href="drm-internals.html#c.drm_show_memory_stats" title="drm_show_memory_stats"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_show_memory_stats()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rss</span></code></dt><dd><p>Return resident size of the object in physical memory.</p>
<p>Called by <a class="reference internal" href="drm-internals.html#c.drm_show_memory_stats" title="drm_show_memory_stats"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_show_memory_stats()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_ops</span></code></dt><dd><p>Virtual memory operations used with mmap.</p>
<p>This is optional but necessary for mmap support.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_lru">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru</span></span></span><a class="headerlink" href="#c.drm_gem_lru" title="Link to this definition">¶</a><br /></dt>
<dd><p>A simple LRU helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_lru {
    struct mutex *lock;
    long count;
    struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Lock protecting movement of GEM objects between LRUs.  All
LRUs that the object can move between should be protected
by the same lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>The total number of backing pages of the GEM objects in
this LRU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>The LRU list.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A helper for tracking GEM objects in a given state, to aid in
driver’s shrinker implementation.  Tracks the count of pages
for lockless <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker.count_objects</span></code>, and provides
<a class="reference internal" href="#c.drm_gem_lru_scan" title="drm_gem_lru_scan"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_lru_scan</span></code></a> for driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker.scan_objects</span></code>
implementation.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_object">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object</span></span></span><a class="headerlink" href="#c.drm_gem_object" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM buffer object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_object {
    struct kref refcount;
    unsigned handle_count;
    struct drm_device *dev;
    struct file *filp;
    struct drm_vma_offset_node vma_node;
    size_t size;
    int name;
    struct dma_buf *dma_buf;
    struct dma_buf_attachment *import_attach;
    struct dma_resv *resv;
    struct dma_resv _resv;
    struct {
        struct list_head list;
#ifdef CONFIG_LOCKDEP;
        struct lockdep_map *lock_dep_map;
#endif;
    } gpuva;
    const struct drm_gem_object_funcs *funcs;
    struct list_head lru_node;
    struct drm_gem_lru *lru;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>Reference count of this object</p>
<p>Please use <a class="reference internal" href="#c.drm_gem_object_get" title="drm_gem_object_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_get()</span></code></a> to acquire and drm_gem_object_put_locked()
or <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_put()</span></code></a> to release a reference to a GEM
buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle_count</span></code></dt><dd><p>This is the GEM file_priv handle count of this object.</p>
<p>Each handle also holds a reference. Note that when the handle_count
drops to 0 any global names (e.g. the id in the flink namespace) will
be cleared.</p>
<p>Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.object_name_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM dev this object belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filp</span></code></dt><dd><p>SHMEM file node used as backing storage for swappable buffer objects.
GEM also supports driver private objects with driver-specific backing
storage (contiguous DMA memory, special reserved blocks). In this
case <strong>filp</strong> is NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vma_node</span></code></dt><dd><p>Mapping info for this object to support mmap. Drivers are supposed to
allocate the mmap offset using <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>. The
offset itself can be retrieved using <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_offset_addr()</span></code></a>.</p>
<p>Memory mapping itself is handled by <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a>, which also checks
that userspace is allowed to access the object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the object, in bytes.  Immutable over the object’s
lifetime.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Global name for this object, starts at 1. 0 means unnamed.
Access is covered by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.object_name_lock</span></code></a>. This is used by
the GEM_FLINK and GEM_OPEN ioctls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_buf</span></code></dt><dd><p>dma-buf associated with this GEM object.</p>
<p>Pointer to the dma-buf associated with this gem object (either
through importing or exporting). We break the resulting reference
loop when the last gem handle for this object is released.</p>
<p>Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.object_name_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">import_attach</span></code></dt><dd><p>dma-buf attachment backing this object.</p>
<p>Any foreign dma_buf imported as a gem object has this set to the
attachment point for the device. This is invariant over the lifetime
of a gem object.</p>
<p>The <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.free</span></code></a> callback is responsible for
cleaning up the dma_buf attachment and references acquired at import
time.</p>
<p>Note that the drm gem/prime core does not depend upon drivers setting
this field any more. So for drivers where this doesn’t make sense
(e.g. virtual devices or a displaylink behind an usb bus) they can
simply leave it as NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resv</span></code></dt><dd><p>Pointer to reservation object associated with the this GEM object.</p>
<p>Normally (<strong>resv</strong> == &amp;**_resv**) except for imported GEM objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_resv</span></code></dt><dd><p>A reservation object for this GEM object.</p>
<p>This is unused for imported GEM objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpuva</span></code></dt><dd><p>Provides the list of GPU VAs attached to this GEM object.</p>
<p>Drivers should lock list accesses with the GEMs <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock
(<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.resv</span></code></a>) or a custom lock if one is provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Optional GEM object functions. If this is set, it will be used instead of the
corresponding <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> GEM callbacks.</p>
<p>New drivers should use this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru_node</span></code></dt><dd><p>List node in a <a class="reference internal" href="#c.drm_gem_lru" title="drm_gem_lru"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_lru</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lru</span></code></dt><dd><p>The current LRU list that the GEM object is on.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure defines the generic parts for GEM buffer objects, which are
mostly around handling mmap and userspace handles.</p>
<p>Buffer objects are often abbreviated to BO.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_FOPS">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_FOPS</span></span></span><a class="headerlink" href="#c.DRM_GEM_FOPS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_FOPS</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>Default drm GEM file operations</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro provides a shorthand for setting the GEM file ops in the
<code class="xref c c-type docutils literal notranslate"><span class="pre">file_operations</span></code> structure.  If all you need are the default ops, use
DEFINE_DRM_GEM_FOPS instead.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_DRM_GEM_FOPS">
<span class="sig-name descname"><span class="n"><span class="pre">DEFINE_DRM_GEM_FOPS</span></span></span><a class="headerlink" href="#c.DEFINE_DRM_GEM_FOPS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEFINE_DRM_GEM_FOPS</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>macro to generate file operations for GEM drivers</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name for the generated structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro autogenerates a suitable <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code> for GEM based
drivers, which can be assigned to <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.fops</span></code></a>. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS_MODULE.</p>
<p>Note that the declaration is already marked as static - if you need a
non-static version of this you’re probably doing it wrong and will break the
THIS_MODULE reference by accident.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>acquire a GEM buffer object reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM buffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires an additional reference to <strong>obj</strong>. It is illegal to
call this without already holding a reference. No locks required.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>drop a GEM buffer object reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM buffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>obj</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_is_shared_for_memory_stats">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_is_shared_for_memory_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_is_shared_for_memory_stats" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper for shared memory stats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper should only be used for fdinfo shared memory stats to determine
if a GEM object is shared.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gem_gpuva_set_lock">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gem_gpuva_set_lock</span></span></span><a class="headerlink" href="#c.drm_gem_gpuva_set_lock" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gem_gpuva_set_lock</span> <span class="pre">(obj,</span> <span class="pre">lock)</span></code></p>
<blockquote>
<div><p>Set the lock protecting accesses to the gpuva list.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>the lock used to protect the gpuva list. The locking primitive
must contain a dep_map field.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this if you’re not proctecting access to the gpuva list with the
dma-resv lock, but with a custom lock.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_gpuva_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_gpuva_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_gpuva_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize the gpuva list of a GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This initializes the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>’s <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> list.</p>
<p>Calling this function is only necessary for drivers intending to support the
<a class="reference internal" href="drm-internals.html#c.drm_driver_feature" title="drm_driver_feature"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver_feature</span></code></a> DRIVER_GEM_GPUVA.</p>
<p>See also <a class="reference internal" href="#c.drm_gem_gpuva_set_lock" title="drm_gem_gpuva_set_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_gpuva_set_lock()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gem_for_each_gpuvm_bo">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gem_for_each_gpuvm_bo</span></span></span><a class="headerlink" href="#c.drm_gem_for_each_gpuvm_bo" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gem_for_each_gpuvm_bo</span> <span class="pre">(entry__,</span> <span class="pre">obj__)</span></code></p>
<blockquote>
<div><p>iterator to walk over a list of <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> structure to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to walk are associated with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> structures associated with the
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gem_for_each_gpuvm_bo_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gem_for_each_gpuvm_bo_safe</span></span></span><a class="headerlink" href="#c.drm_gem_for_each_gpuvm_bo_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gem_for_each_gpuvm_bo_safe</span> <span class="pre">(entry__,</span> <span class="pre">next__,</span> <span class="pre">obj__)</span></code></p>
<blockquote>
<div><p>iterator to safely walk over a list of <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry__</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bostructure</span></code> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next__</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">next</span></code> <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to store the next step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to walk are associated with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> structures associated with the
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. It is implemented with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_safe" title="list_for_each_entry_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_safe()</span></code></a>, hence
it is save against removal of elements.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize an allocated shmem-backed GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device the object should be initialized for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm_gem_object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>object size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an already allocated GEM object of the specified size with
shmfs backing store.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_private_object_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_private_object_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_private_object_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize an allocated private GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device the object should be initialized for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm_gem_object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>object size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an already allocated GEM object of the specified size with
no GEM provided backing store. Instead the caller is responsible for
backing the object and handling it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_private_object_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_private_object_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_private_object_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Finalize a failed drm_gem_object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>drm_gem_object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uninitialize an already allocated GEM object when it initialized failed</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_handle_delete">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_handle_delete</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_handle_delete" title="Link to this definition">¶</a><br /></dt>
<dd><p>deletes the given file-private handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*filp</span></code></dt><dd><p>drm file-private structure to use for the handle look up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>userspace handle to delete</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the GEM handle from the <strong>filp</strong> lookup table which has been added with
<a class="reference internal" href="#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_handle_create()</span></code></a>. If this is the last handle also cleans up linked
resources like GEM names.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dumb_map_offset">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dumb_map_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dumb_map_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>return the fake mmap offset for a gem object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file-private structure containing the gem object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>corresponding drm_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>gem object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*offset</span></code></dt><dd><p>return location for the fake mmap offset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_map_offset</span></code></a> kms driver callback for
drivers which use gem to manage their backing storage.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_handle_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_handle_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_priv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handlep</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_handle_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a gem handle for an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file-private structure to register the handle for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>object to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*handlep</span></code></dt><dd><p>pointer to return the created handle to the caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a handle for this object. This adds a handle reference to the object,
which includes a regular reference count. Callers will likely want to
dereference the object afterwards.</p>
<p>Since this publishes <strong>obj</strong> to userspace it must be fully set up by this point,
drivers must call this last in their buffer object creation callbacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_free_mmap_offset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_free_mmap_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_free_mmap_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a fake mmap offset for an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine frees fake offsets allocated by <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.drm_gem_object_release" title="drm_gem_object_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_release()</span></code></a> already calls this function, so drivers
don’t have to take care of releasing the mmap offset themselves when freeing
the GEM object.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_create_mmap_offset_size">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_create_mmap_offset_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_create_mmap_offset_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a fake mmap offset for an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the virtual size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.</p>
<p>This routine allocates and attaches a fake offset for <strong>obj</strong>, in cases where
the virtual size differs from the physical size (ie. <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.size</span></code></a>).
Otherwise just use <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>.</p>
<p>This function is idempotent and handles an already allocated mmap offset
transparently. Drivers do not need to check for this case.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_create_mmap_offset">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_create_mmap_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_create_mmap_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a fake mmap offset for an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.</p>
<p>This routine allocates and attaches a fake offset for <strong>obj</strong>.</p>
<p>Drivers can call <a class="reference internal" href="#c.drm_gem_free_mmap_offset" title="drm_gem_free_mmap_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_free_mmap_offset()</span></code></a> before freeing <strong>obj</strong> to release
the fake offset again.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_get_pages">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_get_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_get_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to allocate backing pages for a GEM object from shmem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the page-array of the shmem-backing storage of the given gem
object. An array of pages is returned. If a page is not allocated or
swapped-out, this will allocate/swap-in the required pages. Note that the
whole object is covered by the page-array and pinned in memory.</p>
<p>Use <a class="reference internal" href="#c.drm_gem_put_pages" title="drm_gem_put_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_put_pages()</span></code></a> to release the array and unpin all pages.</p>
<p>This uses the GFP-mask set on the shmem-mapping (see mapping_set_gfp_mask()).
If you require other GFP-masks, you have to do those allocations yourself.</p>
<p>Note that you are not allowed to change gfp-zones during runtime. That is,
shmem_read_mapping_page_gfp() must be called with the same gfp_zone(gfp) as
set during initialization. If you have special zone constraints, set them
after <a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a> via mapping_set_gfp_mask(). shmem-core takes care
to keep pages in the required zone during swap-in.</p>
<p>This function is only valid on objects initialized with
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a>, but not for those initialized with
<a class="reference internal" href="#c.drm_gem_private_object_init" title="drm_gem_private_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_private_object_init()</span></code></a> only.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_put_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_put_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">dirty</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">accessed</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_put_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to free backing pages for a GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pages to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">dirty</span></code></dt><dd><p>if true, pages will be marked as dirty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">accessed</span></code></dt><dd><p>if true, the pages will be marked as accessed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_objects_lookup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_objects_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="pre">__user</span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo_handles</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objs_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_objects_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>look up GEM objects from an array of handles</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*filp</span></code></dt><dd><p>DRM file private date</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*bo_handles</span></code></dt><dd><p>user pointer to array of userspace handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>size of handle array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">***objs_out</span></code></dt><dd><p>returned pointer to array of drm_gem_object pointers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an array of userspace handles and returns a newly allocated array of
GEM objects.</p>
<p>For a single handle lookup, use <a class="reference internal" href="#c.drm_gem_object_lookup" title="drm_gem_object_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_lookup()</span></code></a>.</p>
<p><strong>objs</strong> filled in with GEM object pointers. Returned GEM objects need to be
released with <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_put()</span></code></a>. -ENOENT is returned on a lookup
failure. 0 is returned on success.</p>
<p><strong>Return</strong></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_lookup">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>look up a GEM object from its handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*filp</span></code></dt><dd><p>DRM file private date</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>userspace handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>Description</strong></p>
<p>A reference to the object named by the handle if such exists on <strong>filp</strong>, NULL
otherwise.</p>
<p>If looking up an array of handles, use <a class="reference internal" href="#c.drm_gem_objects_lookup" title="drm_gem_objects_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_objects_lookup()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_resv_wait">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_resv_wait</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filep</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">wait_all</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_resv_wait" title="Link to this definition">¶</a><br /></dt>
<dd><p>Wait on GEM object’s reservation’s objects shared and/or exclusive fences.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*filep</span></code></dt><dd><p>DRM file private date</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>userspace handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wait_all</span></code></dt><dd><p>if true, wait on all fences, else wait on just exclusive fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies or zero to return immediately</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or
greater than 0 on success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>release GEM buffer object resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM buffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases any structures and resources used by <strong>obj</strong> and is the inverse of
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_object_init()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_object_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_object_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object_free" title="kref"><span class="n"><span class="pre">kref</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p>kref of the object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after the last reference to the object has been lost.</p>
<p>Frees the object</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vm_open">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vm_open</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vm_open" title="Link to this definition">¶</a><br /></dt>
<dd><p>vma-&gt;ops-&gt;open implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VM area structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the #vm_operations_struct open() callback for GEM
drivers. This must be used together with <a class="reference internal" href="#c.drm_gem_vm_close" title="drm_gem_vm_close"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vm_close()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vm_close">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vm_close</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vm_close" title="Link to this definition">¶</a><br /></dt>
<dd><p>vma-&gt;ops-&gt;close implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VM area structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the #vm_operations_struct close() callback for GEM
drivers. This must be used together with <a class="reference internal" href="#c.drm_gem_vm_open" title="drm_gem_vm_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vm_open()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_mmap_obj">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_mmap_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">obj_size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_mmap_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>memory map a GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the GEM object to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">obj_size</span></code></dt><dd><p>the object size to be mapped, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the VMA to prepare mapping of the GEM object using the GEM object’s
vm_ops. Depending on their requirements, GEM objects can either
provide a fault handler in their vm_ops (in which case any accesses to
the object will be trapped, to perform migration, GTT binding, surface
register allocation, or performance monitoring), or mmap the buffer memory
synchronously after calling drm_gem_mmap_obj.</p>
<p>This function is mainly intended to implement the DMABUF mmap operation, when
the GEM object is not looked up based on its fake offset. To implement the
DRM mmap operation, drivers should use the <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a> function.</p>
<p><a class="reference internal" href="#c.drm_gem_mmap_obj" title="drm_gem_mmap_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap_obj()</span></code></a> assumes the user is granted access to the buffer while
<a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap()</span></code></a> prevents unprivileged users from mapping random objects. So
callers must verify access restrictions before calling this helper.</p>
<p>Return 0 or success or -EINVAL if the object size is smaller than the VMA
size, or if no vm_ops are provided.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>memory map routine for GEM objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>DRM file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a driver supports GEM object mapping, mmap calls on the DRM file
descriptor will end up here.</p>
<p>Look up the GEM object based on the offset passed in (vma-&gt;vm_pgoff will
contain the fake offset we created when the GTT map ioctl was called on
the object) and map it with a call to <a class="reference internal" href="#c.drm_gem_mmap_obj" title="drm_gem_mmap_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_mmap_obj()</span></code></a>.</p>
<p>If the caller is not granted access to the buffer object, the mmap will fail
with EACCES. Please see the vma manager for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lock_reservations">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lock_reservations</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">count</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ww_acquire_ctx</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">acquire_ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lock_reservations" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets up the ww context and acquires the lock on an array of GEM objects.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">**objs</span></code></dt><dd><p>drm_gem_objects to lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of objects in <strong>objs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*acquire_ctx</span></code></dt><dd><p>struct ww_acquire_ctx that will be initialized as
part of tracking this set of locked reservations.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once you’ve locked your reservations, you’ll want to set up space
for your shared fences (if applicable), submit your job, then
drm_gem_unlock_reservations().</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lru_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_lru" title="drm_gem_lru"><span class="n"><span class="pre">drm_gem_lru</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lru</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">mutex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lru_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a LRU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_lru</span> <span class="pre">*lru</span></code></dt><dd><p>The LRU to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The lock protecting the LRU</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lru_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lru_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove object from whatever LRU it is in</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The GEM object to remove from current LRU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the object is currently in any LRU, remove it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lru_move_tail_locked">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru_move_tail_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_lru" title="drm_gem_lru"><span class="n"><span class="pre">drm_gem_lru</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lru</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lru_move_tail_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>move the object to the tail of the LRU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_lru</span> <span class="pre">*lru</span></code></dt><dd><p>The LRU to move the object into.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The GEM object to move into this LRU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.drm_gem_lru_move_tail" title="drm_gem_lru_move_tail"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_lru_move_tail</span></code></a> but lru lock must be held</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lru_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_lru" title="drm_gem_lru"><span class="n"><span class="pre">drm_gem_lru</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lru</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lru_move_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>move the object to the tail of the LRU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_lru</span> <span class="pre">*lru</span></code></dt><dd><p>The LRU to move the object into.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The GEM object to move into this LRU</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the object is already in this LRU it will be moved to the
tail.  Otherwise it will be removed from whichever other LRU
it is in (if any) and moved into this LRU.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_lru_scan">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_lru_scan</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_lru" title="drm_gem_lru"><span class="n"><span class="pre">drm_gem_lru</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lru</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_to_scan</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remaining</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shrink</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_lru_scan" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to implement shrinker.scan_objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_lru</span> <span class="pre">*lru</span></code></dt><dd><p>The LRU to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_to_scan</span></code></dt><dd><p>The number of pages to try to reclaim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*remaining</span></code></dt><dd><p>The number of pages left to reclaim, should be initialized by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*shrink)(struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj)</span></code></dt><dd><p>Callback to try to shrink/reclaim the object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the shrink callback succeeds, it is expected that the driver
move the object out of this LRU.</p>
<p>If the LRU possibly contain active buffers, it is the responsibility
of the shrink callback to check for this (ie. <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_test_signaled" title="dma_resv_test_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_test_signaled()</span></code></a>)
or if necessary block until the buffer becomes idle.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_evict">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_evict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_evict" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to evict backing pages for a GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>obj in question</p>
</dd>
</dl>
</div>
</section>
<section id="gem-dma-helper-functions-reference">
<h3>GEM DMA Helper Functions Reference<a class="headerlink" href="#gem-dma-helper-functions-reference" title="Link to this heading">¶</a></h3>
<p>The DRM GEM/DMA helpers are a means to provide buffer objects that are
presented to the device as a contiguous chunk of memory. This is useful
for devices that do not support scatter-gather DMA (either directly or
by using an intimately attached IOMMU).</p>
<p>For devices that access the memory bus through an (external) IOMMU then
the buffer objects are allocated using a traditional page-based
allocator and may be scattered through physical memory. However they
are contiguous in the IOVA space so appear contiguous to devices using
them.</p>
<p>For other devices then the helpers rely on CMA to provide buffer
objects that are physically contiguous in memory.</p>
<p>For GEM callback helpers in struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> functions, see likewise
named functions with an _object_ infix (e.g., drm_gem_dma_object_vmap() wraps
<a class="reference internal" href="#c.drm_gem_dma_vmap" title="drm_gem_dma_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_vmap()</span></code></a>). These helpers perform the necessary type conversion.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_dma_object">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_object</span></span></span><a class="headerlink" href="#c.drm_gem_dma_object" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object backed by DMA memory allocations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_dma_object {
    struct drm_gem_object base;
    dma_addr_t dma_addr;
    struct sg_table *sgt;
    void *vaddr;
    bool map_noncoherent;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt><dd><p>DMA address of the backing memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgt</span></code></dt><dd><p>scatter/gather table for imported PRIME buffers. The table can have
more than one entry but they are guaranteed to have contiguous
DMA addresses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr</span></code></dt><dd><p>kernel virtual address of the backing memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_noncoherent</span></code></dt><dd><p>if true, the GEM object is backed by non-coherent memory</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_object_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_object_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_object_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_dma_free" title="drm_gem_dma_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_free()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps drm_gem_dma_free_object(). Drivers that employ the DMA helpers
should use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.free</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_object_print_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_object_print_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">indent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_object_print_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_dma_object</span></code></a> info for debugfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_dma_print_info" title="drm_gem_dma_print_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_print_info()</span></code></a>. Drivers that employ the DMA helpers
should use this function as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.print_info</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_object_get_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_object_get_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_object_get_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_dma_get_sg_table" title="drm_gem_dma_get_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_get_sg_table()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_dma_get_sg_table" title="drm_gem_dma_get_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_get_sg_table()</span></code></a>. Drivers that employ the DMA helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a> handler.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_object_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_object_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_object_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_dma_mmap" title="drm_gem_dma_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_mmap()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_dma_mmap" title="drm_gem_dma_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_mmap()</span></code></a>. Drivers that employ the dma helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.mmap</span></code></a> handler.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE</span></span></span><a class="headerlink" href="#c.DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE</span> <span class="pre">(dumb_create_func)</span></code></p>
<blockquote>
<div><p>DMA GEM driver operations</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dumb_create_func</span></code></dt><dd><p>callback function for .dumb_create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the default GEM operations in the
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure.</p>
<p>This macro is a variant of DRM_GEM_DMA_DRIVER_OPS for drivers that
override the default implementation of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rm_driver</span></code>.dumb_create. Use
DRM_GEM_DMA_DRIVER_OPS if possible. Drivers that require a virtual address
on imported buffers should use
<a class="reference internal" href="#c.DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE" title="DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE()</span></code></a> instead.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_DMA_DRIVER_OPS">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_DMA_DRIVER_OPS</span></span></span><a class="headerlink" href="#c.DRM_GEM_DMA_DRIVER_OPS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>DMA GEM driver operations</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the default GEM operations in the
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure.</p>
<p>Drivers that come with their own implementation of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create should use
<a class="reference internal" href="#c.DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE" title="DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE()</span></code></a> instead. Use
DRM_GEM_DMA_DRIVER_OPS if possible. Drivers that require a virtual address
on imported buffers should use DRM_GEM_DMA_DRIVER_OPS_VMAP instead.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE</span></span></span><a class="headerlink" href="#c.DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE</span> <span class="pre">(dumb_create_func)</span></code></p>
<blockquote>
<div><p>DMA GEM driver operations ensuring a virtual address on the buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dumb_create_func</span></code></dt><dd><p>callback function for .dumb_create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the default GEM operations in the
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure for drivers that need the virtual address also on
imported buffers.</p>
<p>This macro is a variant of DRM_GEM_DMA_DRIVER_OPS_VMAP for drivers that
override the default implementation of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create. Use
DRM_GEM_DMA_DRIVER_OPS_VMAP if possible. Drivers that do not require a
virtual address on imported buffers should use
<a class="reference internal" href="#c.DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE" title="DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE()</span></code></a> instead.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_DMA_DRIVER_OPS_VMAP">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP</span></span></span><a class="headerlink" href="#c.DRM_GEM_DMA_DRIVER_OPS_VMAP" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>DMA GEM driver operations ensuring a virtual address on the buffer</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the default GEM operations in the
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure for drivers that need the virtual address also on
imported buffers.</p>
<p>Drivers that come with their own implementation of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create should use
<a class="reference internal" href="#c.DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE" title="DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE()</span></code></a> instead. Use
DRM_GEM_DMA_DRIVER_OPS_VMAP if possible. Drivers that do not require a
virtual address on imported buffers should use DRM_GEM_DMA_DRIVER_OPS
instead.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DEFINE_DRM_GEM_DMA_FOPS">
<span class="sig-name descname"><span class="n"><span class="pre">DEFINE_DRM_GEM_DMA_FOPS</span></span></span><a class="headerlink" href="#c.DEFINE_DRM_GEM_DMA_FOPS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DEFINE_DRM_GEM_DMA_FOPS</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>macro to generate file operations for DMA drivers</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name for the generated structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro autogenerates a suitable <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code> for DMA based
drivers, which can be assigned to <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.fops</span></code></a>. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS_MODULE.</p>
<p>Note that the declaration is already marked as static - if you need a
non-static version of this you’re probably doing it wrong and will break the
THIS_MODULE reference by accident.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drm</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate an object with the given size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the object to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a DMA GEM object and allocates memory as backing store.
The allocated memory will occupy a contiguous chunk of bus address space.</p>
<p>For devices that are directly connected to the memory bus then the allocated
memory will be physically contiguous. For devices that access through an
IOMMU, then the allocated memory is not expected to be physically contiguous
because having contiguous IOVAs is sufficient to meet a devices DMA
requirements.</p>
<p><strong>Return</strong></p>
<p>A <a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span></code></a> * on success or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded negative
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free resources associated with a DMA GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span> <span class="pre">*dma_obj</span></code></dt><dd><p>DMA GEM object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees the backing memory of the DMA GEM object, cleans up the
GEM object state and frees the memory used to store the object itself.
If the buffer is imported and the virtual address is set, it is released.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_dumb_create_internal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_dumb_create_internal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_priv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><span class="n"><span class="pre">drm_mode_create_dumb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_dumb_create_internal" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a dumb buffer object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file-private structure to create the dumb buffer for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*args</span></code></dt><dd><p>IOCTL data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This aligns the pitch and size arguments to the minimum required. This is
an internal helper that can be wrapped by a driver to account for hardware
with more specific alignment requirements. It should not be used directly
as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_dumb_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_dumb_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_priv</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><span class="n"><span class="pre">drm_mode_create_dumb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_dumb_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a dumb buffer object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file-private structure to create the dumb buffer for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*args</span></code></dt><dd><p>IOCTL data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the pitch of the dumb buffer and rounds it up to an
integer number of bytes per pixel. Drivers for hardware that doesn’t have
any additional restrictions on the pitch can directly use this function as
their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p>For hardware with additional restrictions, drivers can adjust the fields
set up by userspace and pass the IOCTL data along to the
<a class="reference internal" href="#c.drm_gem_dma_dumb_create_internal" title="drm_gem_dma_dumb_create_internal"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_dumb_create_internal()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_get_unmapped_area">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_get_unmapped_area</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">file</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filp</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pgoff</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_get_unmapped_area" title="Link to this definition">¶</a><br /></dt>
<dd><p>propose address for mapping in noMMU cases</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>memory address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>memory flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used in noMMU platforms to propose address mapping
for a given buffer.
It’s intended to be used as a direct handler for the struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">file_operations.get_unmapped_area</span></code> operation.</p>
<p><strong>Return</strong></p>
<p>mapping address on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_print_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_print_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">indent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_print_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_dma_object</span></code></a> info for debugfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span> <span class="pre">*dma_obj</span></code></dt><dd><p>DMA GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prints dma_addr and vaddr for use in e.g. debugfs output.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_get_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_get_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_get_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>provide a scatter/gather table of pinned pages for a DMA GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span> <span class="pre">*dma_obj</span></code></dt><dd><p>DMA GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function exports a scatter/gather table by calling the standard
DMA mapping API.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or NULL on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_prime_import_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_prime_import_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_prime_import_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>produce a DMA GEM object from another driver’s scatter/gather table of pinned pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>DMA-BUF attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>scatter/gather table of pinned pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function imports a scatter/gather table exported via DMA-BUF by
another driver. Imported buffers must be physically contiguous in memory
(i.e. the scatter/gather table must contain a single entry). Drivers that
use the DMA helpers should set this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>A pointer to a newly created GEM object or an ERR_PTR-encoded negative
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_vmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>map a DMA GEM object into the kernel’s virtual address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span> <span class="pre">*dma_obj</span></code></dt><dd><p>DMA GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>Returns the kernel virtual address of the DMA GEM object’s backing
store.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function maps a buffer into the kernel’s virtual address space.
Since the DMA buffers are already mapped into the kernel virtual address
space this simply returns the cached virtual address.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dma_object" title="drm_gem_dma_object"><span class="n"><span class="pre">drm_gem_dma_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>memory-map an exported DMA GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_dma_object</span> <span class="pre">*dma_obj</span></code></dt><dd><p>DMA GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function maps a buffer into a userspace process’s address space.
In addition to the usual GEM VMA setup it immediately faults in the entire
object instead of using on-demand faulting.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dma_prime_import_sg_table_vmap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dma_prime_import_sg_table_vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dma_prime_import_sg_table_vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>PRIME import another driver’s scatter/gather table and get the virtual address of the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>DMA-BUF attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>Scatter/gather table of pinned pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function imports a scatter/gather table using
<a class="reference internal" href="#c.drm_gem_dma_prime_import_sg_table" title="drm_gem_dma_prime_import_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dma_prime_import_sg_table()</span></code></a> and uses <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_vmap" title="dma_buf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap()</span></code></a> to get the kernel
virtual address. This ensures that a DMA GEM object always has its virtual
address set. This address is released when the object is freed.</p>
<p>This function can be used as the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a>
callback. The <a class="reference internal" href="#c.DRM_GEM_DMA_DRIVER_OPS_VMAP" title="DRM_GEM_DMA_DRIVER_OPS_VMAP"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GEM_DMA_DRIVER_OPS_VMAP</span></code></a> macro provides a shortcut to set
the necessary DRM driver operations.</p>
<p><strong>Return</strong></p>
<p>A pointer to a newly created GEM object or an ERR_PTR-encoded negative
error code on failure.</p>
</div>
</section>
<section id="gem-shmem-helper-function-reference">
<h3>GEM SHMEM Helper Function Reference<a class="headerlink" href="#gem-shmem-helper-function-reference" title="Link to this heading">¶</a></h3>
<p>This library provides helpers for GEM objects backed by shmem buffers
allocated using anonymous pageable memory.</p>
<p>Functions that operate on the GEM object receive struct <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_shmem_object</span></code></a>.
For GEM callback helpers in struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> functions, see likewise
named functions with an _object_ infix (e.g., drm_gem_shmem_object_vmap() wraps
drm_gem_shmem_vmap()). These helpers perform the necessary type conversion.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></span><a class="headerlink" href="#c.drm_gem_shmem_object" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object backed by shmem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_shmem_object {
    struct drm_gem_object base;
    struct page **pages;
    unsigned int pages_use_count;
    int madv;
    struct list_head madv_list;
    struct sg_table *sgt;
    void *vaddr;
    unsigned int vmap_use_count;
    bool pages_mark_dirty_on_put : 1;
    bool pages_mark_accessed_on_put : 1;
    bool map_wc : 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages</span></code></dt><dd><p>Page table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_use_count</span></code></dt><dd><p>Reference count on the pages table.
The pages are put when the count reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">madv</span></code></dt><dd><p>State for madvise</p>
<p>0 is active/inuse.
A negative value is the object is purged.
Positive values are driver specific and not used by the helpers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">madv_list</span></code></dt><dd><p>List entry for madvise tracking</p>
<p>Typically used by drivers to track purgeable objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgt</span></code></dt><dd><p>Scatter/gather table for imported PRIME buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr</span></code></dt><dd><p>Kernel virtual address of the backing memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_use_count</span></code></dt><dd><p>Reference count on the virtual address.
The address are un-mapped when the count reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_mark_dirty_on_put</span></code></dt><dd><p>Mark pages as dirty when they are put.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pages_mark_accessed_on_put</span></code></dt><dd><p>Mark pages as accessed when they are put.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_wc</span></code></dt><dd><p>map object write-combined (instead of using shmem defaults).</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_shmem_free" title="drm_gem_shmem_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_free()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_free" title="drm_gem_shmem_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_free()</span></code></a>. Drivers that employ the shmem helpers
should use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.free</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_print_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_print_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">indent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_print_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_shmem_object</span></code></a> info for debugfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_print_info" title="drm_gem_shmem_print_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_print_info()</span></code></a>. Drivers that employ the shmem helpers should
use this function as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.print_info</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_pin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_pin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_pin" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_shmem_pin" title="drm_gem_shmem_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_pin()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_pin" title="drm_gem_shmem_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_pin()</span></code></a>. Drivers that employ the shmem helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.pin</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_unpin">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_unpin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_unpin" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_shmem_unpin" title="drm_gem_shmem_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_unpin()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_unpin" title="drm_gem_shmem_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_unpin()</span></code></a>. Drivers that employ the shmem helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.unpin</span></code></a> handler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_get_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_get_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_get_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_shmem_get_sg_table" title="drm_gem_shmem_get_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_get_sg_table()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_get_sg_table" title="drm_gem_shmem_get_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_get_sg_table()</span></code></a>. Drivers that employ the shmem helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a> handler.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or error pointer on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_object_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_object_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_object_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object function for <a class="reference internal" href="#c.drm_gem_shmem_mmap" title="drm_gem_shmem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_mmap()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps <a class="reference internal" href="#c.drm_gem_shmem_mmap" title="drm_gem_shmem_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_mmap()</span></code></a>. Drivers that employ the shmem helpers should
use it as their <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.mmap</span></code></a> handler.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_SHMEM_DRIVER_OPS">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_SHMEM_DRIVER_OPS</span></span></span><a class="headerlink" href="#c.DRM_GEM_SHMEM_DRIVER_OPS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_SHMEM_DRIVER_OPS</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>Default shmem GEM operations</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro provides a shortcut for setting the shmem GEM operations in
the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver</span></code></a> structure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Allocate an object with the given size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of the object to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a shmem GEM object.</p>
<p><strong>Return</strong></p>
<p>A <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span></code></a> * on success or an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded negative
error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free resources associated with a shmem GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up the GEM object state and frees the memory used to
store the object itself.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_pin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_pin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_pin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pin backing pages for a shmem GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes sure the backing pages are pinned in memory while the
buffer is exported.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_unpin">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_unpin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_unpin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpin backing pages for a shmem GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes the requirement that the backing pages are pinned in
memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_dumb_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_dumb_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><span class="n"><span class="pre">drm_mode_create_dumb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_dumb_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Create a dumb shmem buffer object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file structure to create the dumb buffer for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*args</span></code></dt><dd><p>IOCTL data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the pitch of the dumb buffer and rounds it up to an
integer number of bytes per pixel. Drivers for hardware that doesn’t have
any additional restrictions on the pitch can directly use this function as
their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p>For hardware with additional restrictions, drivers can adjust the fields
set up by userspace before calling into this function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Memory-map a shmem GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>VMA for the area to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements an augmented version of the GEM DRM file mmap
operation for shmem objects.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_print_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_print_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">indent</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_print_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_shmem_object</span></code></a> info for debugfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_get_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_get_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_get_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>Provide a scatter/gather table of pinned pages for a shmem GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function exports a scatter/gather table suitable for PRIME usage by
calling the standard DMA mapping API.</p>
<p>Drivers who need to acquire an scatter/gather table for objects need to call
<a class="reference internal" href="#c.drm_gem_shmem_get_pages_sgt" title="drm_gem_shmem_get_pages_sgt"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_get_pages_sgt()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or error pointer on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_get_pages_sgt">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_get_pages_sgt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_shmem_object" title="drm_gem_shmem_object"><span class="n"><span class="pre">drm_gem_shmem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">shmem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_get_pages_sgt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pin pages, dma map them, and return a scatter/gather table for a shmem GEM object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_shmem_object</span> <span class="pre">*shmem</span></code></dt><dd><p>shmem GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a scatter/gather table suitable for driver usage. If
the sg table doesn’t exist, the pages are pinned, dma-mapped, and a sg
table created.</p>
<p>This is the main function for drivers to get at backing storage, and it hides
and difference between dma-buf imported and natively allocated objects.
<a class="reference internal" href="#c.drm_gem_shmem_get_sg_table" title="drm_gem_shmem_get_sg_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_shmem_get_sg_table()</span></code></a> should not be directly called by drivers.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_shmem_prime_import_sg_table">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_shmem_prime_import_sg_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_shmem_prime_import_sg_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>Produce a shmem GEM object from another driver’s scatter/gather table of pinned pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>DMA-BUF attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>Scatter/gather table of pinned pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function imports a scatter/gather table exported via DMA-BUF by
another driver. Drivers that use the shmem helpers should set this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>A pointer to a newly created GEM object or an ERR_PTR-encoded negative
error code on failure.</p>
</div>
</section>
<section id="gem-vram-helper-functions-reference">
<h3>GEM VRAM Helper Functions Reference<a class="headerlink" href="#gem-vram-helper-functions-reference" title="Link to this heading">¶</a></h3>
<p>This library provides <a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span></code></a> (GEM VRAM), a GEM
buffer object that is backed by video RAM (VRAM). It can be used for
framebuffer devices with dedicated memory.</p>
<p>The data structure <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a> and its helpers implement a memory
manager for simple framebuffer devices with dedicated video memory. GEM
VRAM buffer objects are either placed in the video memory or remain evicted
to system memory.</p>
<p>With the GEM interface userspace applications create, manage and destroy
graphics buffers, such as an on-screen framebuffer. GEM does not provide
an implementation of these interfaces. It’s up to the DRM driver to
provide an implementation that suits the hardware. If the hardware device
contains dedicated video memory, the DRM driver can use the VRAM helper
library. Each active buffer object is stored in video RAM. Active
buffer are used for drawing the current frame, typically something like
the frame’s scanout buffer or the cursor image. If there’s no more space
left in VRAM, inactive GEM objects can be moved to system memory.</p>
<p>To initialize the VRAM helper library call <a class="reference internal" href="#c.drmm_vram_helper_init" title="drmm_vram_helper_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_vram_helper_init()</span></code></a>.
The function allocates and initializes an instance of <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a>
in <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span></code></a>.vram_mm . Use <a class="reference internal" href="#c.DRM_GEM_VRAM_DRIVER" title="DRM_GEM_VRAM_DRIVER"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GEM_VRAM_DRIVER</span></code></a> to initialize
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> and  <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_VRAM_MM_FILE_OPERATIONS</span></code> to initialize
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code>; as illustrated below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">file_operations</span><span class="w"> </span><span class="n">fops</span><span class="w"> </span><span class="o">=</span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">        </span><span class="n">DRM_VRAM_MM_FILE_OPERATION</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">drm_driver</span><span class="w"> </span><span class="n">drv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">driver_feature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">fops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fops</span><span class="p">,</span>
<span class="w">        </span><span class="n">DRM_GEM_VRAM_DRIVER</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">init_drm_driver</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">drm_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">vram_base</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">vram_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// setup device, vram base and size</span>
<span class="w">        </span><span class="c1">// ...</span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drmm_vram_helper_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">vram_base</span><span class="p">,</span><span class="w"> </span><span class="n">vram_size</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This creates an instance of <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a>, exports DRM userspace
interfaces for GEM buffer management and initializes file operations to
allow for accessing created GEM buffers. With this setup, the DRM driver
manages an area of video RAM with VRAM MM and provides GEM VRAM objects
to userspace.</p>
<p>You don’t have to clean up the instance of VRAM MM.
<a class="reference internal" href="#c.drmm_vram_helper_init" title="drmm_vram_helper_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_vram_helper_init()</span></code></a> is a managed interface that installs a
clean-up handler to run during the DRM device’s release.</p>
<p>For drawing or scanout operations, rsp. buffer objects have to be pinned
in video RAM. Call <a class="reference internal" href="#c.drm_gem_vram_pin" title="drm_gem_vram_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_pin()</span></code></a> with <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GEM_VRAM_PL_FLAG_VRAM</span></code> or
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GEM_VRAM_PL_FLAG_SYSTEM</span></code> to pin a buffer object in video RAM or system
memory. Call <a class="reference internal" href="#c.drm_gem_vram_unpin" title="drm_gem_vram_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_unpin()</span></code></a> to release the pinned object afterwards.</p>
<p>A buffer object that is pinned in video RAM has a fixed address within that
memory region. Call <a class="reference internal" href="#c.drm_gem_vram_offset" title="drm_gem_vram_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_offset()</span></code></a> to retrieve this value. Typically
it’s used to program the hardware’s scanout engine for framebuffers, set
the cursor overlay’s image for a mouse cursor, or use it as input to the
hardware’s drawing engine.</p>
<p>To access a buffer object’s memory from the DRM driver, call
<a class="reference internal" href="#c.drm_gem_vram_vmap" title="drm_gem_vram_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vmap()</span></code></a>. It maps the buffer into kernel address
space and returns the memory address. Use <a class="reference internal" href="#c.drm_gem_vram_vunmap" title="drm_gem_vram_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vunmap()</span></code></a> to
release the mapping.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gem_vram_object">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_object</span></span></span><a class="headerlink" href="#c.drm_gem_vram_object" title="Link to this definition">¶</a><br /></dt>
<dd><p>GEM object backed by VRAM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_vram_object {
    struct ttm_buffer_object bo;
    struct iosys_map map;
    unsigned int vmap_use_count;
    struct ttm_placement placement;
    struct ttm_place placements[2];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bo</span></code></dt><dd><p>TTM buffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>Mapping information for <strong>bo</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_use_count</span></code></dt><dd><p>Reference count on the virtual address.
The address are un-mapped when the count reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placement</span></code></dt><dd><p>TTM placement information. Supported placements are <code class="docutils literal notranslate"><span class="pre">TTM_PL_VRAM</span></code>
and <code class="docutils literal notranslate"><span class="pre">TTM_PL_SYSTEM</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placements</span></code></dt><dd><p>TTM placement information.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The type <a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span></code></a> represents a GEM object that is
backed by VRAM. It can be used for simple framebuffer devices with
dedicated memory. The buffer object can be evicted to system memory if
video memory becomes scarce.</p>
<p>GEM VRAM objects perform reference counting for pin and mapping
operations. So a buffer object that has been pinned N times with
<a class="reference internal" href="#c.drm_gem_vram_pin" title="drm_gem_vram_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_pin()</span></code></a> must be unpinned N times with
<a class="reference internal" href="#c.drm_gem_vram_unpin" title="drm_gem_vram_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_unpin()</span></code></a>. The same applies to pairs of
drm_gem_vram_kmap() and drm_gem_vram_kunmap(), as well as pairs of
<a class="reference internal" href="#c.drm_gem_vram_vmap" title="drm_gem_vram_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vmap()</span></code></a> and <a class="reference internal" href="#c.drm_gem_vram_vunmap" title="drm_gem_vram_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vunmap()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_of_bo">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_of_bo</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">ttm_buffer_object</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_of_bo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the container of type <a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span></code></a> for field bo.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt><dd><p>the VRAM buffer object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The containing GEM VRAM object</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_of_gem">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_of_gem</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_of_gem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the container of type <a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span></code></a> for field gem.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gem</span></code></dt><dd><p>the GEM object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The containing GEM VRAM object</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_VRAM_PLANE_HELPER_FUNCS">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_VRAM_PLANE_HELPER_FUNCS</span></span></span><a class="headerlink" href="#c.DRM_GEM_VRAM_PLANE_HELPER_FUNCS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_VRAM_PLANE_HELPER_FUNCS</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>Initializes <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> for VRAM handling</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Drivers may use GEM BOs as VRAM helpers for the framebuffer memory. This
macro initializes <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> to use the respective helper
functions.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_GEM_VRAM_DRIVER">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_GEM_VRAM_DRIVER</span></span></span><a class="headerlink" href="#c.DRM_GEM_VRAM_DRIVER" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_GEM_VRAM_DRIVER</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>default callback functions for <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Drivers that use VRAM MM and GEM VRAM can use this macro to initialize
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> with default functions.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_vram_mm">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vram_mm</span></span></span><a class="headerlink" href="#c.drm_vram_mm" title="Link to this definition">¶</a><br /></dt>
<dd><p>An instance of VRAM MM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_vram_mm {
    uint64_t vram_base;
    size_t vram_size;
    struct ttm_device bdev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vram_base</span></code></dt><dd><p>Base address of the managed video memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vram_size</span></code></dt><dd><p>Size of the managed video memory in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bdev</span></code></dt><dd><p>The TTM BO device.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The fields <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a>.vram_base and
<a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a>.vrm_size are managed by VRAM MM, but are
available for public read access. Use the field
<a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a>.bdev to access the TTM BO device.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vram_mm_of_bdev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><span class="n"><span class="pre">drm_vram_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_vram_mm_of_bdev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.ttm_device" title="ttm_device"><span class="n"><span class="pre">ttm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bdev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vram_mm_of_bdev" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the container of type <a class="reference internal" href="#c.ttm_device" title="ttm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span></code></a> for field bdev.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_device</span> <span class="pre">*bdev</span></code></dt><dd><p>the TTM BO device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The containing instance of <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pg_align</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Creates a VRAM-backed GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pg_align</span></code></dt><dd><p>the buffer’s alignment in multiples of the page size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GEM objects are allocated by calling <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.gem_create_object,
if set. Otherwise <a class="reference internal" href="../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> will be used. Drivers can set their own GEM
object functions in <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.gem_create_object. If no functions
are set, the new GEM object will use the default functions from GEM VRAM
helpers.</p>
<p><strong>Return</strong></p>
<p>A new instance of <a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span></code></a> on success, or
an <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>-encoded error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>Releases a reference to a VRAM-backed GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>the GEM VRAM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See ttm_bo_put() for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_offset">
<span class="n"><span class="pre">s64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a GEM VRAM object’s offset in video memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>the GEM VRAM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the buffer object’s offset in the device’s video
memory. The buffer object has to be pinned to <code class="docutils literal notranslate"><span class="pre">TTM_PL_VRAM</span></code>.</p>
<p><strong>Return</strong></p>
<p>The buffer object’s offset in video memory on success, or
a negative errno code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_pin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_pin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pl_flag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_pin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pins a GEM VRAM object in a region.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>the GEM VRAM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pl_flag</span></code></dt><dd><p>a bitmask of possible memory regions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pinning a buffer object ensures that it is not evicted from
a memory region. A pinned buffer object has to be unpinned before
it can be pinned to another region. If the pl_flag argument is 0,
the buffer is pinned at its current location (video RAM or system
memory).</p>
<p>Small buffer objects, such as cursor images, can lead to memory
fragmentation if they are pinned in the middle of video RAM. This
is especially a problem on devices with only a small amount of
video RAM. Fragmentation can prevent the primary framebuffer from
fitting in, even though there’s enough memory overall. The modifier
DRM_GEM_VRAM_PL_FLAG_TOPDOWN marks the buffer object to be pinned
at the high end of the memory region to avoid fragmentation.</p>
<p><strong>Return</strong></p>
<p>0 on success, or
a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_unpin">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_unpin</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_unpin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpins a GEM VRAM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>the GEM VRAM object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or
a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_vmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pins and maps a GEM VRAM object into kernel address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>The GEM VRAM object to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>Returns the kernel virtual address of the VRAM GEM object’s backing
store.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap function pins a GEM VRAM object to its current location, either
system or video memory, and maps its buffer into kernel address space.
As pinned object cannot be relocated, you should avoid pinning objects
permanently. Call <a class="reference internal" href="#c.drm_gem_vram_vunmap" title="drm_gem_vram_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vunmap()</span></code></a> with the returned address to
unmap and unpin the GEM VRAM object.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_vunmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_vunmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_vram_object" title="drm_gem_vram_object"><span class="n"><span class="pre">drm_gem_vram_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gbo</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_vunmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unmaps and unpins a GEM VRAM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_vram_object</span> <span class="pre">*gbo</span></code></dt><dd><p>The GEM VRAM object to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>Kernel virtual address where the VRAM GEM object was mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A call to <a class="reference internal" href="#c.drm_gem_vram_vunmap" title="drm_gem_vram_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vunmap()</span></code></a> unmaps and unpins a GEM VRAM buffer. See
the documentation for <a class="reference internal" href="#c.drm_gem_vram_vmap" title="drm_gem_vram_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_vmap()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_fill_create_dumb">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_fill_create_dumb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pg_align</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pitch_align</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><span class="n"><span class="pre">drm_mode_create_dumb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_fill_create_dumb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper for implementing <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>the DRM file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pg_align</span></code></dt><dd><p>the buffer’s alignment in multiples of the page size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pitch_align</span></code></dt><dd><p>the scanline’s alignment in powers of 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*args</span></code></dt><dd><p>the arguments as provided to
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function fills <a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span></code></a>, which is used
by <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create. Implementations of this interface
should forwards their arguments to this helper, plus the driver-specific
parameters.</p>
<p><strong>Return</strong></p>
<p>0 on success, or
a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_driver_dumb_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_driver_dumb_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-uapi.html#c.drm_mode_create_dumb" title="drm_mode_create_dumb"><span class="n"><span class="pre">drm_mode_create_dumb</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_driver_dumb_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>the DRM file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*args</span></code></dt><dd><p>the arguments as provided to
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>.dumb_create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function requires the driver to use <strong>drm_device.vram_mm</strong> for its
instance of VRAM MM.</p>
<p><strong>Return</strong></p>
<p>0 on success, or
a negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_plane_helper_prepare_fb">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_plane_helper_prepare_fb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><span class="n"><span class="pre">drm_plane</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plane</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_plane_helper_prepare_fb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a>.prepare_fb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>a DRM plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*new_state</span></code></dt><dd><p>the plane’s new state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During plane updates, this function sets the plane’s fence and
pins the GEM VRAM objects of the plane’s new framebuffer to VRAM.
Call <a class="reference internal" href="#c.drm_gem_vram_plane_helper_cleanup_fb" title="drm_gem_vram_plane_helper_cleanup_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_plane_helper_cleanup_fb()</span></code></a> to unpin them.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, or
a negative errno code otherwise.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_plane_helper_cleanup_fb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_plane_helper_cleanup_fb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><span class="n"><span class="pre">drm_plane</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">plane</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_plane_helper_cleanup_fb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a>.cleanup_fb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>a DRM plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>the plane’s old state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During plane updates, this function unpins the GEM VRAM
objects of the plane’s old framebuffer from VRAM. Complements
<a class="reference internal" href="#c.drm_gem_vram_plane_helper_prepare_fb" title="drm_gem_vram_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_plane_helper_prepare_fb()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_simple_display_pipe_prepare_fb">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_simple_display_pipe_prepare_fb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><span class="n"><span class="pre">drm_simple_display_pipe</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pipe</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_simple_display_pipe_prepare_fb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements <a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a>.prepare_fb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>a simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*new_state</span></code></dt><dd><p>the plane’s new state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During plane updates, this function pins the GEM VRAM
objects of the plane’s new framebuffer to VRAM. Call
<a class="reference internal" href="#c.drm_gem_vram_simple_display_pipe_cleanup_fb" title="drm_gem_vram_simple_display_pipe_cleanup_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_simple_display_pipe_cleanup_fb()</span></code></a> to unpin them.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on success, or
a negative errno code otherwise.</p>
</div></blockquote>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_vram_simple_display_pipe_cleanup_fb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_vram_simple_display_pipe_cleanup_fb</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><span class="n"><span class="pre">drm_simple_display_pipe</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pipe</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><span class="n"><span class="pre">drm_plane_state</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old_state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vram_simple_display_pipe_cleanup_fb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements <a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a>.cleanup_fb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>a simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>the plane’s old state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During plane updates, this function unpins the GEM VRAM
objects of the plane’s old framebuffer from VRAM. Complements
<a class="reference internal" href="#c.drm_gem_vram_simple_display_pipe_prepare_fb" title="drm_gem_vram_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_vram_simple_display_pipe_prepare_fb()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vram_mm_debugfs_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vram_mm_debugfs_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><span class="n"><span class="pre">drm_minor</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">minor</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vram_mm_debugfs_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register VRAM MM debugfs file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*minor</span></code></dt><dd><p>drm minor device.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drmm_vram_helper_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drmm_vram_helper_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">vram_base</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">vram_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drmm_vram_helper_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes a device’s instance of <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">vram_base</span></code></dt><dd><p>the base address of the video memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">vram_size</span></code></dt><dd><p>the size of the video memory in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new instance of <a class="reference internal" href="#c.drm_vram_mm" title="drm_vram_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vram_mm</span></code></a> and stores it in
struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.vram_mm</span></code></a>. The instance is auto-managed and cleaned
up as part of device cleanup. Calling this function multiple times
will generate an error message.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vram_helper_mode_valid">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><span class="n"><span class="pre">drm_mode_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vram_helper_mode_valid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><span class="n"><span class="pre">drm_display_mode</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vram_helper_mode_valid" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if a display mode’s framebuffer fits into the available video memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>the mode to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tests if enough video memory is available for using the
specified display mode. Atomic modesetting requires importing the
designated framebuffer into video memory before evicting the active
one. Hence, any framebuffer may consume at most half of the available
VRAM. Display modes that require a larger framebuffer can not be used,
even if the CRTC does support them. Each framebuffer is assumed to
have 32-bit color depth.</p>
<p><strong>Note</strong></p>
<p>The function can only test if the display mode is supported in
general. If there are too many framebuffers pinned to video memory,
a display mode may still not be usable in practice. The color depth of
32-bit fits all current use case. A more flexible test can be added
when necessary.</p>
<p><strong>Return</strong></p>
<p>MODE_OK if the display mode is supported, or an error code of type
<a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mode_status</span></code></a> otherwise.</p>
</div>
</section>
<section id="gem-ttm-helper-functions-reference">
<h3>GEM TTM Helper Functions Reference<a class="headerlink" href="#gem-ttm-helper-functions-reference" title="Link to this heading">¶</a></h3>
<p>This library provides helper functions for gem objects backed by
ttm.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_ttm_print_info">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_ttm_print_info</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">indent</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gem</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_ttm_print_info" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code> info for debugfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt><dd><p>Tab indentation level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gem</span></code></dt><dd><p>GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.print_info</span></code></a>
callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_ttm_vmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_ttm_vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gem</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_ttm_vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>vmap <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gem</span></code></dt><dd><p>GEM object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>[out] returns the dma-buf mapping.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps a GEM object with ttm_bo_vmap(). This function can be used as
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.vmap</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_ttm_vunmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_ttm_vunmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gem</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_ttm_vunmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>vunmap <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gem</span></code></dt><dd><p>GEM object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>dma-buf mapping.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmaps a GEM object with ttm_bo_vunmap(). This function can be used as
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.vmap</span></code></a> callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_ttm_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_ttm_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gem</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_ttm_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>mmap <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gem</span></code></dt><dd><p>GEM object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm area.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.mmap</span></code></a>
callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_ttm_dumb_map_offset">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_ttm_dumb_map_offset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_ttm_dumb_map_offset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements struct <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_map_offset</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">handle</span></code></dt><dd><p>GEM handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*offset</span></code></dt><dd><p>Returns the mapping’s memory offset on success</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides an implementation of struct <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_map_offset</span></code></a> for
TTM-based GEM drivers. TTM allocates the offset internally and
<a class="reference internal" href="#c.drm_gem_ttm_dumb_map_offset" title="drm_gem_ttm_dumb_map_offset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_ttm_dumb_map_offset()</span></code></a> returns it for dumb-buffer implementations.</p>
<p>See struct <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.dumb_map_offset</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
</section>
</section>
<section id="vma-offset-manager">
<h2>VMA Offset Manager<a class="headerlink" href="#vma-offset-manager" title="Link to this heading">¶</a></h2>
<p>The vma-manager is responsible to map arbitrary driver-dependent memory
regions into the linear user address-space. It provides offsets to the
caller which can then be used on the address_space of the drm-device. It
takes care to not overlap regions, size them appropriately and to not
confuse mm-core by inconsistent fake vm_pgoff fields.
Drivers shouldn’t use this for object placement in VMEM. This manager should
only be used to manage mappings into linear user-space VMs.</p>
<p>We use drm_mm as backend to manage object allocations. But it is highly
optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to
speed up offset lookups.</p>
<p>You must not use multiple offset managers on a single address_space.
Otherwise, mm-core will be unable to tear down memory mappings as the VM will
no longer be linear.</p>
<p>This offset manager works on page-based addresses. That is, every argument
and return code (with the exception of <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_offset_addr()</span></code></a>) is given
in number of pages, not number of bytes. That means, object sizes and offsets
must always be page-aligned (as usual).
If you want to get a valid byte-based user-space address for a given offset,
please see <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_offset_addr()</span></code></a>.</p>
<p>Additionally to offset management, the vma offset manager also handles access
management. For every open-file context that is allowed to access a given
node, you must call <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_allow()</span></code></a>. Otherwise, an mmap() call on this
open-file with the offset of the node will fail with -EACCES. To revoke
access again, use <a class="reference internal" href="#c.drm_vma_node_revoke" title="drm_vma_node_revoke"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_revoke()</span></code></a>. However, the caller is responsible
for destroying already existing mappings, if required.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_exact_lookup_locked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_exact_lookup_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_exact_lookup_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>Look up node by exact address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>Start address (page-based, not byte-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt><dd><p>Size of object (page-based)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.drm_vma_offset_lookup_locked" title="drm_vma_offset_lookup_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_lookup_locked()</span></code></a> but does not allow any offset into the node.
It only returns the exact object with the given start address.</p>
<p><strong>Return</strong></p>
<p>Node at exact start address <strong>start</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_lock_lookup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_lock_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_lock_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lock lookup for extended private use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock VMA manager for extended lookups. Only locked VMA function calls
are allowed while holding this lock. All other contexts are blocked from VMA
until the lock is released via <a class="reference internal" href="#c.drm_vma_offset_unlock_lookup" title="drm_vma_offset_unlock_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_unlock_lookup()</span></code></a>.</p>
<p>Use this if you need to take a reference to the objects returned by
<a class="reference internal" href="#c.drm_vma_offset_lookup_locked" title="drm_vma_offset_lookup_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_lookup_locked()</span></code></a> before releasing this lock again.</p>
<p>This lock must not be used for anything else than extended lookups. You must
not call any other VMA helpers while holding this lock.</p>
<p><strong>Note</strong></p>
<p>You’re in atomic-context while holding this lock!</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_unlock_lookup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_unlock_lookup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_unlock_lookup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unlock lookup for extended private use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release lookup-lock. See <a class="reference internal" href="#c.drm_vma_offset_lock_lookup" title="drm_vma_offset_lock_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_lock_lookup()</span></code></a> for more information.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_reset">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_reset</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_reset" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize or reset node object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to initialize or reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset a node to its initial state. This must be called before using it with
any VMA offset manager.</p>
<p>This must not be called on an already allocated node, or you will leak
memory.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_start">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return start address for page-based addressing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to inspect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the start address of the given node. This can be used as offset into
the linear VM space that is provided by the VMA offset manager. Note that
this can only be used for page-based addressing. If you need a proper offset
for user-space mappings, you must apply “&lt;&lt; PAGE_SHIFT” or use the
<a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_offset_addr()</span></code></a> helper instead.</p>
<p><strong>Return</strong></p>
<p>Start address of <strong>node</strong> for page-based addressing. 0 if the node does not
have an offset allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_size">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return size (page-based)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to inspect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the size as number of pages for the given node. This is the same size
that was passed to <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_add()</span></code></a>. If no offset is allocated for the
node, this is 0.</p>
<p><strong>Return</strong></p>
<p>Size of <strong>node</strong> as number of pages. 0 if the node does not have an offset
allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_offset_addr">
<span class="n"><span class="pre">__u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_offset_addr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_offset_addr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return sanitized offset for user-space mmaps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Linked offset node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.drm_vma_node_start" title="drm_vma_node_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_start()</span></code></a> but returns the address as a valid offset that
can be used for user-space mappings during mmap().
This must not be called on unlinked nodes.</p>
<p><strong>Return</strong></p>
<p>Offset of <strong>node</strong> for byte-based addressing. 0 if the node does not have an
object allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_unmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_unmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><span class="n"><span class="pre">address_space</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_mapping</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unmap offset node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Offset node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*file_mapping</span></code></dt><dd><p>Address space to unmap <strong>node</strong> from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap all userspace mappings for a given offset node. The mappings must be
associated with the <strong>file_mapping</strong> address-space. If no offset exists
nothing is done.</p>
<p>This call is unlocked. The caller must guarantee that <a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_remove()</span></code></a>
is not called on this node concurrently.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_verify_access">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_verify_access</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_verify_access" title="Link to this definition">¶</a><br /></dt>
<dd><p>Access verification helper for TTM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Offset node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*tag</span></code></dt><dd><p>Tag of file to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks whether <strong>tag</strong> is granted access to <strong>node</strong>. It is the same as
<a class="reference internal" href="#c.drm_vma_node_is_allowed" title="drm_vma_node_is_allowed"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_is_allowed()</span></code></a> but suitable as drop-in helper for TTM
verify_access() callbacks.</p>
<p><strong>Return</strong></p>
<p>0 if access is granted, -EACCES otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_manager_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_manager_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">page_offset</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_manager_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize new offset-manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_offset</span></code></dt><dd><p>Offset of available memory area (page-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>Size of available address space range (page-based)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new offset-manager. The offset and area size available for the
manager are given as <strong>page_offset</strong> and <strong>size</strong>. Both are interpreted as
page-numbers, not bytes.</p>
<p>Adding/removing nodes from the manager is locked internally and protected
against concurrent access. However, node allocation and destruction is left
for the caller. While calling into the vma-manager, a given node must
always be guaranteed to be referenced.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_manager_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_manager_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_manager_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy offset manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy an object manager which was previously created via
<a class="reference internal" href="#c.drm_vma_offset_manager_init" title="drm_vma_offset_manager_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_manager_init()</span></code></a>. The caller must remove all allocated nodes
before destroying the manager. Otherwise, drm_mm will refuse to free the
requested resources.</p>
<p>The manager must not be accessed after this function is called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_lookup_locked">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_lookup_locked</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_lookup_locked" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find node in offset space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt><dd><p>Start address for object (page-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt><dd><p>Size of object (page-based)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a node given a start address and object size. This returns the _best_
match for the given node. That is, <strong>start</strong> may point somewhere into a valid
region and the given node will be returned, as long as the node spans the
whole requested area (given the size in number of pages as <strong>pages</strong>).</p>
<p>Note that before lookup the vma offset manager lookup lock must be acquired
with <a class="reference internal" href="#c.drm_vma_offset_lock_lookup" title="drm_vma_offset_lock_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_lock_lookup()</span></code></a>. See there for an example. This can then be
used to implement weakly referenced lookups using kref_get_unless_zero().</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>drm_vma_offset_lock_lookup(mgr);
node = drm_vma_offset_lookup_locked(mgr);
if (node)
    kref_get_unless_zero(container_of(node, sth, entr));
drm_vma_offset_unlock_lookup(mgr);
</pre></div>
</div>
<p><strong>Example</strong></p>
<p><strong>Return</strong></p>
<p>Returns NULL if no suitable node can be found. Otherwise, the best match
is returned. It’s the caller’s responsibility to make sure the node doesn’t
get destroyed before the caller can access it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_add">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add offset node to manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt><dd><p>Allocation size visible to user-space (in number of pages)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a node to the offset-manager. If the node was already added, this does
nothing and return 0. <strong>pages</strong> is the size of the object given in number of
pages.
After this call succeeds, you can access the offset of the node until it
is removed again.</p>
<p>If this call fails, it is safe to retry the operation or call
<a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_remove()</span></code></a>, anyway. However, no cleanup is required in that
case.</p>
<p><strong>pages</strong> is not required to be the same size as the underlying memory object
that you want to map. It only limits the size that user-space can map into
their address space.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_offset_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_offset_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_manager</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mgr</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove offset node from manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a node from the offset manager. If the node wasn’t added before, this
does nothing. After this call returns, the offset and size will be 0 until a
new offset is allocated via <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_add()</span></code></a> again. Helper functions like
<a class="reference internal" href="#c.drm_vma_node_start" title="drm_vma_node_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_start()</span></code></a> and <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_offset_addr()</span></code></a> will return 0 if no
offset is allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_allow">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_allow</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_allow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add open-file to list of allowed users</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*tag</span></code></dt><dd><p>Tag of file to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>tag</strong> to the list of allowed open-files for this node. If <strong>tag</strong> is
already on this list, the ref-count is incremented.</p>
<p>The list of allowed-users is preserved across <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_add()</span></code></a> and
<a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_remove()</span></code></a> calls. You may even call it if the node is currently
not added to any offset-manager.</p>
<p>You must remove all open-files the same number of times as you added them
before destroying the node. Otherwise, you will leak memory.</p>
<p>This is locked against concurrent access internally.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on internal failure (out-of-mem)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_allow_once">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_allow_once</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_allow_once" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add open-file to list of allowed users</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*tag</span></code></dt><dd><p>Tag of file to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>tag</strong> to the list of allowed open-files for this node.</p>
<p>The list of allowed-users is preserved across <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_add()</span></code></a> and
<a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_offset_remove()</span></code></a> calls. You may even call it if the node is currently
not added to any offset-manager.</p>
<p>This is not ref-counted unlike <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_allow()</span></code></a> hence <a class="reference internal" href="#c.drm_vma_node_revoke" title="drm_vma_node_revoke"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_revoke()</span></code></a>
should only be called once after this.</p>
<p>This is locked against concurrent access internally.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on internal failure (out-of-mem)</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_revoke">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_revoke</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_revoke" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove open-file from list of allowed users</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*tag</span></code></dt><dd><p>Tag of file to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the ref-count of <strong>tag</strong> in the list of allowed open-files on <strong>node</strong>.
If the ref-count drops to zero, remove <strong>tag</strong> from the list. You must call
this once for every <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_allow()</span></code></a> on <strong>tag</strong>.</p>
<p>This is locked against concurrent access internally.</p>
<p>If <strong>tag</strong> is not on the list, nothing is done.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_vma_node_is_allowed">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_vma_node_is_allowed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_vma_offset_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tag</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_is_allowed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check whether an open-file is granted access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*node</span></code></dt><dd><p>Node to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*tag</span></code></dt><dd><p>Tag of file to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the list in <strong>node</strong> whether <strong>tag</strong> is currently on the list of allowed
open-files (see <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_vma_node_allow()</span></code></a>).</p>
<p>This is locked against concurrent access internally.</p>
<p><strong>Return</strong></p>
<p>true if <strong>filp</strong> is on the list</p>
</div>
</section>
<section id="prime-buffer-sharing">
<span id="id1"></span><h2>PRIME Buffer Sharing<a class="headerlink" href="#prime-buffer-sharing" title="Link to this heading">¶</a></h2>
<p>PRIME is the cross device buffer sharing framework in drm, originally
created for the OPTIMUS range of multi-gpu platforms. To userspace PRIME
buffers are dma-buf based file descriptors.</p>
<section id="overview-and-lifetime-rules">
<h3>Overview and Lifetime Rules<a class="headerlink" href="#overview-and-lifetime-rules" title="Link to this heading">¶</a></h3>
<p>Similar to GEM global names, PRIME file descriptors are also used to share
buffer objects across processes. They offer additional security: as file
descriptors must be explicitly sent over UNIX domain sockets to be shared
between applications, they can’t be guessed like the globally unique GEM
names.</p>
<p>Drivers that support the PRIME API implement the drm_gem_object_funcs.export
and <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> hooks. <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a> implementations for
drivers are all individually exported for drivers which need to overwrite
or reimplement some of them.</p>
<section id="reference-counting-for-gem-drivers">
<h4>Reference Counting for GEM Drivers<a class="headerlink" href="#reference-counting-for-gem-drivers" title="Link to this heading">¶</a></h4>
<p>On the export the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> holds a reference to the exported buffer object,
usually a <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. It takes this reference in the PRIME_HANDLE_TO_FD
IOCTL, when it first calls <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.export</span></code></a>
and stores the exporting GEM object in the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.priv</span></code></a> field. This
reference needs to be released when the final reference to the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>
itself is dropped and its <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.release</span></code></a> function is called.  For
GEM-based drivers, the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> should be exported using
<a class="reference internal" href="#c.drm_gem_dmabuf_export" title="drm_gem_dmabuf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_export()</span></code></a> and then released by <a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_release()</span></code></a>.</p>
<p>Thus the chain of references always flows in one direction, avoiding loops:
importing GEM object -&gt; dma-buf -&gt; exported GEM bo. A further complication
are the lookup caches for import and export. These are required to guarantee
that any given object will always have only one unique userspace handle. This
is required to allow userspace to detect duplicated imports, since some GEM
drivers do fail command submissions if a given buffer object is listed more
than once. These import and export caches in <a class="reference internal" href="#c.drm_prime_file_private" title="drm_prime_file_private"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_prime_file_private</span></code></a> only
retain a weak reference, which is cleaned up when the corresponding object is
released.</p>
<p>Self-importing: If userspace is using PRIME as a replacement for flink then
it will get a fd-&gt;handle request for a GEM object that it created.  Drivers
should detect this situation and return back the underlying object from the
dma-buf private. For GEM based drivers this is handled in
<a class="reference internal" href="#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import()</span></code></a> already.</p>
</section>
</section>
<section id="prime-helper-functions">
<h3>PRIME Helper Functions<a class="headerlink" href="#prime-helper-functions" title="Link to this heading">¶</a></h3>
<p>Drivers can implement <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.export</span></code></a> and
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> in terms of simpler APIs by using the helper
functions <a class="reference internal" href="#c.drm_gem_prime_export" title="drm_gem_prime_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_export()</span></code></a> and <a class="reference internal" href="#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import()</span></code></a>. These functions
implement dma-buf support in terms of some lower-level helpers, which are
again exported for drivers to use individually:</p>
<section id="exporting-buffers">
<h4>Exporting buffers<a class="headerlink" href="#exporting-buffers" title="Link to this heading">¶</a></h4>
<p>Optional pinning of buffers is handled at dma-buf attach and detach time in
<a class="reference internal" href="#c.drm_gem_map_attach" title="drm_gem_map_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_attach()</span></code></a> and <a class="reference internal" href="#c.drm_gem_map_detach" title="drm_gem_map_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_detach()</span></code></a>. Backing storage itself is
handled by <a class="reference internal" href="#c.drm_gem_map_dma_buf" title="drm_gem_map_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_dma_buf()</span></code></a> and <a class="reference internal" href="#c.drm_gem_unmap_dma_buf" title="drm_gem_unmap_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_unmap_dma_buf()</span></code></a>, which relies on
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a>. If <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a> is
unimplemented, exports into another device are rejected.</p>
<p>For kernel-internal access there’s <a class="reference internal" href="#c.drm_gem_dmabuf_vmap" title="drm_gem_dmabuf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_vmap()</span></code></a> and
<a class="reference internal" href="#c.drm_gem_dmabuf_vunmap" title="drm_gem_dmabuf_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_vunmap()</span></code></a>. Userspace mmap support is provided by
<a class="reference internal" href="#c.drm_gem_dmabuf_mmap" title="drm_gem_dmabuf_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_mmap()</span></code></a>.</p>
<p>Note that these export helpers can only be used if the underlying backing
storage is fully coherent and either permanently pinned, or it is safe to pin
it indefinitely.</p>
<p>FIXME: The underlying helper functions are named rather inconsistently.</p>
</section>
<section id="importing-buffers">
<h4>Importing buffers<a class="headerlink" href="#importing-buffers" title="Link to this heading">¶</a></h4>
<p>Importing dma-bufs using <a class="reference internal" href="#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import()</span></code></a> relies on
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a>.</p>
<p>Note that similarly to the export helpers this permanently pins the
underlying backing storage. Which is ok for scanout, but is not the best
option for sharing lots of buffers for rendering.</p>
</section>
</section>
<section id="prime-function-references">
<h3>PRIME Function References<a class="headerlink" href="#prime-function-references" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_prime_file_private">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_file_private</span></span></span><a class="headerlink" href="#c.drm_prime_file_private" title="Link to this definition">¶</a><br /></dt>
<dd><p>per-file tracking for PRIME</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_prime_file_private {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
</div>
<p><strong>Description</strong></p>
<p>This just contains the internal <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> and handle caches for each
<a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> used by the PRIME core code.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dmabuf_export">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dmabuf_export</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export_info" title="dma_buf_export_info"><span class="n"><span class="pre">dma_buf_export_info</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_info</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_export" title="Link to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> export implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>parent device for the exported dmabuf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_export_info</span> <span class="pre">*exp_info</span></code></dt><dd><p>the export information used by <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This wraps <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a> for use by generic GEM drivers that are using
<a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_release()</span></code></a>. In addition to calling <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a>, we take
a reference to the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> and the exported <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> (stored in
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export_info" title="dma_buf_export_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_export_info.priv</span></code></a>) which is released by <a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_release()</span></code></a>.</p>
<p>Returns the new dmabuf.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dmabuf_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dmabuf_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dmabuf_release" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_release" title="Link to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.drm_gem_dmabuf_release" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> release implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic release function for dma_bufs exported as PRIME buffers. GEM drivers
must use this in their <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a> structure as the release callback.
<a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_release()</span></code></a> should be used in conjunction with
<a class="reference internal" href="#c.drm_gem_dmabuf_export" title="drm_gem_dmabuf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_dmabuf_export()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_fd_to_handle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_fd_to_handle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_priv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">prime_fd</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_fd_to_handle" title="Link to this definition">¶</a><br /></dt>
<dd><p>PRIME import function for GEM drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file-private structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">prime_fd</span></code></dt><dd><p>fd id of the dma-buf which should be imported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*handle</span></code></dt><dd><p>pointer to storage for the handle of the imported buffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the PRIME import function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual importing of GEM object from the dma-buf is done through the
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> driver callback.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_handle_to_fd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_handle_to_fd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_priv</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prime_fd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_handle_to_fd" title="Link to this definition">¶</a><br /></dt>
<dd><p>PRIME export function for GEM drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>dev to export the buffer from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>drm file-private structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">handle</span></code></dt><dd><p>buffer handle to export</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flags like DRM_CLOEXEC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*prime_fd</span></code></dt><dd><p>pointer to storage for the fd id of the create dma-buf</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the PRIME export function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual exporting from GEM object to a dma-buf is done through the
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.export</span></code></a> callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_map_attach">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_map_attach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_map_attach" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_attach" title="Link to this definition">¶</a><br /></dt>
<dd><p>dma_buf attach implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to attach device to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>buffer attachment data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.pin</span></code></a> for device specific handling. This can be
used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.attach</span></code></a> callback. Must be used together with
<a class="reference internal" href="#c.drm_gem_map_detach" title="drm_gem_map_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_detach()</span></code></a>.</p>
<p>Returns 0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_map_detach">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_map_detach</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_map_detach" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_detach" title="Link to this definition">¶</a><br /></dt>
<dd><p>dma_buf detach implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to detach from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>attachment to be detached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.pin</span></code></a> for device specific handling.  Cleans up
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a> from <a class="reference internal" href="#c.drm_gem_map_attach" title="drm_gem_map_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_map_attach()</span></code></a>. This can be used as the
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.detach</span></code></a> callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_map_dma_buf">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_map_dma_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dma_data_direction</span></span><span class="w"> </span><span class="n"><span class="pre">dir</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_dma_buf" title="Link to this definition">¶</a><br /></dt>
<dd><p>map_dma_buf implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>attachment whose scatterlist is to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a> and then maps the scatterlist. This
can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.map_dma_buf</span></code></a> callback. Should be used together
with <a class="reference internal" href="#c.drm_gem_unmap_dma_buf" title="drm_gem_unmap_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_unmap_dma_buf()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>sg_table containing the scatterlist to be returned; returns ERR_PTR
on error. May return -EINTR if it is interrupted by a signal.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_unmap_dma_buf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_unmap_dma_buf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><span class="n"><span class="pre">dma_buf_attachment</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">dma_data_direction</span></span><span class="w"> </span><span class="n"><span class="pre">dir</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_unmap_dma_buf" title="Link to this definition">¶</a><br /></dt>
<dd><p>unmap_dma_buf implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>attachment to unmap buffer from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>scatterlist info of the buffer to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.unmap_dma_buf</span></code></a> callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dmabuf_vmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dmabuf_vmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dmabuf_vmap" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_vmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>dma_buf vmap implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>the virtual address of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a kernel virtual mapping. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vmap</span></code></a>
callback. Calls into <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.vmap</span></code></a> for device specific handling.
The kernel virtual address is returned in map.</p>
<p>Returns 0 on success or a negative errno code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dmabuf_vunmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dmabuf_vunmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dmabuf_vunmap" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">map</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_vunmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>dma_buf vunmap implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to be unmapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>the virtual address of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a kernel virtual mapping. This can be used as the
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vunmap</span></code></a> callback. Calls into <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.vunmap</span></code></a> for device specific handling.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>PRIME mmap function for GEM drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Virtual address range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up a userspace mapping for PRIME exported buffers using
the same codepath that is used for regular GEM buffer mapping on the DRM fd.
The fake GEM offset is added to vma-&gt;vm_pgoff and <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;fops</span></code></a>-&gt;mmap is
called to set up the mapping.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_dmabuf_mmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_dmabuf_mmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_dmabuf_mmap" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">vm_area_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_mmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>dma_buf mmap implementation for GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>buffer to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>virtual address range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides memory mapping for the buffer. This can be used as the
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.mmap</span></code></a> callback. It just forwards to <a class="reference internal" href="#c.drm_gem_prime_mmap" title="drm_gem_prime_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_mmap()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_prime_pages_to_sg">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_pages_to_sg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">nr_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_pages_to_sg" title="Link to this definition">¶</a><br /></dt>
<dd><p>converts a page array into an sg list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>pointer to the array of page pointers to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt><dd><p>length of the page vector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper creates an sg table object from a set of pages
the driver is responsible for mapping the pages into the
importers address space for use with dma_buf itself.</p>
<p>This is useful for implementing <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.get_sg_table</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_prime_get_contiguous_size">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_get_contiguous_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_get_contiguous_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>returns the contiguous size of the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>sg_table describing the buffer to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper calculates the contiguous size in the DMA address space
of the buffer described by the provided sg_table.</p>
<p>This is useful for implementing
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.gem_prime_import_sg_table</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_export">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_export</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_export" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper library implementation of the export callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object to export</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags like DRM_CLOEXEC and DRM_RDWR</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the implementation of the <a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.export</span></code></a> functions for GEM drivers
using the PRIME helpers. It is used as the default in
<a class="reference internal" href="#c.drm_gem_prime_handle_to_fd" title="drm_gem_prime_handle_to_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_handle_to_fd()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_import_dev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_import_dev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_prime_import_dev" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attach_dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_import_dev" title="Link to this definition">¶</a><br /></dt>
<dd><p>core implementation of the import callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>dma-buf object to import</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*attach_dev</span></code></dt><dd><p><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to dma_buf attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the core of <a class="reference internal" href="#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import()</span></code></a>. It’s designed to be called by
drivers who want to use a different device structure than <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.dev</span></code></a> for
attaching via dma_buf. This function calls
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> internally.</p>
<p>Drivers must arrange to call <a class="reference internal" href="#c.drm_prime_gem_destroy" title="drm_prime_gem_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_prime_gem_destroy()</span></code></a> from their
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.free</span></code></a> hook when using this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gem_prime_import">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gem_prime_import</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_prime_import" title="dma_buf"><span class="n"><span class="pre">dma_buf</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dma_buf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_import" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper library implementation of the import callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device to import into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt><dd><p>dma-buf object to import</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the implementation of the gem_prime_import functions for GEM drivers
using the PRIME helpers. Drivers can use this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> implementation. It is used as the default
implementation in <a class="reference internal" href="#c.drm_gem_prime_fd_to_handle" title="drm_gem_prime_fd_to_handle"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_fd_to_handle()</span></code></a>.</p>
<p>Drivers must arrange to call <a class="reference internal" href="#c.drm_prime_gem_destroy" title="drm_prime_gem_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_prime_gem_destroy()</span></code></a> from their
<a class="reference internal" href="#c.drm_gem_object_funcs" title="drm_gem_object_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object_funcs.free</span></code></a> hook when using this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_prime_sg_to_page_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_sg_to_page_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_entries</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_sg_to_page_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert an sg table into a page array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>scatter-gather table to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array of page pointers to store the pages in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_entries</span></code></dt><dd><p>size of the passed-in array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports an sg table into an array of pages.</p>
<p>This function is deprecated and strongly discouraged to be used.
The page array is only useful for page faults and those can corrupt fields
in the struct page if they are not handled by the exporting driver.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_prime_sg_to_dma_addr_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_sg_to_dma_addr_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sgt</span></span>, <span class="n"><span class="pre">dma_addr_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addrs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">max_entries</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_sg_to_dma_addr_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>convert an sg table into a dma addr array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>scatter-gather table to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*addrs</span></code></dt><dd><p>array to store the dma bus address of each page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_entries</span></code></dt><dd><p>size of both the passed-in arrays</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports an sg table into an array of addresses.</p>
<p>Drivers should use this in their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a>
implementation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_prime_gem_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_prime_gem_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_gem_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to clean up a PRIME-imported GEM object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>GEM object which was created from a dma-buf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sg</span></code></dt><dd><p>the sg-table which was pinned at import time</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the cleanup functions which GEM drivers need to call when they use
<a class="reference internal" href="#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import()</span></code></a> or <a class="reference internal" href="#c.drm_gem_prime_import_dev" title="drm_gem_prime_import_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_prime_import_dev()</span></code></a> to import dma-bufs.</p>
</div>
</section>
</section>
<section id="drm-mm-range-allocator">
<h2>DRM MM Range Allocator<a class="headerlink" href="#drm-mm-range-allocator" title="Link to this heading">¶</a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h3>
<p>drm_mm provides a simple range allocator. The drivers are free to use the
resource allocator from the linux core if it suits them, the upside of drm_mm
is that it’s in the DRM core. Which means that it’s easier to extend for
some of the crazier special purpose needs of gpus.</p>
<p>The main data struct is <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm</span></code></a>, allocations are tracked in <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node</span></code></a>.
Drivers are free to embed either of them into their own suitable
datastructures. drm_mm itself will not do any memory allocations of its own,
so if drivers choose not to embed nodes they need to still allocate them
themselves.</p>
<p>The range allocator also supports reservation of preallocated blocks. This is
useful for taking over initial mode setting configurations from the firmware,
where an object needs to be created which exactly matches the firmware’s
scanout target. As long as the range is still free it can be inserted anytime
after the allocator is initialized, which helps with avoiding looped
dependencies in the driver load sequence.</p>
<p>drm_mm maintains a stack of most recently freed holes, which of all
simplistic datastructures seems to be a fairly decent approach to clustering
allocations and avoiding too much fragmentation. This means free space
searches are O(num_holes). Given that all the fancy features drm_mm supports
something better would be fairly complex and since gfx thrashing is a fairly
steep cliff not a real concern. Removing a node again is O(1).</p>
<p>drm_mm supports a few features: Alignment and range restrictions can be
supplied. Furthermore every <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node</span></code></a> has a color value (which is just an
opaque unsigned long) which in conjunction with a driver callback can be used
to implement sophisticated placement restrictions. The i915 DRM driver uses
this to implement guard pages between incompatible caching domains in the
graphics TT.</p>
<p>Two behaviors are supported for searching and allocating: bottom-up and
top-down. The default is bottom-up. Top-down allocation can be used if the
memory area has different restrictions, or just to reduce fragmentation.</p>
<p>Finally iteration helpers to walk all nodes and all holes are provided as are
some basic allocator dumpers for debugging.</p>
<p>Note that this range allocator is not thread-safe, drivers need to protect
modifications with their own locking. The idea behind this is that for a full
memory manager additional data needs to be protected anyway, hence internal
locking would be fully redundant.</p>
</section>
<section id="lru-scan-eviction-support">
<h3>LRU Scan/Eviction Support<a class="headerlink" href="#lru-scan-eviction-support" title="Link to this heading">¶</a></h3>
<p>Very often GPUs need to have continuous allocations for a given object. When
evicting objects to make space for a new one it is therefore not most
efficient when we simply start to select all objects from the tail of an LRU
until there’s a suitable hole: Especially for big objects or nodes that
otherwise have special allocation constraints there’s a good chance we evict
lots of (smaller) objects unnecessarily.</p>
<p>The DRM range allocator supports this use-case through the scanning
interfaces. First a scan operation needs to be initialized with
<a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_init()</span></code></a> or <a class="reference internal" href="#c.drm_mm_scan_init_with_range" title="drm_mm_scan_init_with_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_init_with_range()</span></code></a>. The driver adds
objects to the roster, probably by walking an LRU list, but this can be
freely implemented. Eviction candidates are added using
<a class="reference internal" href="#c.drm_mm_scan_add_block" title="drm_mm_scan_add_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_add_block()</span></code></a> until a suitable hole is found or there are no
further evictable objects. Eviction roster metadata is tracked in <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mm_scan</span></code></a>.</p>
<p>The driver must walk through all objects again in exactly the reverse
order to restore the allocator state. Note that while the allocator is used
in the scan mode no other operation is allowed.</p>
<p>Finally the driver evicts all objects selected (<a class="reference internal" href="#c.drm_mm_scan_remove_block" title="drm_mm_scan_remove_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_remove_block()</span></code></a>
reported true) in the scan, and any overlapping nodes after color adjustment
(<a class="reference internal" href="#c.drm_mm_scan_color_evict" title="drm_mm_scan_color_evict"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_color_evict()</span></code></a>). Adding and removing an object is O(1), and
since freeing a node is also O(1) the overall complexity is
O(scanned_objects). So like the free stack which needs to be walked before a
scan operation even begins this is linear in the number of objects. It
doesn’t seem to hurt too badly.</p>
</section>
<section id="drm-mm-range-allocator-function-references">
<h3>DRM MM Range Allocator Function References<a class="headerlink" href="#drm-mm-range-allocator-function-references" title="Link to this heading">¶</a></h3>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_mm_insert_mode">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_insert_mode</span></span></span><a class="headerlink" href="#c.drm_mm_insert_mode" title="Link to this definition">¶</a><br /></dt>
<dd><p>control search and allocation behaviour</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_BEST</span></code></dt><dd><p>Search for the smallest hole (within the search range) that fits
the desired node.</p>
<p>Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_LOW</span></code></dt><dd><p>Search for the lowest hole (address closest to 0, within the search
range) that fits the desired node.</p>
<p>Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_HIGH</span></code></dt><dd><p>Search for the highest hole (address closest to U64_MAX, within the
search range) that fits the desired node.</p>
<p>Allocates the node from the <em>top</em> of the found hole. The specified
alignment for the node is applied to the base of the node
(<a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node.start</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_EVICT</span></code></dt><dd><p>Search for the most recently evicted hole (within the search range)
that fits the desired node. This is appropriate for use immediately
after performing an eviction scan (see <a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_init()</span></code></a>) and
removing the selected nodes to form a hole.</p>
<p>Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_ONCE</span></code></dt><dd><p>Only check the first hole for suitablity and report -ENOSPC
immediately otherwise, rather than check every hole until a
suitable one is found. Can only be used in conjunction with another
search method such as DRM_MM_INSERT_HIGH or DRM_MM_INSERT_LOW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_HIGHEST</span></code></dt><dd><p>Only check the highest hole (the hole with the largest address) and
insert the node at the top of the hole or report -ENOSPC if
unsuitable.</p>
<p>Does not search all holes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MM_INSERT_LOWEST</span></code></dt><dd><p>Only check the lowest hole (the hole with the smallest address) and
insert the node at the bottom of the hole or report -ENOSPC if
unsuitable.</p>
<p>Does not search all holes.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span></code></a> range manager supports finding a suitable modes using
a number of search trees. These trees are oranised by size, by address and
in most recent eviction order. This allows the user to find either the
smallest hole to reuse, the lowest or highest address to reuse, or simply
reuse the most recent eviction that fits. When allocating the <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node</span></code></a>
from within the hole, the <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_insert_mode</span></code></a> also dictate whether to
allocate the lowest matching address or the highest.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_mm_node">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_node</span></span></span><a class="headerlink" href="#c.drm_mm_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocated block in the DRM allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mm_node {
    unsigned long color;
    u64 start;
    u64 size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">color</span></code></dt><dd><p>Opaque driver-private tag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Start address of the allocated block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the allocated block.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This represents an allocated block in a <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm</span></code></a> allocator. Except for
pre-reserved nodes inserted using <a class="reference internal" href="#c.drm_mm_reserve_node" title="drm_mm_reserve_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_reserve_node()</span></code></a> the structure is
entirely opaque and should only be accessed through the provided funcions.
Since allocation of these nodes is entirely handled by the driver they can be
embedded.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_mm">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm</span></span></span><a class="headerlink" href="#c.drm_mm" title="Link to this definition">¶</a><br /></dt>
<dd><p>DRM allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mm {
    void (*color_adjust)(const struct drm_mm_node *node,unsigned long color, u64 *start, u64 *end);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">color_adjust</span></code></dt><dd><p>Optional driver callback to further apply restrictions on a hole. The
node argument points at the node containing the hole from which the
block would be allocated (see <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_hole_follows()</span></code></a> and friends). The
other arguments are the size of the block to be allocated. The driver
can adjust the start and end as needed to e.g. insert guard pages.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>DRM range allocator with a few special functions and features geared towards
managing GPU memory. Except for the <strong>color_adjust</strong> callback the structure is
entirely opaque and should only be accessed through the provided functions
and macros. This structure can be embedded into larger driver structures.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_mm_scan">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan</span></span></span><a class="headerlink" href="#c.drm_mm_scan" title="Link to this definition">¶</a><br /></dt>
<dd><p>DRM allocator eviction roaster data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mm_scan {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
</div>
<p><strong>Description</strong></p>
<p>This structure tracks data needed for the eviction roaster set up using
<a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_init()</span></code></a>, and used with <a class="reference internal" href="#c.drm_mm_scan_add_block" title="drm_mm_scan_add_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_add_block()</span></code></a> and
<a class="reference internal" href="#c.drm_mm_scan_remove_block" title="drm_mm_scan_remove_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_remove_block()</span></code></a>. The structure is entirely opaque and should only
be accessed through the provided functions and macros. It is meant to be
allocated temporarily by the driver on the stack.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_node_allocated">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_node_allocated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_node_allocated" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks whether a node is allocated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers are required to clear a node prior to using it with the
drm_mm range manager.</p>
<p>Drivers should use this helper for proper encapsulation of drm_mm
internals.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>node</strong> is allocated.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_initialized">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_initialized</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_initialized" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks whether an allocator is initialized</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should clear the <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span></code></a> prior to initialisation if they
want to use this function.</p>
<p>Drivers should use this helper for proper encapsulation of drm_mm
internals.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>mm</strong> is initialized.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_hole_follows">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_hole_follows</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_follows" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks whether a hole follows this node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Holes are embedded into the drm_mm using the tail of a drm_mm_node.
If you wish to know whether a hole follows this particular node,
query this function. See also <a class="reference internal" href="#c.drm_mm_hole_node_start" title="drm_mm_hole_node_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_hole_node_start()</span></code></a> and
<a class="reference internal" href="#c.drm_mm_hole_node_end" title="drm_mm_hole_node_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_hole_node_end()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if a hole follows the <strong>node</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_hole_node_start">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_hole_node_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hole_node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_node_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>computes the start of the hole following <strong>node</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*hole_node</span></code></dt><dd><p>drm_mm_node which implicitly tracks the following hole</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_hole_follows()</span></code></a></p>
<p><strong>Return</strong></p>
<p>Start of the subsequent hole.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_hole_node_end">
<span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_hole_node_end</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hole_node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_node_end" title="Link to this definition">¶</a><br /></dt>
<dd><p>computes the end of the hole following <strong>node</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*hole_node</span></code></dt><dd><p>drm_mm_node which implicitly tracks the following hole</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_hole_follows()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>End of the subsequent hole.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_mm_nodes">
<span class="sig-name descname"><span class="n"><span class="pre">drm_mm_nodes</span></span></span><a class="headerlink" href="#c.drm_mm_nodes" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_mm_nodes</span> <span class="pre">(mm)</span></code></p>
<blockquote>
<div><p>list of nodes under the drm_mm range manager</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span></code></a> range manager</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>As the drm_mm range manager hides its node_list deep with its
structure, extracting it looks painful and repetitive. This is
not expected to be used outside of the <a class="reference internal" href="#c.drm_mm_for_each_node" title="drm_mm_for_each_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_for_each_node()</span></code></a>
macros and similar internal functions.</p>
<p><strong>Return</strong></p>
<p>The node list, may be empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_mm_for_each_node">
<span class="sig-name descname"><span class="n"><span class="pre">drm_mm_for_each_node</span></span></span><a class="headerlink" href="#c.drm_mm_for_each_node" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_mm_for_each_node</span> <span class="pre">(entry,</span> <span class="pre">mm)</span></code></p>
<blockquote>
<div><p>iterator to walk over all allocated nodes</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm</span></code></a> allocator to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a>, so not save against removal of elements.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_mm_for_each_node_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_mm_for_each_node_safe</span></span></span><a class="headerlink" href="#c.drm_mm_for_each_node_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_mm_for_each_node_safe</span> <span class="pre">(entry,</span> <span class="pre">next,</span> <span class="pre">mm)</span></code></p>
<blockquote>
<div><p>iterator to walk over all allocated nodes</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to store the next step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm</span></code></a> allocator to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_safe" title="list_for_each_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_safe()</span></code></a>, so save against removal of elements.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_mm_for_each_hole">
<span class="sig-name descname"><span class="n"><span class="pre">drm_mm_for_each_hole</span></span></span><a class="headerlink" href="#c.drm_mm_for_each_hole" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_mm_for_each_hole</span> <span class="pre">(pos,</span> <span class="pre">mm,</span> <span class="pre">hole_start,</span> <span class="pre">hole_end)</span></code></p>
<blockquote>
<div><p>iterator to walk over all holes</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node</span></code></a> used internally to track progress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm</span></code></dt><dd><p><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm</span></code></a> allocator to walk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hole_start</span></code></dt><dd><p>ulong variable to assign the hole start to on each iteration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hole_end</span></code></dt><dd><p>ulong variable to assign the hole end to on each iteration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all holes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a>, so not save against removal of elements. <strong>entry</strong> is used
internally and will not reflect a real drm_mm_node for the very first hole.
Hence users of this iterator may not access it.</p>
<p>Implementation Note:
We need to inline list_for_each_entry in order to be able to set hole_start
and hole_end on each iteration while keeping the macro sane.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_insert_node_generic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_insert_node_generic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">color</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><span class="n"><span class="pre">drm_mm_insert_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node_generic" title="Link to this definition">¶</a><br /></dt>
<dd><p>search for space and insert <strong>node</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>preallocate node to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>alignment of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>opaque tag value to use for this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt><dd><p>fine-tune the allocation search and placement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_insert_node_in_range" title="drm_mm_insert_node_in_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_insert_node_in_range()</span></code></a> with no
range restrictions applied.</p>
<p>The preallocated node must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there’s no suitable hole.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_insert_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_insert_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>search for space and insert <strong>node</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>preallocate node to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_insert_node_generic" title="drm_mm_insert_node_generic"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_insert_node_generic()</span></code></a> with <strong>color</strong> set
to 0.</p>
<p>The preallocated node must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there’s no suitable hole.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_clean">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_clean</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_clean" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks whether an allocator is clean</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm allocator to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the allocator is completely free, false if there’s still a node
allocated in it.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_mm_for_each_node_in_range">
<span class="sig-name descname"><span class="n"><span class="pre">drm_mm_for_each_node_in_range</span></span></span><a class="headerlink" href="#c.drm_mm_for_each_node_in_range" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_mm_for_each_node_in_range</span> <span class="pre">(node__,</span> <span class="pre">mm__,</span> <span class="pre">start__,</span> <span class="pre">end__)</span></code></p>
<blockquote>
<div><p>iterator to walk over a range of allocated nodes</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node__</span></code></dt><dd><p>drm_mm_node structure to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm__</span></code></dt><dd><p>drm_mm allocator to walk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start__</span></code></dt><dd><p>starting offset, the first node will overlap this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end__</span></code></dt><dd><p>ending offset, the last node will start before this (but may overlap)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator that lie
between <strong>start</strong> and <strong>end</strong>. It is implemented similarly to <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a>,
but using the internal interval tree to accelerate the search for the
starting node, and so not safe against removal of elements. It assumes
that <strong>end</strong> is within (or is the upper limit of) the drm_mm allocator.
If [<strong>start</strong>, <strong>end</strong>] are beyond the range of the drm_mm, the iterator may walk
over the special _unallocated_ <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm.head_node</span></code></a>, and may even continue
indefinitely.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_scan_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><span class="n"><span class="pre">drm_mm_scan</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scan</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">color</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><span class="n"><span class="pre">drm_mm_insert_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize lru scanning</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*scan</span></code></dt><dd><p>scan state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>alignment of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>opaque tag value to use for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt><dd><p>fine-tune the allocation search and placement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_scan_init_with_range" title="drm_mm_scan_init_with_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mm_scan_init_with_range()</span></code></a> with no range
restrictions applied.</p>
<p>This simply sets up the scanning routines with the parameters for the desired
hole.</p>
<p>Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_reserve_node">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_reserve_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_reserve_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert an pre-initialized node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm allocator to insert <strong>node</strong> into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions inserts an already set-up <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mm_node</span></code></a> into the allocator,
meaning that start, size and color must be set by the caller. All other
fields must be cleared to 0. This is useful to initialize the allocator with
preallocated objects which must be set-up before the range allocator can be
set-up, e.g. when taking over a firmware framebuffer.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there’s no hole where <strong>node</strong> is.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_insert_node_in_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_insert_node_in_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">node</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">color</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range_start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range_end</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><span class="n"><span class="pre">drm_mm_insert_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node_in_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>ranged search for space and insert <strong>node</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">mm</span></code></dt><dd><p>drm_mm to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">node</span></code></dt><dd><p>preallocate node to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>alignment of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>opaque tag value to use for this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range_start</span></code></dt><dd><p>start of the allowed range for this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range_end</span></code></dt><dd><p>end of the allowed range for this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt><dd><p>fine-tune the allocation search and placement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The preallocated <strong>node</strong> must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there’s no suitable hole.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_remove_node">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_remove_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_remove_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove a memory node from the allocator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This just removes a node from its drm_mm allocator. The node does not need to
be cleared again before it can be re-inserted into this or any other drm_mm
allocator. It is a bug to call this function on a unallocated node.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_scan_init_with_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan_init_with_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><span class="n"><span class="pre">drm_mm_scan</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scan</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">color</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><span class="n"><span class="pre">drm_mm_insert_mode</span></span></a><span class="w"> </span><span class="n"><span class="pre">mode</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_init_with_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize range-restricted lru scanning</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*scan</span></code></dt><dd><p>scan state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt><dd><p>alignment of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt><dd><p>opaque tag value to use for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start of the allowed range for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end of the allowed range for the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt><dd><p>fine-tune the allocation search and placement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply sets up the scanning routines with the parameters for the desired
hole.</p>
<p>Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_scan_add_block">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan_add_block</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><span class="n"><span class="pre">drm_mm_scan</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scan</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_add_block" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a node to the scan list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*scan</span></code></dt><dd><p>the active drm_mm scanner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a node to the scan list that might be freed to make space for the desired
hole.</p>
<p><strong>Return</strong></p>
<p>True if a hole has been found, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_scan_remove_block">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan_remove_block</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><span class="n"><span class="pre">drm_mm_scan</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scan</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">node</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_remove_block" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a node from the scan list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*scan</span></code></dt><dd><p>the active drm_mm scanner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*node</span></code></dt><dd><p>drm_mm_node to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Nodes <strong>must</strong> be removed in exactly the reverse order from the scan list as
they have been added (e.g. using <a class="reference internal" href="../core-api/kernel-api.html#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a> as they are added and then
<a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a> over that eviction list to remove), otherwise the internal
state of the memory manager will be corrupted.</p>
<p>When the scan list is empty, the selected memory nodes can be freed. An
immediately following drm_mm_insert_node_in_range_generic() or one of the
simpler versions of that function with !DRM_MM_SEARCH_BEST will then return
the just freed block (because it’s at the top of the free_stack list).</p>
<p><strong>Return</strong></p>
<p>True if this block should be evicted, false otherwise. Will always
return false when no hole has been found.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_scan_color_evict">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><span class="n"><span class="pre">drm_mm_node</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_scan_color_evict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><span class="n"><span class="pre">drm_mm_scan</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">scan</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_color_evict" title="Link to this definition">¶</a><br /></dt>
<dd><p>evict overlapping nodes on either side of hole</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*scan</span></code></dt><dd><p>drm_mm scan with target hole</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After completing an eviction scan and removing the selected nodes, we may
need to remove a few more nodes from either side of the target hole if
mm.color_adjust is being used.</p>
<p><strong>Return</strong></p>
<p>A node to evict, or NULL if there are no overlapping nodes.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a drm-mm allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>the drm_mm structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start of the range managed by <strong>mm</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>end of the range managed by <strong>mm</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>mm</strong> must be cleared to 0 before calling this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_takedown">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_takedown</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_takedown" title="Link to this definition">¶</a><br /></dt>
<dd><p>clean up a drm_mm allocator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm allocator to clean up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that it is a bug to call this function on an allocator which is not
clean.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_mm_print">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_mm_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_mm" title="drm_mm"><span class="n"><span class="pre">drm_mm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>print allocator state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*mm</span></code></dt><dd><p>drm_mm allocator to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer to use</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="drm-gpuvm">
<span id="id2"></span><h2>DRM GPUVM<a class="headerlink" href="#drm-gpuvm" title="Link to this heading">¶</a></h2>
<section id="id3">
<h3>Overview<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<p>The DRM GPU VA Manager, represented by <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> keeps track of a
GPU’s virtual address (VA) space and manages the corresponding virtual
mappings represented by <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> objects. It also keeps track of the
mapping’s backing <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> buffers.</p>
<p><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> buffers maintain a list of <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> objects representing
all existent GPU VA mappings using this <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> as backing buffer.</p>
<p>GPU VAs can be flagged as sparse, such that drivers may use GPU VAs to also
keep track of sparse PTEs in order to support Vulkan ‘Sparse Resources’.</p>
<p>The GPU VA manager internally uses a rb-tree to manage the
<a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> mappings within a GPU’s virtual address space.</p>
<p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> structure contains a special <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> representing the
portion of VA space reserved by the kernel. This node is initialized together
with the GPU VA manager instance and removed when the GPU VA manager is
destroyed.</p>
<p>In a typical application drivers would embed <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> and
<a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span></code></a> within their own driver specific structures, there won’t be
any memory allocations of its own nor memory allocations of <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>
entries.</p>
<p>The data structures needed to store <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> within the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> are
contained within <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span></code></a> already. Hence, for inserting <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>
entries from within dma-fence signalling critical sections it is enough to
pre-allocate the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures.</p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> which are private to a single VM can share a common
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> in order to improve locking efficiency (e.g. with <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a>).
For this purpose drivers must pass a <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> to <a class="reference internal" href="#c.drm_gpuvm_init" title="drm_gpuvm_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_init()</span></code></a>, in
the following called ‘resv object’, which serves as the container of the
GPUVM’s shared <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>. This resv object can be a driver specific
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>, such as the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> containing the root page table,
but it can also be a ‘dummy’ object, which can be allocated with
<a class="reference internal" href="#c.drm_gpuvm_resv_object_alloc" title="drm_gpuvm_resv_object_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_resv_object_alloc()</span></code></a>.</p>
<p>In order to connect a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span></code></a> its backing <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> each
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> maintains a list of <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> structures, and each
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> contains a list of <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures.</p>
<p>A <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> is an abstraction that represents a combination of a
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and a <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. Every such combination should be unique.
This is ensured by the API through <a class="reference internal" href="#c.drm_gpuvm_bo_obtain" title="drm_gpuvm_bo_obtain"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_obtain()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_bo_obtain_prealloc" title="drm_gpuvm_bo_obtain_prealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_obtain_prealloc()</span></code></a> which first look into the corresponding
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> list of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bos</span></code> for an existing instance of this
particular combination. If not existent a new instance is created and linked
to the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>.</p>
<p><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> structures, since unique for a given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>, are also used
as entry for the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s lists of external and evicted objects. Those
lists are maintained in order to accelerate locking of dma-resv locks and
validation of evicted objects bound in a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>. For instance, all
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>’s <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> of a given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> can be locked by calling
<a class="reference internal" href="#c.drm_gpuvm_exec_lock" title="drm_gpuvm_exec_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_exec_lock()</span></code></a>. Once locked drivers can call <a class="reference internal" href="#c.drm_gpuvm_validate" title="drm_gpuvm_validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_validate()</span></code></a> in
order to validate all evicted <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code>. It is also possible to lock
additional <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> by providing the corresponding parameters to
<a class="reference internal" href="#c.drm_gpuvm_exec_lock" title="drm_gpuvm_exec_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_exec_lock()</span></code></a> as well as open code the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> loop while making
use of helper functions such as <a class="reference internal" href="#c.drm_gpuvm_prepare_range" title="drm_gpuvm_prepare_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_prepare_range()</span></code></a> or
<a class="reference internal" href="#c.drm_gpuvm_prepare_objects" title="drm_gpuvm_prepare_objects"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_prepare_objects()</span></code></a>.</p>
<p>Every bound <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> is treated as external object when its <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>
structure is different than the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s common <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> structure.</p>
</section>
<section id="split-and-merge">
<h3>Split and Merge<a class="headerlink" href="#split-and-merge" title="Link to this heading">¶</a></h3>
<p>Besides its capability to manage and represent a GPU VA space, the
GPU VA manager also provides functions to let the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> calculate a
sequence of operations to satisfy a given map or unmap request.</p>
<p>Therefore the DRM GPU VA manager provides an algorithm implementing splitting
and merging of existent GPU VA mappings with the ones that are requested to
be mapped or unmapped. This feature is required by the Vulkan API to
implement Vulkan ‘Sparse Memory Bindings’ - drivers UAPIs often refer to this
as VM BIND.</p>
<p>Drivers can call <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> to receive a sequence of callbacks
containing map, unmap and remap operations for a given newly requested
mapping. The sequence of callbacks represents the set of operations to
execute in order to integrate the new mapping cleanly into the current state
of the GPU VA space.</p>
<p>Depending on how the new GPU VA mapping intersects with the existent mappings
of the GPU VA space the <a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> callbacks contain an arbitrary amount
of unmap operations, a maximum of two remap operations and a single map
operation. The caller might receive no callback at all if no operation is
required, e.g. if the requested mapping already exists in the exact same way.</p>
<p>The single map operation represents the original map operation requested by
the caller.</p>
<p><a class="reference internal" href="#c.drm_gpuva_op_unmap" title="drm_gpuva_op_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_unmap</span></code></a> contains a ‘keep’ field, which indicates whether the
<a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to unmap is physically contiguous with the original mapping
request. Optionally, if ‘keep’ is set, drivers may keep the actual page table
entries for this <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>, adding the missing page table entries only and
update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of things accordingly.</p>
<p>Drivers may do the same optimization, namely delta page table updates, also
for remap operations. This is possible since <a class="reference internal" href="#c.drm_gpuva_op_remap" title="drm_gpuva_op_remap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_remap</span></code></a> consists of
one unmap operation and one or two map operations, such that drivers can
derive the page table update delta accordingly.</p>
<p>Note that there can’t be more than two existent mappings to split up, one at
the beginning and one at the end of the new mapping, hence there is a
maximum of two remap operations.</p>
<p>Analogous to <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap()</span></code></a> uses <a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> to
call back into the driver in order to unmap a range of GPU VA space. The
logic behind this function is way simpler though: For all existent mappings
enclosed by the given range unmap operations are created. For mappings which
are only partically located within the given range, remap operations are
created such that those mappings are split up and re-mapped partically.</p>
<p>As an alternative to <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> and <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap()</span></code></a>,
<a class="reference internal" href="#c.drm_gpuvm_sm_map_ops_create" title="drm_gpuvm_sm_map_ops_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map_ops_create()</span></code></a> and <a class="reference internal" href="#c.drm_gpuvm_sm_unmap_ops_create" title="drm_gpuvm_sm_unmap_ops_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap_ops_create()</span></code></a> can be used
to directly obtain an instance of <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_ops</span></code></a> containing a list of
<a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a>, which can be iterated with <a class="reference internal" href="#c.drm_gpuva_for_each_op" title="drm_gpuva_for_each_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op()</span></code></a>. This list
contains the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> analogous to the callbacks one would receive when
calling <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> or <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap()</span></code></a>. While this way requires
more memory (to allocate the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>), it provides drivers a way to
iterate the <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> multiple times, e.g. once in a context where memory
allocations are possible (e.g. to allocate GPU page tables) and once in the
dma-fence signalling critical path.</p>
<p>To update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space <a class="reference internal" href="#c.drm_gpuva_insert" title="drm_gpuva_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_insert()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuva_remove" title="drm_gpuva_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_remove()</span></code></a> may be used. These functions can safely be used from
<a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> callbacks originating from <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> or
<a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap()</span></code></a>. However, it might be more convenient to use the
provided helper functions <a class="reference internal" href="#c.drm_gpuva_map" title="drm_gpuva_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_map()</span></code></a>, <a class="reference internal" href="#c.drm_gpuva_remap" title="drm_gpuva_remap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_remap()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuva_unmap" title="drm_gpuva_unmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_unmap()</span></code></a> instead.</p>
<p>The following diagram depicts the basic relationships of existent GPU VA
mappings, a newly requested mapping and the resulting mappings as implemented
by <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map()</span></code></a> - it doesn’t cover any arbitrary combinations of these.</p>
<ol class="arabic">
<li><p>Requested mapping is identical. Replace it, but indicate the backing PTEs
could be kept.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     1
old: |-----------| (bo_offset=n)

     0     a     1
req: |-----------| (bo_offset=n)

     0     a     1
new: |-----------| (bo_offset=n)
</pre></div>
</div>
</li>
<li><p>Requested mapping is identical, except for the BO offset, hence replace
the mapping.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     1
old: |-----------| (bo_offset=n)

     0     a     1
req: |-----------| (bo_offset=m)

     0     a     1
new: |-----------| (bo_offset=m)
</pre></div>
</div>
</li>
<li><p>Requested mapping is identical, except for the backing BO, hence replace
the mapping.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     1
old: |-----------| (bo_offset=n)

     0     b     1
req: |-----------| (bo_offset=n)

     0     b     1
new: |-----------| (bo_offset=n)
</pre></div>
</div>
</li>
<li><p>Existent mapping is a left aligned subset of the requested one, hence
replace the existent one.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0  a  1
old: |-----|       (bo_offset=n)

     0     a     2
req: |-----------| (bo_offset=n)

     0     a     2
new: |-----------| (bo_offset=n)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We expect to see the same result for a request with a different BO
and/or non-contiguous BO offset.</p>
</div>
</li>
<li><p>Requested mapping’s range is a left aligned subset of the existent one,
but backed by a different BO. Hence, map the requested mapping and split
the existent one adjusting its BO offset.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     2
old: |-----------| (bo_offset=n)

     0  b  1
req: |-----|       (bo_offset=n)

     0  b  1  a&#39; 2
new: |-----|-----| (b.bo_offset=n, a.bo_offset=n+1)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We expect to see the same result for a request with a different BO
and/or non-contiguous BO offset.</p>
</div>
</li>
<li><p>Existent mapping is a superset of the requested mapping. Split it up, but
indicate that the backing PTEs could be kept.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     2
old: |-----------| (bo_offset=n)

     0  a  1
req: |-----|       (bo_offset=n)

     0  a  1  a&#39; 2
new: |-----|-----| (a.bo_offset=n, a&#39;.bo_offset=n+1)
</pre></div>
</div>
</li>
<li><p>Requested mapping’s range is a right aligned subset of the existent one,
but backed by a different BO. Hence, map the requested mapping and split
the existent one, without adjusting the BO offset.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     2
old: |-----------| (bo_offset=n)

           1  b  2
req:       |-----| (bo_offset=m)

     0  a  1  b  2
new: |-----|-----| (a.bo_offset=n,b.bo_offset=m)
</pre></div>
</div>
</li>
<li><p>Existent mapping is a superset of the requested mapping. Split it up, but
indicate that the backing PTEs could be kept.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      0     a     2
old: |-----------| (bo_offset=n)

           1  a  2
req:       |-----| (bo_offset=n+1)

     0  a&#39; 1  a  2
new: |-----|-----| (a&#39;.bo_offset=n, a.bo_offset=n+1)
</pre></div>
</div>
</li>
<li><p>Existent mapping is overlapped at the end by the requested mapping backed
by a different BO. Hence, map the requested mapping and split up the
existent one, without adjusting the BO offset.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     2
old: |-----------|       (bo_offset=n)

           1     b     3
req:       |-----------| (bo_offset=m)

     0  a  1     b     3
new: |-----|-----------| (a.bo_offset=n,b.bo_offset=m)
</pre></div>
</div>
</li>
<li><p>Existent mapping is overlapped by the requested mapping, both having the
same backing BO with a contiguous offset. Indicate the backing PTEs of
the old mapping could be kept.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0     a     2
old: |-----------|       (bo_offset=n)

           1     a     3
req:       |-----------| (bo_offset=n+1)

     0  a&#39; 1     a     3
new: |-----|-----------| (a&#39;.bo_offset=n, a.bo_offset=n+1)
</pre></div>
</div>
</li>
<li><p>Requested mapping’s range is a centered subset of the existent one
having a different backing BO. Hence, map the requested mapping and split
up the existent one in two mappings, adjusting the BO offset of the right
one accordingly.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0        a        3
old: |-----------------| (bo_offset=n)

           1  b  2
req:       |-----|       (bo_offset=m)

     0  a  1  b  2  a&#39; 3
new: |-----|-----|-----| (a.bo_offset=n,b.bo_offset=m,a&#39;.bo_offset=n+2)
</pre></div>
</div>
</li>
<li><p>Requested mapping is a contiguous subset of the existent one. Split it
up, but indicate that the backing PTEs could be kept.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     0        a        3
old: |-----------------| (bo_offset=n)

           1  a  2
req:       |-----|       (bo_offset=n+1)

     0  a&#39; 1  a  2 a&#39;&#39; 3
old: |-----|-----|-----| (a&#39;.bo_offset=n, a.bo_offset=n+1, a&#39;&#39;.bo_offset=n+2)
</pre></div>
</div>
</li>
<li><p>Existent mapping is a right aligned subset of the requested one, hence
replace the existent one.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           1  a  2
old:       |-----| (bo_offset=n+1)

     0     a     2
req: |-----------| (bo_offset=n)

     0     a     2
new: |-----------| (bo_offset=n)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We expect to see the same result for a request with a different bo
and/or non-contiguous bo_offset.</p>
</div>
</li>
<li><p>Existent mapping is a centered subset of the requested one, hence
replace the existent one.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           1  a  2
old:       |-----| (bo_offset=n+1)

     0        a       3
req: |----------------| (bo_offset=n)

     0        a       3
new: |----------------| (bo_offset=n)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We expect to see the same result for a request with a different bo
and/or non-contiguous bo_offset.</p>
</div>
</li>
<li><p>Existent mappings is overlapped at the beginning by the requested mapping
backed by a different BO. Hence, map the requested mapping and split up
the existent one, adjusting its BO offset accordingly.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           1     a     3
old:       |-----------| (bo_offset=n)

     0     b     2
req: |-----------|       (bo_offset=m)

     0     b     2  a&#39; 3
new: |-----------|-----| (b.bo_offset=m,a.bo_offset=n+2)
</pre></div>
</div>
</li>
</ol>
</section>
<section id="locking">
<span id="drm-gpuvm-locking"></span><h3>Locking<a class="headerlink" href="#locking" title="Link to this heading">¶</a></h3>
<p>In terms of managing <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> entries DRM GPUVM does not take care of
locking itself, it is the drivers responsibility to take care about locking.
Drivers might want to protect the following operations: inserting, removing
and iterating <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> objects as well as generating all kinds of
operations, such as split / merge or prefetch.</p>
<p>DRM GPUVM also does not take care of the locking of the backing
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> buffers GPU VA lists and <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> abstractions by
itself; drivers are responsible to enforce mutual exclusion using either the
GEMs dma_resv lock or alternatively a driver specific external lock. For the
latter see also <a class="reference internal" href="#c.drm_gem_gpuva_set_lock" title="drm_gem_gpuva_set_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_gpuva_set_lock()</span></code></a>.</p>
<p>However, DRM GPUVM contains lockdep checks to ensure callers of its API hold
the corresponding lock whenever the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> GPU VA list is accessed
by functions such as <a class="reference internal" href="#c.drm_gpuva_link" title="drm_gpuva_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_link()</span></code></a> or <a class="reference internal" href="#c.drm_gpuva_unlink" title="drm_gpuva_unlink"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_unlink()</span></code></a>, but also
<a class="reference internal" href="#c.drm_gpuvm_bo_obtain" title="drm_gpuvm_bo_obtain"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_obtain()</span></code></a> and <a class="reference internal" href="#c.drm_gpuvm_bo_put" title="drm_gpuvm_bo_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_put()</span></code></a>.</p>
<p>The latter is required since on creation and destruction of a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>
the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> is attached / removed from the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> gpuva list.
Subsequent calls to <a class="reference internal" href="#c.drm_gpuvm_bo_obtain" title="drm_gpuvm_bo_obtain"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_obtain()</span></code></a> for the same <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> must be able to observe previous creations and destructions
of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bos</span></code> in order to keep instances unique.</p>
<p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s lists for keeping track of external and evicted objects are
protected against concurrent insertion / removal and iteration internally.</p>
<p>However, drivers still need ensure to protect concurrent calls to functions
iterating those lists, namely <a class="reference internal" href="#c.drm_gpuvm_prepare_objects" title="drm_gpuvm_prepare_objects"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_prepare_objects()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_validate" title="drm_gpuvm_validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_validate()</span></code></a>.</p>
<p>Alternatively, drivers can set the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GPUVM_RESV_PROTECTED</span></code> flag to indicate
that the corresponding <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> locks are held in order to protect the
lists. If <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GPUVM_RESV_PROTECTED</span></code> is set, internal locking is disabled and
the corresponding lockdep checks are enabled. This is an optimization for
drivers which are capable of taking the corresponding <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> locks and
hence do not require internal locking.</p>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h3>
<p>This section gives two examples on how to let the DRM GPUVA Manager generate
<a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> in order to satisfy a given map or unmap request and how to
make use of them.</p>
<p>The below code is strictly limited to illustrate the generic usage pattern.
To maintain simplicitly, it doesn’t make use of any abstractions for common
code, different (asyncronous) stages with fence signalling critical paths,
any other helpers or error handling in terms of freeing memory and dropping
previously taken locks.</p>
<ol class="arabic">
<li><p>Obtain a list of <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to create a new mapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Allocates a new &amp;drm_gpuva.
struct drm_gpuva * driver_gpuva_alloc(void);

// Typically drivers would embedd the &amp;drm_gpuvm and &amp;drm_gpuva
// structure in individual driver structures and lock the dma-resv with
// drm_exec or similar helpers.
int driver_mapping_create(struct drm_gpuvm *gpuvm,
                          u64 addr, u64 range,
                          struct drm_gem_object *obj, u64 offset)
{
        struct drm_gpuva_ops *ops;
        struct drm_gpuva_op *op
        struct drm_gpuvm_bo *vm_bo;

        driver_lock_va_space();
        ops = drm_gpuvm_sm_map_ops_create(gpuvm, addr, range,
                                          obj, offset);
        if (IS_ERR(ops))
                return PTR_ERR(ops);

        vm_bo = drm_gpuvm_bo_obtain(gpuvm, obj);
        if (IS_ERR(vm_bo))
                return PTR_ERR(vm_bo);

        drm_gpuva_for_each_op(op, ops) {
                struct drm_gpuva *va;

                switch (op-&gt;op) {
                case DRM_GPUVA_OP_MAP:
                        va = driver_gpuva_alloc();
                        if (!va)
                                ; // unwind previous VA space updates,
                                  // free memory and unlock

                        driver_vm_map();
                        drm_gpuva_map(gpuvm, va, &amp;op-&gt;map);
                        drm_gpuva_link(va, vm_bo);

                        break;
                case DRM_GPUVA_OP_REMAP: {
                        struct drm_gpuva *prev = NULL, *next = NULL;

                        va = op-&gt;remap.unmap-&gt;va;

                        if (op-&gt;remap.prev) {
                                prev = driver_gpuva_alloc();
                                if (!prev)
                                        ; // unwind previous VA space
                                          // updates, free memory and
                                          // unlock
                        }

                        if (op-&gt;remap.next) {
                                next = driver_gpuva_alloc();
                                if (!next)
                                        ; // unwind previous VA space
                                          // updates, free memory and
                                          // unlock
                        }

                        driver_vm_remap();
                        drm_gpuva_remap(prev, next, &amp;op-&gt;remap);

                        if (prev)
                                drm_gpuva_link(prev, va-&gt;vm_bo);
                        if (next)
                                drm_gpuva_link(next, va-&gt;vm_bo);
                        drm_gpuva_unlink(va);

                        break;
                }
                case DRM_GPUVA_OP_UNMAP:
                        va = op-&gt;unmap-&gt;va;

                        driver_vm_unmap();
                        drm_gpuva_unlink(va);
                        drm_gpuva_unmap(&amp;op-&gt;unmap);

                        break;
                default:
                        break;
                }
        }
        drm_gpuvm_bo_put(vm_bo);
        driver_unlock_va_space();

        return 0;
}
</pre></div>
</div>
</li>
<li><p>Receive a callback for each <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to create a new mapping:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct driver_context {
        struct drm_gpuvm *gpuvm;
        struct drm_gpuvm_bo *vm_bo;
        struct drm_gpuva *new_va;
        struct drm_gpuva *prev_va;
        struct drm_gpuva *next_va;
};

// ops to pass to drm_gpuvm_init()
static const struct drm_gpuvm_ops driver_gpuvm_ops = {
        .sm_step_map = driver_gpuva_map,
        .sm_step_remap = driver_gpuva_remap,
        .sm_step_unmap = driver_gpuva_unmap,
};

// Typically drivers would embedd the &amp;drm_gpuvm and &amp;drm_gpuva
// structure in individual driver structures and lock the dma-resv with
// drm_exec or similar helpers.
int driver_mapping_create(struct drm_gpuvm *gpuvm,
                          u64 addr, u64 range,
                          struct drm_gem_object *obj, u64 offset)
{
        struct driver_context ctx;
        struct drm_gpuvm_bo *vm_bo;
        struct drm_gpuva_ops *ops;
        struct drm_gpuva_op *op;
        int ret = 0;

        ctx.gpuvm = gpuvm;

        ctx.new_va = kzalloc(sizeof(*ctx.new_va), GFP_KERNEL);
        ctx.prev_va = kzalloc(sizeof(*ctx.prev_va), GFP_KERNEL);
        ctx.next_va = kzalloc(sizeof(*ctx.next_va), GFP_KERNEL);
        ctx.vm_bo = drm_gpuvm_bo_create(gpuvm, obj);
        if (!ctx.new_va || !ctx.prev_va || !ctx.next_va || !vm_bo) {
                ret = -ENOMEM;
                goto out;
        }

        // Typically protected with a driver specific GEM gpuva lock
        // used in the fence signaling path for drm_gpuva_link() and
        // drm_gpuva_unlink(), hence pre-allocate.
        ctx.vm_bo = drm_gpuvm_bo_obtain_prealloc(ctx.vm_bo);

        driver_lock_va_space();
        ret = drm_gpuvm_sm_map(gpuvm, &amp;ctx, addr, range, obj, offset);
        driver_unlock_va_space();

out:
        drm_gpuvm_bo_put(ctx.vm_bo);
        kfree(ctx.new_va);
        kfree(ctx.prev_va);
        kfree(ctx.next_va);
        return ret;
}

int driver_gpuva_map(struct drm_gpuva_op *op, void *__ctx)
{
        struct driver_context *ctx = __ctx;

        drm_gpuva_map(ctx-&gt;vm, ctx-&gt;new_va, &amp;op-&gt;map);

        drm_gpuva_link(ctx-&gt;new_va, ctx-&gt;vm_bo);

        // prevent the new GPUVA from being freed in
        // driver_mapping_create()
        ctx-&gt;new_va = NULL;

        return 0;
}

int driver_gpuva_remap(struct drm_gpuva_op *op, void *__ctx)
{
        struct driver_context *ctx = __ctx;
        struct drm_gpuva *va = op-&gt;remap.unmap-&gt;va;

        drm_gpuva_remap(ctx-&gt;prev_va, ctx-&gt;next_va, &amp;op-&gt;remap);

        if (op-&gt;remap.prev) {
                drm_gpuva_link(ctx-&gt;prev_va, va-&gt;vm_bo);
                ctx-&gt;prev_va = NULL;
        }

        if (op-&gt;remap.next) {
                drm_gpuva_link(ctx-&gt;next_va, va-&gt;vm_bo);
                ctx-&gt;next_va = NULL;
        }

        drm_gpuva_unlink(va);
        kfree(va);

        return 0;
}

int driver_gpuva_unmap(struct drm_gpuva_op *op, void *__ctx)
{
        drm_gpuva_unlink(op-&gt;unmap.va);
        drm_gpuva_unmap(&amp;op-&gt;unmap);
        kfree(op-&gt;unmap.va);

        return 0;
}
</pre></div>
</div>
</li>
</ol>
</section>
<section id="drm-gpuvm-function-references">
<h3>DRM GPUVM Function References<a class="headerlink" href="#drm-gpuvm-function-references" title="Link to this heading">¶</a></h3>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_gpuva_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_flags</span></span></span><a class="headerlink" href="#c.drm_gpuva_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>flags for <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_INVALIDATED</span></code></dt><dd><p>Flag indicating that the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>’s backing GEM is invalidated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_SPARSE</span></code></dt><dd><p>Flag indicating that the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> is a sparse mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_USERBITS</span></code></dt><dd><p>user defined bits</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva</span></span></span><a class="headerlink" href="#c.drm_gpuva" title="Link to this definition">¶</a><br /></dt>
<dd><p>structure to track a GPU VA mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva {
    struct drm_gpuvm *vm;
    struct drm_gpuvm_bo *vm_bo;
    enum drm_gpuva_flags flags;
    struct {
        u64 addr;
        u64 range;
    } va;
    struct {
        u64 offset;
        struct drm_gem_object *obj;
        struct list_head entry;
    } gem;
    struct {
        struct rb_node node;
        struct list_head entry;
        u64 __subtree_last;
    } rb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> this object is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> abstraction for the mapped
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_flags" title="drm_gpuva_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_flags</span></code></a> for this mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>structure containing the address and range of the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va.addr</span></code></dt><dd><p>the start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem</span></code></dt><dd><p>structure containing the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> and it’s offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem.offset</span></code></dt><dd><p>the offset within the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem.obj</span></code></dt><dd><p>the mapped <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem.entry</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> to attach this object to a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb</span></code></dt><dd><p>structure containing data to store <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> in a rb-tree</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb.node</span></code></dt><dd><p>the rb-tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb.entry</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> to additionally connect <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code>
in the same order they appear in the interval tree. This is
useful to keep iterating <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> from a start node found
through the rb-tree while doing modifications on the rb-tree
itself.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb.__subtree_last</span></code></dt><dd><p>needed by the interval tree, holding last-in-subtree</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a GPU VA mapping and is associated with a
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
<p>Typically, this structure is embedded in bigger driver structures.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_invalidate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_invalidate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">invalidate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_invalidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>sets whether the backing GEM of this <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> is invalidated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to set the invalidate flag for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">invalidate</span></code></dt><dd><p>indicates whether the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> is invalidated</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_invalidated">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_invalidated</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_invalidated" title="Link to this definition">¶</a><br /></dt>
<dd><p>indicates whether the backing BO of this <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> is invalidated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the GPU VA is invalidated, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise</p>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_gpuvm_flags">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_flags</span></span></span><a class="headerlink" href="#c.drm_gpuvm_flags" title="Link to this definition">¶</a><br /></dt>
<dd><p>flags for <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVM_RESV_PROTECTED</span></code></dt><dd><p>GPUVM is protected externally by the
GPUVM’s <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVM_USERBITS</span></code></dt><dd><p>user defined bits</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuvm">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm</span></span></span><a class="headerlink" href="#c.drm_gpuvm" title="Link to this definition">¶</a><br /></dt>
<dd><p>DRM GPU VA Manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuvm {
    const char *name;
    enum drm_gpuvm_flags flags;
    struct drm_device *drm;
    u64 mm_start;
    u64 mm_range;
    struct {
        struct rb_root_cached tree;
        struct list_head list;
    } rb;
    struct kref kref;
    struct drm_gpuva kernel_alloc_node;
    const struct drm_gpuvm_ops *ops;
    struct drm_gem_object *r_obj;
    struct {
        struct list_head list;
        struct list_head *local_list;
        spinlock_t lock;
    } extobj;
    struct {
        struct list_head list;
        struct list_head *local_list;
        spinlock_t lock;
    } evict;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>the name of the DRM GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_flags" title="drm_gpuvm_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_flags</span></code></a> of this GPUVM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm</span></code></dt><dd><p>the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> this VM lives in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm_start</span></code></dt><dd><p>start of the VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm_range</span></code></dt><dd><p>length of the VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb</span></code></dt><dd><p>structures to track <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb.tree</span></code></dt><dd><p>the rb-tree to track GPU VA mappings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb.list</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> to track GPU VA mappings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>reference count of this object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_alloc_node</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> representing the address space cutout reserved for
the kernel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> providing the split/merge steps to drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">r_obj</span></code></dt><dd><p>Resv GEM object; representing the GPUVM’s common <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extobj</span></code></dt><dd><p>structure holding the extobj list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extobj.list</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> storing <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bos</span></code> serving as
external object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extobj.local_list</span></code></dt><dd><p>pointer to the local list temporarily
storing entries from the external object list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extobj.lock</span></code></dt><dd><p>spinlock to protect the extobj list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evict</span></code></dt><dd><p>structure holding the evict list and evict list lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evict.list</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> storing <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bos</span></code> currently
being evicted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evict.local_list</span></code></dt><dd><p>pointer to the local list temporarily
storing entries from the evicted object list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evict.lock</span></code></dt><dd><p>spinlock to protect the evict list</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The DRM GPU VA Manager keeps track of a GPU’s virtual address space by using
<code class="xref c c-type docutils literal notranslate"><span class="pre">maple_tree</span></code> structures. Typically, this structure is embedded in bigger
driver structures.</p>
<p>Drivers can pass addresses and ranges in an arbitrary unit, e.g. bytes or
pages.</p>
<p>There should be one manager instance per GPU virtual address space.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>acquire a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to acquire the reference of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires an additional reference to <strong>gpuvm</strong>. It is illegal to
call this without already holding a reference. No locks required.</p>
<p><strong>Return</strong></p>
<p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> pointer</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_resv_protected">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_resv_protected</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_resv_protected" title="Link to this definition">¶</a><br /></dt>
<dd><p>indicates whether <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GPUVM_RESV_PROTECTED</span></code> is set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_GPUVM_RESV_PROTECTED</span></code> is set, false otherwise.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_resv">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_resv</span></span></span><a class="headerlink" href="#c.drm_gpuvm_resv" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_resv</span> <span class="pre">(gpuvm__)</span></code></p>
<blockquote>
<div><p>returns the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s shared <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a></p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_resv_obj">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_resv_obj</span></span></span><a class="headerlink" href="#c.drm_gpuvm_resv_obj" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_resv_obj</span> <span class="pre">(gpuvm__)</span></code></p>
<blockquote>
<div><p>returns the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> holding the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> holding the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s shared
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_is_extobj">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_is_extobj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_is_extobj" title="Link to this definition">¶</a><br /></dt>
<dd><p>indicates whether the given <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> is an external object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> differs from the
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvms</span></code> <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>, false otherwise</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_for_each_va_range">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_for_each_va_range</span></span></span><a class="headerlink" href="#c.drm_gpuvm_for_each_va_range" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_range</span> <span class="pre">(va__,</span> <span class="pre">gpuvm__,</span> <span class="pre">start__,</span> <span class="pre">end__)</span></code></p>
<blockquote>
<div><p>iterate over a range of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structure to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to walk over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start__</span></code></dt><dd><p>starting offset, the first gpuva will overlap this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end__</span></code></dt><dd><p>ending offset, the last gpuva will start before this (but may
overlap)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> in the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> that lie
between <strong>start__</strong> and <strong>end__</strong>. It is implemented similarly to <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a>,
but is using the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s internal interval tree to accelerate
the search for the starting <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>, and hence isn’t safe against removal
of elements. It assumes that <strong>end__</strong> is within (or is the upper limit of) the
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>. This iterator does not skip over the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s
<strong>kernel_alloc_node</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_for_each_va_range_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_for_each_va_range_safe</span></span></span><a class="headerlink" href="#c.drm_gpuvm_for_each_va_range_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_range_safe</span> <span class="pre">(va__,</span> <span class="pre">next__,</span> <span class="pre">gpuvm__,</span> <span class="pre">start__,</span> <span class="pre">end__)</span></code></p>
<blockquote>
<div><p>safely iterate over a range of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next__</span></code></dt><dd><p>another <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to walk over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start__</span></code></dt><dd><p>starting offset, the first gpuva will overlap this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end__</span></code></dt><dd><p>ending offset, the last gpuva will start before this (but may
overlap)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> in the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> that lie
between <strong>start__</strong> and <strong>end__</strong>. It is implemented similarly to
<a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_safe" title="list_for_each_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_safe()</span></code></a>, but is using the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s internal interval
tree to accelerate the search for the starting <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>, and hence is safe
against removal of elements. It assumes that <strong>end__</strong> is within (or is the
upper limit of) the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>. This iterator does not skip over the
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s <strong>kernel_alloc_node</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_for_each_va">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_for_each_va</span></span></span><a class="headerlink" href="#c.drm_gpuvm_for_each_va" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va</span> <span class="pre">(va__,</span> <span class="pre">gpuvm__)</span></code></p>
<blockquote>
<div><p>iterate over all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to walk over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures associated with the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_for_each_va_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_for_each_va_safe</span></span></span><a class="headerlink" href="#c.drm_gpuvm_for_each_va_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_safe</span> <span class="pre">(va__,</span> <span class="pre">next__,</span> <span class="pre">gpuvm__)</span></code></p>
<blockquote>
<div><p>safely iterate over all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next__</span></code></dt><dd><p>another <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpuvm__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to walk over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures associated with the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>. It is implemented with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_safe" title="list_for_each_entry_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_safe()</span></code></a>, and
hence safe against the removal of elements.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></span><a class="headerlink" href="#c.drm_gpuvm_exec" title="Link to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> abstraction of <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuvm_exec {
    struct drm_exec exec;
    u32 flags;
    struct drm_gpuvm *vm;
    unsigned int num_fences;
    struct {
        int (*fn)(struct drm_gpuvm_exec *vm_exec);
        void *priv;
    } extra;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>the flags for the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to lock its DMA reservations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_fences</span></code></dt><dd><p>the number of fences to reserve for the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> of the
locked <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra</span></code></dt><dd><p>Callback and corresponding private data for the driver to
lock arbitrary additional <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra.fn</span></code></dt><dd><p>The driver callback to lock additional
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extra.priv</span></code></dt><dd><p>driver private data for the <strong>fn</strong> callback</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure should be created on the stack as <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> should be.</p>
<p>Optionally, <strong>extra</strong> can be set in order to lock additional <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_unlock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p>lock all dma-resv of all assoiciated BOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all dma-resv locks of all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> previously acquired
through <a class="reference internal" href="#c.drm_gpuvm_exec_lock" title="drm_gpuvm_exec_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_exec_lock()</span></code></a> or its variants.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_resv_add_fence">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_resv_add_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><span class="n"><span class="pre">dma_resv_usage</span></span></a><span class="w"> </span><span class="n"><span class="pre">private_usage</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><span class="n"><span class="pre">dma_resv_usage</span></span></a><span class="w"> </span><span class="n"><span class="pre">extobj_usage</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_resv_add_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>add fence to private and all extobj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">private_usage</span></code></dt><dd><p>private dma-resv usage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">extobj_usage</span></code></dt><dd><p>extobj dma-resv usage</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.drm_gpuvm_resv_add_fence" title="drm_gpuvm_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_resv_add_fence()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_validate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_validate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_validate" title="Link to this definition">¶</a><br /></dt>
<dd><p>validate all BOs marked as evicted</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.drm_gpuvm_validate" title="drm_gpuvm_validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_validate()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></span><a class="headerlink" href="#c.drm_gpuvm_bo" title="Link to this definition">¶</a><br /></dt>
<dd><p>structure representing a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> combination</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuvm_bo {
    struct drm_gpuvm *vm;
    struct drm_gem_object *obj;
    bool evicted;
    struct kref kref;
    struct {
        struct list_head gpuva;
        struct {
            struct list_head gem;
            struct list_head extobj;
            struct list_head evict;
        } entry;
    } list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> the <strong>obj</strong> is mapped in. This is a reference
counted pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> being mapped in <strong>vm</strong>. This is a reference
counted pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evicted</span></code></dt><dd><p>Indicates whether the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> is evicted; field
protected by the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>’s dma-resv lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>The reference count for this <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Structure containing all <code class="xref c c-type docutils literal notranslate"><span class="pre">list_heads</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list.gpuva</span></code></dt><dd><p>The list of linked <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code>.</p>
<p>It is safe to access entries from this list as long as the
GEM’s gpuva lock is held. See also <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list.entry</span></code></dt><dd><p>Structure containing all <code class="xref c c-type docutils literal notranslate"><span class="pre">list_heads</span></code> serving as
entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list.entry.gem</span></code></dt><dd><p>List entry to attach to the
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> gpuva list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list.entry.evict</span></code></dt><dd><p>List entry to attach to the
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvms</span></code> evict list.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is an abstraction representing a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> combination. It serves as an indirection to accelerate
iterating all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> within a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> backed by the same
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>.</p>
<p>Furthermore it is used cache evicted GEM objects for a certain GPU-VM to
accelerate validation.</p>
<p>Typically, drivers want to create an instance of a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a> once
a GEM object is mapped first in a GPU-VM and release the instance once the
last mapping of the GEM object in this GPU-VM is unmapped.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>acquire a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a> reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to acquire the reference of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires an additional reference to <strong>vm_bo</strong>. It is illegal to
call this without already holding a reference. No locks required.</p>
<p><strong>Return</strong></p>
<p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_bo</span></code> pointer</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_gem_evict">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_gem_evict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">evict</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_gem_evict" title="Link to this definition">¶</a><br /></dt>
<dd><p>add/remove all <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>’s in the list to/from the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvms</span></code> evicted list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evict</span></code></dt><dd><p>indicates whether <strong>obj</strong> is evicted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.drm_gpuvm_bo_evict" title="drm_gpuvm_bo_evict"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_bo_evict()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_for_each_va">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_for_each_va</span></span></span><a class="headerlink" href="#c.drm_gpuvm_bo_for_each_va" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_bo_for_each_va</span> <span class="pre">(va__,</span> <span class="pre">vm_bo__)</span></code></p>
<blockquote>
<div><p>iterator to walk over a list of <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structure to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to walk are associated with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures associated with the
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>.</p>
<p>The caller must hold the GEM’s gpuva lock.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_for_each_va_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_for_each_va_safe</span></span></span><a class="headerlink" href="#c.drm_gpuvm_bo_for_each_va_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuvm_bo_for_each_va_safe</span> <span class="pre">(va__,</span> <span class="pre">next__,</span> <span class="pre">vm_bo__)</span></code></p>
<blockquote>
<div><p>iterator to safely walk over a list of <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va__</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structure to assign to in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next__</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">next</span></code> <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to store the next step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo__</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to walk are associated with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structures associated with the
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>. It is implemented with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_safe" title="list_for_each_entry_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_safe()</span></code></a>, hence
it is save against removal of elements.</p>
<p>The caller must hold the GEM’s gpuva lock.</p>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.drm_gpuva_op_type">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_type</span></span></span><a class="headerlink" href="#c.drm_gpuva_op_type" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA operation type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_OP_MAP</span></code></dt><dd><p>the map op type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_OP_REMAP</span></code></dt><dd><p>the remap op type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_OP_UNMAP</span></code></dt><dd><p>the unmap op type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_GPUVA_OP_PREFETCH</span></code></dt><dd><p>the prefetch op type</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Operations to alter the GPU VA mappings tracked by the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_op_map">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_map</span></span></span><a class="headerlink" href="#c.drm_gpuva_op_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA map operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_op_map {
    struct {
        u64 addr;
        u64 range;
    } va;
    struct {
        u64 offset;
        struct drm_gem_object *obj;
    } gem;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>structure containing address and range of a map
operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va.addr</span></code></dt><dd><p>the base address of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va.range</span></code></dt><dd><p>the range of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem</span></code></dt><dd><p>structure containing the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> and it’s offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem.offset</span></code></dt><dd><p>the offset within the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gem.obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> to map</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single map operation generated by the
DRM GPU VA manager.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_op_unmap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_unmap</span></span></span><a class="headerlink" href="#c.drm_gpuva_op_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA unmap operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_op_unmap {
    struct drm_gpuva *va;
    bool keep;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keep</span></code></dt><dd><p>Indicates whether this <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> is physically contiguous with the
original mapping request.</p>
<p>Optionally, if <code class="xref c c-type docutils literal notranslate"><span class="pre">keep</span></code> is set, drivers may keep the actual page table
mappings for this <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a>, adding the missing page table entries
only and update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> accordingly.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single unmap operation generated by the
DRM GPU VA manager.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_op_remap">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_remap</span></span></span><a class="headerlink" href="#c.drm_gpuva_op_remap" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA remap operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_op_remap {
    struct drm_gpuva_op_map *prev;
    struct drm_gpuva_op_map *next;
    struct drm_gpuva_op_unmap *unmap;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">prev</span></code></dt><dd><p>the preceding part of a split mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>the subsequent part of a split mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap</span></code></dt><dd><p>the unmap operation for the original existing mapping</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This represents a single remap operation generated by the DRM GPU VA manager.</p>
<p>A remap operation is generated when an existing GPU VA mmapping is split up
by inserting a new GPU VA mapping or by partially unmapping existent
mapping(s), hence it consists of a maximum of two map and one unmap
operation.</p>
<p>The <strong>unmap</strong> operation takes care of removing the original existing mapping.
<strong>prev</strong> is used to remap the preceding part, <strong>next</strong> the subsequent part.</p>
<p>If either a new mapping’s start address is aligned with the start address
of the old mapping or the new mapping’s end address is aligned with the
end address of the old mapping, either <strong>prev</strong> or <strong>next</strong> is NULL.</p>
<p>Note, the reason for a dedicated remap operation, rather than arbitrary
unmap and map operations, is to give drivers the chance of extracting driver
specific data for creating the new mappings from the unmap operations’s
<a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> structure which typically is embedded in larger driver specific
structures.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_op_prefetch">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_prefetch</span></span></span><a class="headerlink" href="#c.drm_gpuva_op_prefetch" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA prefetch operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_op_prefetch {
    struct drm_gpuva *va;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to prefetch</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single prefetch operation generated by the
DRM GPU VA manager.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_op">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_op" title="Link to this definition">¶</a><br /></dt>
<dd><p>GPU VA operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_op {
    struct list_head entry;
    enum drm_gpuva_op_type op;
    union {
        struct drm_gpuva_op_map map;
        struct drm_gpuva_op_remap remap;
        struct drm_gpuva_op_unmap unmap;
        struct drm_gpuva_op_prefetch prefetch;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> used to distribute instances of this struct within
<a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>the type of the operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>the map operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remap</span></code></dt><dd><p>the remap operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap</span></code></dt><dd><p>the unmap operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prefetch</span></code></dt><dd><p>the prefetch operation</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a single generic operation.</p>
<p>The particular type of the operation is defined by <strong>op</strong>.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuva_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_ops</span></span></span><a class="headerlink" href="#c.drm_gpuva_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>wraps a list of <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuva_ops {
    struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code></p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_for_each_op">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_for_each_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_for_each_op" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op</span> <span class="pre">(op,</span> <span class="pre">ops)</span></code></p>
<blockquote>
<div><p>iterator to walk over <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to assign in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all ops within a given list of operations.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_for_each_op_safe">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_for_each_op_safe</span></span></span><a class="headerlink" href="#c.drm_gpuva_for_each_op_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op_safe</span> <span class="pre">(op,</span> <span class="pre">next,</span> <span class="pre">ops)</span></code></p>
<blockquote>
<div><p>iterator to safely walk over <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to assign in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">next</span></code> <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to store the next step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all ops within a given list of operations. It is
implemented with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_safe" title="list_for_each_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_safe()</span></code></a>, so save against removal of elements.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_for_each_op_from_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_for_each_op_from_reverse</span></span></span><a class="headerlink" href="#c.drm_gpuva_for_each_op_from_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op_from_reverse</span> <span class="pre">(op,</span> <span class="pre">ops)</span></code></p>
<blockquote>
<div><p>iterate backwards from the given point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to assign in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all ops within a given list of operations beginning
from the given operation in reverse order.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_for_each_op_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_for_each_op_reverse</span></span></span><a class="headerlink" href="#c.drm_gpuva_for_each_op_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op_reverse</span> <span class="pre">(op,</span> <span class="pre">ops)</span></code></p>
<blockquote>
<div><p>iterator to walk over <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> in reverse</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> to assign in each iteration step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to walk</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all ops within a given list of operations in reverse</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_first_op">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_first_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_first_op" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_first_op</span> <span class="pre">(ops)</span></code></p>
<blockquote>
<div><p>returns the first <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> from <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to get the fist <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> from</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_last_op">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_last_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_last_op" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_last_op</span> <span class="pre">(ops)</span></code></p>
<blockquote>
<div><p>returns the last <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> from <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to get the last <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> from</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_prev_op">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_prev_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_prev_op" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_prev_op</span> <span class="pre">(op)</span></code></p>
<blockquote>
<div><p>previous <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> in the list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>the current <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a></p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_gpuva_next_op">
<span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_next_op</span></span></span><a class="headerlink" href="#c.drm_gpuva_next_op" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_gpuva_next_op</span> <span class="pre">(op)</span></code></p>
<blockquote>
<div><p>next <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> in the list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">op</span></code></dt><dd><p>the current <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a></p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpuvm_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_ops</span></span></span><a class="headerlink" href="#c.drm_gpuvm_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>callbacks for split/merge steps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpuvm_ops {
    void (*vm_free)(struct drm_gpuvm *gpuvm);
    struct drm_gpuva_op *(*op_alloc)(void);
    void (*op_free)(struct drm_gpuva_op *op);
    struct drm_gpuvm_bo *(*vm_bo_alloc)(void);
    void (*vm_bo_free)(struct drm_gpuvm_bo *vm_bo);
    int (*vm_bo_validate)(struct drm_gpuvm_bo *vm_bo, struct drm_exec *exec);
    int (*sm_step_map)(struct drm_gpuva_op *op, void *priv);
    int (*sm_step_remap)(struct drm_gpuva_op *op, void *priv);
    int (*sm_step_unmap)(struct drm_gpuva_op *op, void *priv);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm_free</span></code></dt><dd><p>called when the last reference of a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> is
dropped</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_alloc</span></code></dt><dd><p>called when the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> allocates
a <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op</span></code></a></p>
<p>Some drivers may want to embed <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op</span></code></a> into driver
specific structures. By implementing this callback drivers can
allocate memory accordingly.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">op_free</span></code></dt><dd><p>called when the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> frees a
<a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op</span></code></a></p>
<p>Some drivers may want to embed <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op</span></code></a> into driver
specific structures. By implementing this callback drivers can
free the previously allocated memory accordingly.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo_alloc</span></code></dt><dd><p>called when the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> allocates
a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a></p>
<p>Some drivers may want to embed <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a> into driver
specific structures. By implementing this callback drivers can
allocate memory accordingly.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo_free</span></code></dt><dd><p>called when the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> frees a
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a></p>
<p>Some drivers may want to embed <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a> into driver
specific structures. By implementing this callback drivers can
free the previously allocated memory accordingly.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_bo_validate</span></code></dt><dd><p>called from <a class="reference internal" href="#c.drm_gpuvm_validate" title="drm_gpuvm_validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_validate()</span></code></a></p>
<p>Drivers receive this callback for every evicted <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> being
mapped in the corresponding <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
<p>Typically, drivers would call their driver specific variant of
ttm_bo_validate() from within this callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sm_step_map</span></code></dt><dd><p>called from <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> to finally insert the
mapping once all previous steps were completed</p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">priv</span></code> pointer matches the one the driver passed to
<a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> or <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a>, respectively.</p>
<p>Can be NULL if <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sm_step_remap</span></code></dt><dd><p>called from <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> to split up an existent mapping</p>
<p>This callback is called when existent mapping needs to be split up.
This is the case when either a newly requested mapping overlaps or
is enclosed by an existent mapping or a partial unmap of an existent
mapping is requested.</p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">priv</span></code> pointer matches the one the driver passed to
<a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> or <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a>, respectively.</p>
<p>Can be NULL if neither <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> nor <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> is
used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sm_step_unmap</span></code></dt><dd><p>called from <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> to unmap an existent mapping</p>
<p>This callback is called when existent mapping needs to be unmapped.
This is the case when either a newly requested mapping encloses an
existent mapping or an unmap of an existent mapping is requested.</p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">priv</span></code> pointer matches the one the driver passed to
<a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> or <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a>, respectively.</p>
<p>Can be NULL if neither <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> nor <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> is
used.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure defines the callbacks used by <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> to provide the split/merge steps for map and unmap
operations to drivers.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_op_remap_to_unmap_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_op_remap_to_unmap_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_op_remap" title="drm_gpuva_op_remap"><span class="n"><span class="pre">drm_gpuva_op_remap</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start_addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_op_remap_to_unmap_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Helper to get the start and range of the unmap stage of a remap op.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gpuva_op_remap</span> <span class="pre">*op</span></code></dt><dd><p>Remap op.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*start_addr</span></code></dt><dd><p>Output pointer for the start of the required unmap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*range</span></code></dt><dd><p>Output pointer for the length of the required unmap.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The given start address and range will be set such that they represent the
range of the address space that was previously covered by the mapping being
re-mapped, but is now empty.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_range_valid">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_range_valid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_range_valid" title="Link to this definition">¶</a><br /></dt>
<dd><p>checks whether the given range is valid for the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the GPUVM to check the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the base address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the range starting from the base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the range is within the GPUVM’s managed boundaries.</p>
<p><strong>Return</strong></p>
<p>true for a valid range, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_resv_object_alloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_resv_object_alloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_resv_object_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate a dummy <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>the drivers <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a dummy <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> which can be passed to <a class="reference internal" href="#c.drm_gpuvm_init" title="drm_gpuvm_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_init()</span></code></a> in
order to serve as root GEM object providing the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_resv</span></code> shared across
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> local to a single GPUVM.</p>
<p><strong>Return</strong></p>
<p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> on success, NULL on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_flags" title="drm_gpuvm_flags"><span class="n"><span class="pre">drm_gpuvm_flags</span></span></a><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><span class="n"><span class="pre">drm_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">drm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r_obj</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start_offset</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">reserve_offset</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">reserve_range</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><span class="n"><span class="pre">drm_gpuvm_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_gpuvm_flags</span> <span class="pre">flags</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_flags" title="drm_gpuvm_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_flags</span></code></a> for this GPUVM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> this VM resides in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*r_obj</span></code></dt><dd><p>the resv <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> providing the GPUVM’s common <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start_offset</span></code></dt><dd><p>the start offset of the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the size of the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">reserve_offset</span></code></dt><dd><p>the start of the kernel reserved GPU VA area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">reserve_range</span></code></dt><dd><p>the size of the kernel reserved GPU VA area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gpuvm_ops</span> <span class="pre">*ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> called on <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> / <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> must be initialized with this function before use.</p>
<p>Note that <strong>gpuvm</strong> must be cleared to 0 before calling this function. The given
<code class="xref c c-type docutils literal notranslate"><span class="pre">name</span></code> is expected to be managed by the surrounding driver structures.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>drop a <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span></code></a> reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to release the reference of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>gpuvm</strong>.</p>
<p>This function may be called from atomic context.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_prepare_vm">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_prepare_vm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_prepare_vm" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare the GPUVMs common dma-resv</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>the amount of <code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fences</span></code> to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_exec_prepare_obj" title="drm_exec_prepare_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_prepare_obj()</span></code></a> for the GPUVMs dummy <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>; if
<strong>num_fences</strong> is zero <a class="reference internal" href="#c.drm_exec_lock_obj" title="drm_exec_lock_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_lock_obj()</span></code></a> is called instead.</p>
<p>Using this function directly, it is the drivers responsibility to call
<a class="reference internal" href="#c.drm_exec_init" title="drm_exec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_init()</span></code></a> and <a class="reference internal" href="#c.drm_exec_fini" title="drm_exec_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_fini()</span></code></a> accordingly.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_prepare_objects">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_prepare_objects</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_prepare_objects" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare all assoiciated BOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> locking context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>the amount of <code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fences</span></code> to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_exec_prepare_obj" title="drm_exec_prepare_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_prepare_obj()</span></code></a> for all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> contains mappings of; if <strong>num_fences</strong> is zero <a class="reference internal" href="#c.drm_exec_lock_obj" title="drm_exec_lock_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_lock_obj()</span></code></a>
is called instead.</p>
<p>Using this function directly, it is the drivers responsibility to call
<a class="reference internal" href="#c.drm_exec_init" title="drm_exec_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_init()</span></code></a> and <a class="reference internal" href="#c.drm_exec_fini" title="drm_exec_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_fini()</span></code></a> accordingly.</p>
<p>Drivers need to make sure to protect this case with either an outer VM lock
or by calling <a class="reference internal" href="#c.drm_gpuvm_prepare_vm" title="drm_gpuvm_prepare_vm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_prepare_vm()</span></code></a> before this function within the
<a class="reference internal" href="#c.drm_exec_until_all_locked" title="drm_exec_until_all_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_until_all_locked()</span></code></a> loop, such that the GPUVM’s dma-resv lock ensures
mutual exclusion.</p>
<p><strong>Note</strong></p>
<p>This function is safe against concurrent insertion and removal of
external objects, however it is not safe against concurrent usage itself.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_prepare_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_prepare_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_prepare_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare all BOs mapped within a given range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> locking context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the start address within the VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the range to iterate within the VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>the amount of <code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fences</span></code> to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_exec_prepare_obj" title="drm_exec_prepare_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_prepare_obj()</span></code></a> for all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> mapped between <strong>addr</strong>
and <strong>addr</strong> + <strong>range</strong>; if <strong>num_fences</strong> is zero <a class="reference internal" href="#c.drm_exec_lock_obj" title="drm_exec_lock_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_lock_obj()</span></code></a> is called
instead.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_lock">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_lock</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_lock" title="Link to this definition">¶</a><br /></dt>
<dd><p>lock all dma-resv of all assoiciated BOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires all dma-resv locks of all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> contains mappings of.</p>
<p>Addionally, when calling this function with <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span></code></a>::extra
being set the driver receives the given <strong>fn</strong> callback to lock additional
dma-resv in the context of the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> instance. Typically, drivers
would call <a class="reference internal" href="#c.drm_exec_prepare_obj" title="drm_exec_prepare_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_prepare_obj()</span></code></a> from within this callback.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_lock_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_lock_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_objs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_lock_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>lock all dma-resv of all assoiciated BOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">**objs</span></code></dt><dd><p>additional <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> to lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_objs</span></code></dt><dd><p>the number of additional <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> to lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires all dma-resv locks of all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>
contains mappings of, plus the ones given through <strong>objs</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_exec_lock_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_exec_lock_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><span class="n"><span class="pre">drm_gpuvm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_exec</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_exec_lock_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare all BOs mapped within a given range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_exec</span> <span class="pre">*vm_exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_exec" title="drm_gpuvm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_exec</span></code></a> wrapper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the start address within the VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the range to iterate within the VA space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires all dma-resv locks of all <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_objects</span></code> mapped between <strong>addr</strong> and
<strong>addr</strong> + <strong>range</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_validate">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_validate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_validate" title="Link to this definition">¶</a><br /></dt>
<dd><p>validate all BOs marked as evicted</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to validate evicted BOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> instance used for locking the GPUVM</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the <a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a>::vm_bo_validate callback for all evicted buffer
objects being mapped in the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_resv_add_fence">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_resv_add_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><span class="n"><span class="pre">dma_resv_usage</span></span></a><span class="w"> </span><span class="n"><span class="pre">private_usage</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><span class="n"><span class="pre">dma_resv_usage</span></span></a><span class="w"> </span><span class="n"><span class="pre">extobj_usage</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_resv_add_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>add fence to private and all extobj dma-resv</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to add a fence to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_exec" title="drm_exec"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_exec</span></code></a> locking context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">private_usage</span></code></dt><dd><p>private dma-resv usage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">extobj_usage</span></code></dt><dd><p>extobj dma-resv usage</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a new instance of <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> the <strong>obj</strong> is mapped in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> being mapped in the <strong>gpuvm</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If provided by the driver, this function uses the <a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a>
vm_bo_alloc() callback to allocate.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> on success, NULL on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_put">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>drop a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a> reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to release the reference of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>vm_bo</strong>.</p>
<p>If the reference count drops to zero, the <code class="xref c c-type docutils literal notranslate"><span class="pre">gpuvm_bo</span></code> is destroyed, which
includes removing it from the GEMs gpuva list. Hence, if a call to this
function can potentially let the reference count drop to zero the caller must
hold the dma-resv or driver specific GEM gpuva lock.</p>
<p>This function may only be called from non-atomic context.</p>
<p><strong>Return</strong></p>
<p>true if vm_bo was destroyed, false otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_find">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> for the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> the <strong>obj</strong> is mapped in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> being mapped in the <strong>gpuvm</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> representing the combination of the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. If found, increases the reference
count of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> accordingly.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> on success, NULL on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_obtain">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_obtain</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_obtain" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtains and instance of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> for the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> the <strong>obj</strong> is mapped in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> being mapped in the <strong>gpuvm</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> representing the combination of the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. If found, increases the reference
count of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> accordingly. If not found, allocates a new
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>.</p>
<p>A new <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> is added to the GEMs gpuva list.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> on success, an ERR_PTR on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_obtain_prealloc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_obtain_prealloc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">__vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_obtain_prealloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>obtains and instance of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> for the given <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*__vm_bo</span></code></dt><dd><p>A pre-allocated <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> representing the combination of the given
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> and <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a>. If found, increases the reference
count of the found <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> accordingly, while the <strong>__vm_bo</strong> reference
count is decreased. If not found <strong>__vm_bo</strong> is returned without further
increase of the reference count.</p>
<p>A new <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> is added to the GEMs gpuva list.</p>
<p><strong>Return</strong></p>
<p>a pointer to the found <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> or <strong>__vm_bo</strong> if no existing
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> was found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_extobj_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_extobj_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_extobj_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to its <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s extobj list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to add to its <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s the extobj list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the given <strong>vm_bo</strong> to its <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s extobj list if not on the list
already and if the corresponding <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> is an external object,
actually.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_evict">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_evict</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">evict</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_evict" title="Link to this definition">¶</a><br /></dt>
<dd><p>add / remove a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to / from the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvms</span></code> evicted list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to add or remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evict</span></code></dt><dd><p>indicates whether the object is evicted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to or removes it from the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvms</span></code> evicted list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_insert">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_insert</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>insert a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to insert the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> with a given address and range into a
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>.</p>
<p>It is safe to use this function using the safe versions of iterating the GPU
VA space, such as <a class="reference internal" href="#c.drm_gpuvm_for_each_va_safe" title="drm_gpuvm_for_each_va_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_safe()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_for_each_va_range_safe" title="drm_gpuvm_for_each_va_range_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_range_safe()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_remove">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_remove</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>remove a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This removes the given <code class="xref c c-type docutils literal notranslate"><span class="pre">va</span></code> from the underlaying tree.</p>
<p>It is safe to use this function using the safe versions of iterating the GPU
VA space, such as <a class="reference internal" href="#c.drm_gpuvm_for_each_va_safe" title="drm_gpuvm_for_each_va_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_safe()</span></code></a> and
<a class="reference internal" href="#c.drm_gpuvm_for_each_va_range_safe" title="drm_gpuvm_for_each_va_range_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuvm_for_each_va_range_safe()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_link">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_link</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_link" title="Link to this definition">¶</a><br /></dt>
<dd><p>link a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to add the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the given <code class="xref c c-type docutils literal notranslate"><span class="pre">va</span></code> to the GPU VA list of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> and the
<a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> to the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> it is associated with.</p>
<p>For every <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> entry added to the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> an additional
reference of the latter is taken.</p>
<p>This function expects the caller to protect the GEM’s GPUVA list against
concurrent access using either the GEMs dma_resv lock or a driver specific
lock set through <a class="reference internal" href="#c.drm_gem_gpuva_set_lock" title="drm_gem_gpuva_set_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_gpuva_set_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_unlink">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_unlink</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_unlink" title="Link to this definition">¶</a><br /></dt>
<dd><p>unlink a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to unlink</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This removes the given <code class="xref c c-type docutils literal notranslate"><span class="pre">va</span></code> from the GPU VA list of the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> it is
associated with.</p>
<p>This removes the given <code class="xref c c-type docutils literal notranslate"><span class="pre">va</span></code> from the GPU VA list of the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> and
the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> from the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> it is associated with in case
this call unlinks the last <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> from the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a>.</p>
<p>For every <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> entry removed from the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> a reference of
the latter is dropped.</p>
<p>This function expects the caller to protect the GEM’s GPUVA list against
concurrent access using either the GEMs dma_resv lock or a driver specific
lock set through <a class="reference internal" href="#c.drm_gem_gpuva_set_lock" title="drm_gem_gpuva_set_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_gpuva_set_lock()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_find_first">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_find_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_find_first" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the first <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> in the given range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the first <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> within the given range</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_find">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvas</span></code> range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> at a given <code class="xref c c-type docutils literal notranslate"><span class="pre">addr</span></code> and with a given <code class="xref c c-type docutils literal notranslate"><span class="pre">range</span></code></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_find_prev">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_find_prev</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_find_prev" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> before the given address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>the given GPU VA’s start address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the adjacent <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> before the GPU VA with given <a class="reference internal" href="../networking/ieee802154.html#c.start" title="start"><code class="xref c c-type docutils literal notranslate"><span class="pre">start</span></code></a> address.</p>
<p>Note that if there is any free space between the GPU VA mappings no mapping
is returned.</p>
<p><strong>Return</strong></p>
<p>a pointer to the found <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> or NULL if none was found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_find_next">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_find_next</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_find_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>find the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> after the given address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>the given GPU VA’s end address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the adjacent <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> after the GPU VA with given <code class="xref c c-type docutils literal notranslate"><span class="pre">end</span></code> address.</p>
<p>Note that if there is any free space between the GPU VA mappings no mapping
is returned.</p>
<p><strong>Return</strong></p>
<p>a pointer to the found <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> or NULL if none was found</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_interval_empty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_interval_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_interval_empty" title="Link to this definition">¶</a><br /></dt>
<dd><p>indicate whether a given interval of the VA space is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> to check the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the start address of the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the range of the interval</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the interval is empty, false otherwise</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_map">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_map</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">va</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_op_map" title="drm_gpuva_op_map"><span class="n"><span class="pre">drm_gpuva_op_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to insert a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> according to a <a class="reference internal" href="#c.drm_gpuva_op_map" title="drm_gpuva_op_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_map</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*va</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op_map</span> <span class="pre">*op</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_op_map" title="drm_gpuva_op_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_map</span></code></a> to initialize <strong>va</strong> with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the <strong>va</strong> from the <strong>op</strong> and inserts it into the given <strong>gpuvm</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_remap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_remap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><span class="n"><span class="pre">drm_gpuva</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_op_remap" title="drm_gpuva_op_remap"><span class="n"><span class="pre">drm_gpuva_op_remap</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_remap" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to remap a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> according to a <a class="reference internal" href="#c.drm_gpuva_op_remap" title="drm_gpuva_op_remap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_remap</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*prev</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to remap when keeping the start of a mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva</span> <span class="pre">*next</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to remap when keeping the end of a mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op_remap</span> <span class="pre">*op</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_op_remap" title="drm_gpuva_op_remap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_remap</span></code></a> to initialize <strong>prev</strong> and <strong>next</strong> with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the currently mapped <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> and remaps it using <strong>prev</strong> and/or
<strong>next</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_unmap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_unmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_op_unmap" title="drm_gpuva_op_unmap"><span class="n"><span class="pre">drm_gpuva_op_unmap</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to remove a <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> according to a <a class="reference internal" href="#c.drm_gpuva_op_unmap" title="drm_gpuva_op_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_unmap</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_op_unmap</span> <span class="pre">*op</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_op_unmap" title="drm_gpuva_op_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_unmap</span></code></a> specifying the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the <a class="reference internal" href="#c.drm_gpuva" title="drm_gpuva"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva</span></code></a> associated with the <a class="reference internal" href="#c.drm_gpuva_op_unmap" title="drm_gpuva_op_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op_unmap</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_sm_map">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_sm_map</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_range</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req_obj</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_sm_map" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_op" title="drm_gpuva_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_op</span></code></a> split/merge steps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> representing the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>pointer to a driver private data structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_addr</span></code></dt><dd><p>the start address of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_range</span></code></dt><dd><p>the range of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*req_obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_offset</span></code></dt><dd><p>the offset within the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates the given range of the GPU VA space. It utilizes the
<a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> to call back into the driver providing the split and merge
steps.</p>
<p>Drivers may use these callbacks to update the GPU VA space right away within
the callback. In case the driver decides to copy and store the operations for
later processing neither this function nor <a class="reference internal" href="#c.drm_gpuvm_sm_unmap" title="drm_gpuvm_sm_unmap"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_unmap</span></code></a> is allowed to
be called before the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space was
updated with the previous set of operations. To update the
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space <a class="reference internal" href="#c.drm_gpuva_insert" title="drm_gpuva_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_insert()</span></code></a>,
drm_gpuva_destroy_locked() and/or drm_gpuva_destroy_unlocked() should be
used.</p>
<p>A sequence of callbacks can contain map, unmap and remap operations, but
the sequence of callbacks might also be empty if no operation is required,
e.g. if the requested mapping already exists in the exact same way.</p>
<p>There can be an arbitrary amount of unmap operations, a maximum of two remap
operations and a single map operation. The latter one represents the original
map operation requested by the caller.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_sm_unmap">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_sm_unmap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">priv</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_sm_unmap" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to split on unmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> representing the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>pointer to a driver private data structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_addr</span></code></dt><dd><p>the start address of the range to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_range</span></code></dt><dd><p>the range of the mappings to unmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates the given range of the GPU VA space. It utilizes the
<a class="reference internal" href="#c.drm_gpuvm_ops" title="drm_gpuvm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_ops</span></code></a> to call back into the driver providing the operations to
unmap and, if required, split existent mappings.</p>
<p>Drivers may use these callbacks to update the GPU VA space right away within
the callback. In case the driver decides to copy and store the operations for
later processing neither this function nor <a class="reference internal" href="#c.drm_gpuvm_sm_map" title="drm_gpuvm_sm_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_sm_map</span></code></a> is allowed to be
called before the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space was updated
with the previous set of operations. To update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view
of the GPU VA space <a class="reference internal" href="#c.drm_gpuva_insert" title="drm_gpuva_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_insert()</span></code></a>, drm_gpuva_destroy_locked() and/or
drm_gpuva_destroy_unlocked() should be used.</p>
<p>A sequence of callbacks can contain unmap and remap operations, depending on
whether there are actual overlapping mappings to split.</p>
<p>There can be an arbitrary amount of unmap operations and a maximum of two
remap operations.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_sm_map_ops_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><span class="n"><span class="pre">drm_gpuva_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_sm_map_ops_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_range</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">req_obj</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_offset</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_sm_map_ops_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to split and merge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> representing the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_addr</span></code></dt><dd><p>the start address of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_range</span></code></dt><dd><p>the range of the new mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*req_obj</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_offset</span></code></dt><dd><p>the offset within the <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a list of operations to perform splitting and merging
of existent mapping(s) with the newly requested one.</p>
<p>The list can be iterated with <a class="reference internal" href="#c.drm_gpuva_for_each_op" title="drm_gpuva_for_each_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op</span></code></a> and must be processed
in the given order. It can contain map, unmap and remap operations, but it
also can be empty if no operation is required, e.g. if the requested mapping
already exists is the exact same way.</p>
<p>There can be an arbitrary amount of unmap operations, a maximum of two remap
operations and a single map operation. The latter one represents the original
map operation requested by the caller.</p>
<p>Note that before calling this function again with another mapping request it
is necessary to update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space. The
previously obtained operations must be either processed or abandoned. To
update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space <a class="reference internal" href="#c.drm_gpuva_insert" title="drm_gpuva_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_insert()</span></code></a>,
drm_gpuva_destroy_locked() and/or drm_gpuva_destroy_unlocked() should be
used.</p>
<p>After the caller finished processing the returned <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>, they must
be freed with <a class="reference internal" href="#c.drm_gpuva_ops_free" title="drm_gpuva_ops_free"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops_free</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> on success, an ERR_PTR on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_sm_unmap_ops_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><span class="n"><span class="pre">drm_gpuva_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_sm_unmap_ops_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">req_range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_sm_unmap_ops_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to split on unmap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> representing the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_addr</span></code></dt><dd><p>the start address of the range to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">req_range</span></code></dt><dd><p>the range of the mappings to unmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a list of operations to perform unmapping and, if
required, splitting of the mappings overlapping the unmap range.</p>
<p>The list can be iterated with <a class="reference internal" href="#c.drm_gpuva_for_each_op" title="drm_gpuva_for_each_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op</span></code></a> and must be processed
in the given order. It can contain unmap and remap operations, depending on
whether there are actual overlapping mappings to split.</p>
<p>There can be an arbitrary amount of unmap operations and a maximum of two
remap operations.</p>
<p>Note that before calling this function again with another range to unmap it
is necessary to update the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space. The
previously obtained operations must be processed or abandoned. To update the
<a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a>’s view of the GPU VA space <a class="reference internal" href="#c.drm_gpuva_insert" title="drm_gpuva_insert"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gpuva_insert()</span></code></a>,
drm_gpuva_destroy_locked() and/or drm_gpuva_destroy_unlocked() should be
used.</p>
<p>After the caller finished processing the returned <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>, they must
be freed with <a class="reference internal" href="#c.drm_gpuva_ops_free" title="drm_gpuva_ops_free"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops_free</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> on success, an ERR_PTR on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_prefetch_ops_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><span class="n"><span class="pre">drm_gpuva_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_prefetch_ops_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">addr</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_prefetch_ops_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to prefetch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> representing the GPU VA space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">addr</span></code></dt><dd><p>the start address of the range to prefetch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range</span></code></dt><dd><p>the range of the mappings to prefetch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a list of operations to perform prefetching.</p>
<p>The list can be iterated with <a class="reference internal" href="#c.drm_gpuva_for_each_op" title="drm_gpuva_for_each_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op</span></code></a> and must be processed
in the given order. It can contain prefetch operations.</p>
<p>There can be an arbitrary amount of prefetch operations.</p>
<p>After the caller finished processing the returned <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>, they must
be freed with <a class="reference internal" href="#c.drm_gpuva_ops_free" title="drm_gpuva_ops_free"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops_free</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> on success, an ERR_PTR on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuvm_bo_unmap_ops_create">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><span class="n"><span class="pre">drm_gpuva_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuvm_bo_unmap_ops_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><span class="n"><span class="pre">drm_gpuvm_bo</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vm_bo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuvm_bo_unmap_ops_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>creates the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to unmap a GEM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm_bo</span> <span class="pre">*vm_bo</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm_bo" title="drm_gpuvm_bo"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm_bo</span></code></a> abstraction</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a list of operations to perform unmapping for every
GPUVA attached to a GEM.</p>
<p>The list can be iterated with <a class="reference internal" href="#c.drm_gpuva_for_each_op" title="drm_gpuva_for_each_op"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_for_each_op</span></code></a> and consists out of an
arbitrary amount of unmap operations.</p>
<p>After the caller finished processing the returned <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a>, they must
be freed with <a class="reference internal" href="#c.drm_gpuva_ops_free" title="drm_gpuva_ops_free"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops_free</span></code></a>.</p>
<p>It is the callers responsibility to protect the GEMs GPUVA list against
concurrent access using the GEMs dma_resv lock.</p>
<p><strong>Return</strong></p>
<p>a pointer to the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> on success, an ERR_PTR on failure</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_gpuva_ops_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpuva_ops_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><span class="n"><span class="pre">drm_gpuvm</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">gpuvm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><span class="n"><span class="pre">drm_gpuva_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gpuva_ops_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free the given <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuvm</span> <span class="pre">*gpuvm</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuvm" title="drm_gpuvm"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuvm</span></code></a> the ops were created for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpuva_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the given <a class="reference internal" href="#c.drm_gpuva_ops" title="drm_gpuva_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpuva_ops</span></code></a> structure including all the ops associated
with it.</p>
</div>
</section>
</section>
<section id="drm-buddy-allocator">
<h2>DRM Buddy Allocator<a class="headerlink" href="#drm-buddy-allocator" title="Link to this heading">¶</a></h2>
<section id="drm-buddy-function-references">
<h3>DRM Buddy Function References<a class="headerlink" href="#drm-buddy-function-references" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">chunk_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>init memory manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size in bytes to manage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">chunk_size</span></code></dt><dd><p>minimum page size in bytes for our allocations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the memory manager and its resources.</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>tear down the memory manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup memory manager resources and the freelist</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_get_buddy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_get_buddy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_buddy" title="Link to this definition">¶</a><br /></dt>
<dd><p>get buddy address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy_block</span> <span class="pre">*block</span></code></dt><dd><p>DRM buddy block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the corresponding buddy block for <strong>block</strong>, or NULL
if this is a root block and can’t be merged further.
Requires some kind of locking to protect against
any concurrent allocate and free operations.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_free_block">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_free_block</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">block</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_free_block" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy_block</span> <span class="pre">*block</span></code></dt><dd><p>block to be freed</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_free_list">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_free_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objects</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_free_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>free blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*objects</span></code></dt><dd><p>input list head to free blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>optional flags like DRM_BUDDY_CLEARED</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_block_trim">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_block_trim</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">blocks</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_block_trim" title="Link to this definition">¶</a><br /></dt>
<dd><p>free unused pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*start</span></code></dt><dd><p>start address to begin the trimming.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">new_size</span></code></dt><dd><p>original size requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*blocks</span></code></dt><dd><p>Input and output list of allocated blocks.
MUST contain single block as input to be trimmed.
On success will contain the newly allocated blocks
making up the <strong>new_size</strong>. Blocks always appear in
ascending order</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For contiguous allocation, we round up the size to the nearest
power of two value, drivers consume <em>actual</em> size, so remaining
portions are unused and can be optionally freed with this function</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_alloc_blocks">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_alloc_blocks</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">end</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">min_block_size</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">blocks</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_alloc_blocks" title="Link to this definition">¶</a><br /></dt>
<dd><p>allocate power-of-two blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager to allocate from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">start</span></code></dt><dd><p>start of the allowed range for this block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">end</span></code></dt><dd><p>end of the allowed range for this block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>size of the allocation in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">min_block_size</span></code></dt><dd><p>alignment of the allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*blocks</span></code></dt><dd><p>output list head to add allocated blocks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>DRM_BUDDY_*_ALLOCATION flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>alloc_range_bias() called on range limitations, which traverses
the tree and returns the desired block.</p>
<p>alloc_from_freelist() called when <em>no</em> range restrictions
are enforced, which picks the block from the freelist.</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_block_print">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_block_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy_block</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">block</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_block_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>print block information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy_block</span> <span class="pre">*block</span></code></dt><dd><p>DRM buddy block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer to use</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_buddy_print">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_buddy_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">drm_buddy</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mm</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer"><span class="n"><span class="pre">drm_printer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_buddy_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>print allocator state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_buddy</span> <span class="pre">*mm</span></code></dt><dd><p>DRM buddy manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*p</span></code></dt><dd><p>DRM printer to use</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="drm-cache-handling-and-fast-wc-memcpy">
<h2>DRM Cache Handling and Fast WC memcpy()<a class="headerlink" href="#drm-cache-handling-and-fast-wc-memcpy" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_clflush_pages">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_clflush_pages</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">page</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pages</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">num_pages</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_pages" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flush dcache lines of a set of pages.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*pages[]</span></code></dt><dd><p>List of pages to be flushed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num_pages</span></code></dt><dd><p>Number of pages in the array.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address belonging
to a page in the array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_clflush_sg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_clflush_sg</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">sg_table</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">st</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_sg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flush dcache lines pointing to a scather-gather.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*st</span></code></dt><dd><p>struct sg_table.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address in the
sg.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_clflush_virt_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_clflush_virt_range</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">addr</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">length</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_virt_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flush dcache lines of a region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt><dd><p>Initial kernel memory address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">length</span></code></dt><dd><p>Region size.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address in the
region requested.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_memcpy_from_wc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_memcpy_from_wc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dst</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><span class="n"><span class="pre">iosys_map</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">src</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_memcpy_from_wc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform the fastest available memcpy from a source that may be WC.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>The destination pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>The source pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>The size of the area o transfer in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries an arch optimized memcpy for prefetching reading out of a WC region,
and if no such beast is available, falls back to a normal memcpy.</p>
</div>
</section>
<section id="drm-sync-objects">
<span id="id4"></span><h2>DRM Sync Objects<a class="headerlink" href="#drm-sync-objects" title="Link to this heading">¶</a></h2>
<p>DRM synchronisation objects (syncobj, see struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a>) provide a
container for a synchronization primitive which can be used by userspace
to explicitly synchronize GPU commands, can be shared between userspace
processes, and can be shared between different DRM drivers.
Their primary use-case is to implement Vulkan fences and semaphores.
The syncobj userspace API provides ioctls for several operations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Creation and destruction of syncobjs</p></li>
<li><p>Import and export of syncobjs to/from a syncobj file descriptor</p></li>
<li><p>Import and export a syncobj’s underlying fence to/from a sync file</p></li>
<li><p>Reset a syncobj (set its fence to NULL)</p></li>
<li><p>Signal a syncobj (set a trivially signaled fence)</p></li>
<li><p>Wait for a syncobj’s fence to appear and be signaled</p></li>
</ul>
</div></blockquote>
<p>The syncobj userspace API also provides operations to manipulate a syncobj
in terms of a timeline of struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_chain</span></code></a> rather than a single
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>, through the following operations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Signal a given point on the timeline</p></li>
<li><p>Wait for a given point to appear and/or be signaled</p></li>
<li><p>Import and export from/to a given point of a timeline</p></li>
</ul>
</div></blockquote>
<p>At it’s core, a syncobj is simply a wrapper around a pointer to a struct
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> which may be NULL.
When a syncobj is first created, its pointer is either NULL or a pointer
to an already signaled fence depending on whether the
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_CREATE_SIGNALED</span></code> flag is passed to
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_CREATE</span></code>.</p>
<p>If the syncobj is considered as a binary (its state is either signaled or
unsignaled) primitive, when GPU work is enqueued in a DRM driver to signal
the syncobj, the syncobj’s fence is replaced with a fence which will be
signaled by the completion of that work.
If the syncobj is considered as a timeline primitive, when GPU work is
enqueued in a DRM driver to signal the a given point of the syncobj, a new
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_chain</span></code></a> pointing to the DRM driver’s fence and also
pointing to the previous fence that was in the syncobj. The new struct
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_chain</span></code></a> fence replace the syncobj’s fence and will be signaled by
completion of the DRM driver’s work and also any work associated with the
fence previously in the syncobj.</p>
<p>When GPU work which waits on a syncobj is enqueued in a DRM driver, at the
time the work is enqueued, it waits on the syncobj’s fence before
submitting the work to hardware. That fence is either :</p>
<blockquote>
<div><ul class="simple">
<li><p>The syncobj’s current fence if the syncobj is considered as a binary
primitive.</p></li>
<li><p>The struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> associated with a given point if the syncobj is
considered as a timeline primitive.</p></li>
</ul>
</div></blockquote>
<p>If the syncobj’s fence is NULL or not present in the syncobj’s timeline,
the enqueue operation is expected to fail.</p>
<p>With binary syncobj, all manipulation of the syncobjs’s fence happens in
terms of the current fence at the time the ioctl is called by userspace
regardless of whether that operation is an immediate host-side operation
(signal or reset) or or an operation which is enqueued in some driver
queue. <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_RESET</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_SIGNAL</span></code> can be used
to manipulate a syncobj from the host by resetting its pointer to NULL or
setting its pointer to a fence which is already signaled.</p>
<p>With a timeline syncobj, all manipulation of the synobj’s fence happens in
terms of a u64 value referring to point in the timeline. See
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain_find_seqno" title="dma_fence_chain_find_seqno"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_chain_find_seqno()</span></code></a> to see how a given point is found in the
timeline.</p>
<p>Note that applications should be careful to always use timeline set of
ioctl() when dealing with syncobj considered as timeline. Using a binary
set of ioctl() with a syncobj considered as timeline could result incorrect
synchronization. The use of binary syncobj is supported through the
timeline set of ioctl() by using a point value of 0, this will reproduce
the behavior of the binary set of ioctl() (for example replace the
syncobj’s fence when signaling).</p>
<section id="host-side-wait-on-syncobjs">
<h3>Host-side wait on syncobjs<a class="headerlink" href="#host-side-wait-on-syncobjs" title="Link to this heading">¶</a></h3>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_WAIT</span></code> takes an array of syncobj handles and does a
host-side wait on all of the syncobj fences simultaneously.
If <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL</span></code> is set, the wait ioctl will wait on
all of the syncobj fences to be signaled before it returns.
Otherwise, it returns once at least one syncobj fence has been signaled
and the index of a signaled fence is written back to the client.</p>
<p>Unlike the enqueued GPU work dependencies which fail if they see a NULL
fence in a syncobj, if <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT</span></code> is set,
the host-side wait will first wait for the syncobj to receive a non-NULL
fence and then wait on that fence.
If <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT</span></code> is not set and any one of the
syncobjs in the array has a NULL fence, -EINVAL will be returned.
Assuming the syncobj starts off with a NULL fence, this allows a client
to do a host wait in one thread (or process) which waits on GPU work
submitted in another thread (or process) without having to manually
synchronize between the two.
This requirement is inherited from the Vulkan fence API.</p>
<p>If <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_WAIT_FLAGS_WAIT_DEADLINE</span></code> is set, the ioctl will also set
a fence deadline hint on the backing fences before waiting, to provide the
fence signaler with an appropriate sense of urgency.  The deadline is
specified as an absolute <code class="xref c c-type docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC</span></code> value in units of ns.</p>
<p>Similarly, <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT</span></code> takes an array of syncobj
handles as well as an array of u64 points and does a host-side wait on all
of syncobj fences at the given points simultaneously.</p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT</span></code> also adds the ability to wait for a given
fence to materialize on the timeline without waiting for the fence to be
signaled by using the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE</span></code> flag. This
requirement is inherited from the wait-before-signal behavior required by
the Vulkan timeline semaphore API.</p>
<p>Alternatively, <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_EVENTFD</span></code> can be used to wait without
blocking: an eventfd will be signaled when the syncobj is. This is useful to
integrate the wait in an event loop.</p>
</section>
<section id="import-export-of-syncobjs">
<h3>Import/export of syncobjs<a class="headerlink" href="#import-export-of-syncobjs" title="Link to this heading">¶</a></h3>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD</span></code>
provide two mechanisms for import/export of syncobjs.</p>
<p>The first lets the client import or export an entire syncobj to a file
descriptor.
These fd’s are opaque and have no other use case, except passing the
syncobj between processes.
All exported file descriptors and any syncobj handles created as a
result of importing those file descriptors own a reference to the
same underlying struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a> and the syncobj can be used
persistently across all the processes with which it is shared.
The syncobj is freed only once the last reference is dropped.
Unlike dma-buf, importing a syncobj creates a new handle (with its own
reference) for every import instead of de-duplicating.
The primary use-case of this persistent import/export is for shared
Vulkan fences and semaphores.</p>
<p>The second import/export mechanism, which is indicated by
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE</span></code> or
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE</span></code> lets the client
import/export the syncobj’s current fence from/to a <a class="reference internal" href="../driver-api/dma-buf.html#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>.
When a syncobj is exported to a sync file, that sync file wraps the
sycnobj’s fence at the time of export and any later signal or reset
operations on the syncobj will not affect the exported sync file.
When a sync file is imported into a syncobj, the syncobj’s fence is set
to the fence wrapped by that sync file.
Because sync files are immutable, resetting or signaling the syncobj
will not affect any sync files whose fences have been imported into the
syncobj.</p>
</section>
<section id="import-export-of-timeline-points-in-timeline-syncobjs">
<h3>Import/export of timeline points in timeline syncobjs<a class="headerlink" href="#import-export-of-timeline-points-in-timeline-syncobjs" title="Link to this heading">¶</a></h3>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_SYNCOBJ_TRANSFER</span></code> provides a mechanism to transfer a struct
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_chain</span></code></a> of a syncobj at a given u64 point to another u64 point
into another syncobj.</p>
<p>Note that if you want to transfer a struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_chain</span></code></a> from a given
point on a timeline syncobj from/into a binary syncobj, you can use the
point 0 to mean take/replace the fence in the syncobj.</p>
</section>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_syncobj">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj</span></span></span><a class="headerlink" href="#c.drm_syncobj" title="Link to this definition">¶</a><br /></dt>
<dd><p>sync object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_syncobj {
    struct kref refcount;
    struct dma_fence __rcu *fence;
    struct list_head cb_list;
    struct list_head ev_fd_list;
    spinlock_t lock;
    struct file *file;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>Reference count of this object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>NULL or a pointer to the fence bound to this object.</p>
<p>This field should not be used directly. Use <a class="reference internal" href="#c.drm_syncobj_fence_get" title="drm_syncobj_fence_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_fence_get()</span></code></a>
and <a class="reference internal" href="#c.drm_syncobj_replace_fence" title="drm_syncobj_replace_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_replace_fence()</span></code></a> instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb_list</span></code></dt><dd><p>List of callbacks to call when the <code class="xref c c-type docutils literal notranslate"><span class="pre">fence</span></code> gets replaced.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ev_fd_list</span></code></dt><dd><p>List of registered eventfd.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Protects <code class="xref c c-type docutils literal notranslate"><span class="pre">cb_list</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">ev_fd_list</span></code>, and write-locks <code class="xref c c-type docutils literal notranslate"><span class="pre">fence</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>A file backing for this syncobj.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure defines a generic sync object which wraps a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>acquire a syncobj reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*obj</span></code></dt><dd><p>sync object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This acquires an additional reference to <strong>obj</strong>. It is illegal to call this
without already holding a reference. No locks required.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_put">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_put</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_put" title="Link to this definition">¶</a><br /></dt>
<dd><p>release a reference to a sync object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*obj</span></code></dt><dd><p>sync object.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_fence_get">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_fence_get</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">syncobj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_fence_get" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a reference to a fence in a sync object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*syncobj</span></code></dt><dd><p>sync object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This acquires additional reference to <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj.fence</span></code></a> contained in <strong>obj</strong>,
if not NULL. It is illegal to call this without already holding a reference.
No locks required.</p>
<p><strong>Return</strong></p>
<p>Either the fence of <strong>obj</strong> or NULL if there’s none.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_find">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_find</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_private</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_find" title="Link to this definition">¶</a><br /></dt>
<dd><p>lookup and reference a sync object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_private</span></code></dt><dd><p>drm file private pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>sync object handle to lookup.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the syncobj pointed to by handle or NULL. The
reference must be released by calling <a class="reference internal" href="#c.drm_syncobj_put" title="drm_syncobj_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_add_point">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_add_point</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">syncobj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_chain" title="dma_fence_chain"><span class="n"><span class="pre">dma_fence_chain</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">chain</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span>, <span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="n"><span class="pre">point</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_add_point" title="Link to this definition">¶</a><br /></dt>
<dd><p>add new timeline point to the syncobj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*syncobj</span></code></dt><dd><p>sync object to add timeline point do</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span> <span class="pre">*chain</span></code></dt><dd><p>chain node to use to add the point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to encapsulate in the chain node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">point</span></code></dt><dd><p>sequence number to use for the point</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the chain node as new timeline point to the syncobj.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_replace_fence">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_replace_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">syncobj</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_replace_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace fence in a sync object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*syncobj</span></code></dt><dd><p>Sync object to replace fence in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to install in sync file.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This replaces the fence on a sync object.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_find_fence">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_find_fence</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_private</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">point</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_find_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>lookup and reference the fence in a sync object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_private</span></code></dt><dd><p>drm file private pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>sync object handle to lookup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">point</span></code></dt><dd><p>timeline point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">flags</span></code></dt><dd><p>DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence</span></code></dt><dd><p>out parameter for the fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just a convenience function that combines <a class="reference internal" href="#c.drm_syncobj_find" title="drm_syncobj_find"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_find()</span></code></a> and
<a class="reference internal" href="#c.drm_syncobj_fence_get" title="drm_syncobj_fence_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_fence_get()</span></code></a>.</p>
<p>Returns 0 on success or a negative error value on failure. On success <strong>fence</strong>
contains a reference to the fence, which must be released by calling
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_free</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj_free" title="kref"><span class="n"><span class="pre">kref</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">kref</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>free a sync object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p>kref to free.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only to be called from kref_put in drm_syncobj_put.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out_syncobj</span></span>, <span class="n"><span class="pre">uint32_t</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_create" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a new syncobj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">**out_syncobj</span></code></dt><dd><p>returned syncobj</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>DRM_SYNCOBJ_* flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>if non-NULL, the syncobj will represent this fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first function to create a sync object. After creating, drivers
probably want to make it available to userspace, either through
<a class="reference internal" href="#c.drm_syncobj_get_handle" title="drm_syncobj_get_handle"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_get_handle()</span></code></a> or <a class="reference internal" href="#c.drm_syncobj_get_fd" title="drm_syncobj_get_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_get_fd()</span></code></a>.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_get_handle">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_get_handle</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_private</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">syncobj</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">handle</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get_handle" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a handle from a syncobj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_private</span></code></dt><dd><p>drm file private pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*syncobj</span></code></dt><dd><p>Sync object to export</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*handle</span></code></dt><dd><p>out parameter with the new handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports a sync object created with <a class="reference internal" href="#c.drm_syncobj_create" title="drm_syncobj_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_create()</span></code></a> as a handle on
<strong>file_private</strong> to userspace.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_syncobj_get_fd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_syncobj_get_fd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><span class="n"><span class="pre">drm_syncobj</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">syncobj</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p_fd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get_fd" title="Link to this definition">¶</a><br /></dt>
<dd><p>get a file descriptor from a syncobj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*syncobj</span></code></dt><dd><p>Sync object to export</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*p_fd</span></code></dt><dd><p>out parameter with the new file descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports a sync object created with <a class="reference internal" href="#c.drm_syncobj_create" title="drm_syncobj_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_syncobj_create()</span></code></a> as a file descriptor.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_timeout_abs_to_jiffies">
<span class="kt"><span class="pre">signed</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_timeout_abs_to_jiffies</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="n"><span class="pre">timeout_nsec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_timeout_abs_to_jiffies" title="Link to this definition">¶</a><br /></dt>
<dd><p>calculate jiffies timeout from absolute value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">timeout_nsec</span></code></dt><dd><p>timeout nsec component in ns, 0 for poll</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the timeout in jiffies from an absolute time in sec/nsec.</p>
</div>
</section>
<section id="drm-execution-context">
<h2>DRM Execution context<a class="headerlink" href="#drm-execution-context" title="Link to this heading">¶</a></h2>
<p>This component mainly abstracts the retry loop necessary for locking
multiple GEM objects while preparing hardware operations (e.g. command
submissions, page table updates etc..).</p>
<p>If a contention is detected while locking a GEM object the cleanup procedure
unlocks all previously locked GEM objects and locks the contended one first
before locking any further objects.</p>
<p>After an object is locked fences slots can optionally be reserved on the
dma_resv object inside the GEM object.</p>
<p>A typical usage pattern should look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gem_object *obj;
struct drm_exec exec;
unsigned long index;
int ret;

drm_exec_init(&amp;exec, DRM_EXEC_INTERRUPTIBLE_WAIT);
drm_exec_until_all_locked(&amp;exec) {
        ret = drm_exec_prepare_obj(&amp;exec, boA, 1);
        drm_exec_retry_on_contention(&amp;exec);
        if (ret)
                goto error;

        ret = drm_exec_prepare_obj(&amp;exec, boB, 1);
        drm_exec_retry_on_contention(&amp;exec);
        if (ret)
                goto error;
}

drm_exec_for_each_locked_object(&amp;exec, index, obj) {
        dma_resv_add_fence(obj-&gt;resv, fence, DMA_RESV_USAGE_READ);
        ...
}
drm_exec_fini(&amp;exec);
</pre></div>
</div>
<p>See struct dma_exec for more details.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_exec">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec</span></span></span><a class="headerlink" href="#c.drm_exec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Execution context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_exec {
    u32 flags;
    struct ww_acquire_ctx   ticket;
    unsigned int            num_objects;
    unsigned int            max_objects;
    struct drm_gem_object   **objects;
    struct drm_gem_object   *contended;
    struct drm_gem_object *prelocked;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags to control locking behavior</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ticket</span></code></dt><dd><p>WW ticket used for acquiring locks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_objects</span></code></dt><dd><p>number of objects locked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_objects</span></code></dt><dd><p>maximum objects in array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">objects</span></code></dt><dd><p>array of the locked objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">contended</span></code></dt><dd><p>contended GEM object we backed off for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prelocked</span></code></dt><dd><p>already locked GEM object due to contention</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_obj">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the object for a give drm_exec index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>Pointer to the drm_exec context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">index</span></code></dt><dd><p>The index.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to the locked object corresponding to <strong>index</strong> if
index is within the number of locked objects. NULL otherwise.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_exec_for_each_locked_object">
<span class="sig-name descname"><span class="n"><span class="pre">drm_exec_for_each_locked_object</span></span></span><a class="headerlink" href="#c.drm_exec_for_each_locked_object" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_exec_for_each_locked_object</span> <span class="pre">(exec,</span> <span class="pre">index,</span> <span class="pre">obj)</span></code></p>
<blockquote>
<div><p>iterate over all the locked objects</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>drm_exec object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>unsigned long index for the iteration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>the current GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all the locked GEM objects inside the drm_exec object.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_exec_for_each_locked_object_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">drm_exec_for_each_locked_object_reverse</span></span></span><a class="headerlink" href="#c.drm_exec_for_each_locked_object_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_exec_for_each_locked_object_reverse</span> <span class="pre">(exec,</span> <span class="pre">index,</span> <span class="pre">obj)</span></code></p>
<blockquote>
<div><p>iterate over all the locked objects in reverse locking order</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>drm_exec object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>unsigned long index for the iteration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>the current GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all the locked GEM objects inside the drm_exec object in
reverse locking order. Note that <strong>index</strong> may go below zero and wrap,
but that will be caught by <a class="reference internal" href="#c.drm_exec_obj" title="drm_exec_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_exec_obj()</span></code></a>, returning a NULL object.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_exec_until_all_locked">
<span class="sig-name descname"><span class="n"><span class="pre">drm_exec_until_all_locked</span></span></span><a class="headerlink" href="#c.drm_exec_until_all_locked" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_exec_until_all_locked</span> <span class="pre">(exec)</span></code></p>
<blockquote>
<div><p>loop until all GEM objects are locked</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>drm_exec object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core functionality of the drm_exec object. Loops until all GEM objects are
locked and no more contention exists. At the beginning of the loop it is
guaranteed that no GEM object is locked.</p>
<p>Since labels can’t be defined local to the loops body we use a jump pointer
to make sure that the retry is only used from within the loops body.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.drm_exec_retry_on_contention">
<span class="sig-name descname"><span class="n"><span class="pre">drm_exec_retry_on_contention</span></span></span><a class="headerlink" href="#c.drm_exec_retry_on_contention" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">drm_exec_retry_on_contention</span> <span class="pre">(exec)</span></code></p>
<blockquote>
<div><p>restart the loop to grap all locks</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>drm_exec object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control flow helper to continue when a contention was detected and we need to
clean up and re-start the loop to prepare all GEM objects.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_is_contended">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_is_contended</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_is_contended" title="Link to this definition">¶</a><br /></dt>
<dd><p>check for contention</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>drm_exec object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the drm_exec object has run into some contention while
locking a GEM object and needs to clean up.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">flags</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="n"><span class="pre">nr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialize a drm_exec object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>controls locking behavior, see DRM_EXEC_* defines</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">nr</span></code></dt><dd><p>the initial # of objects</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the object and make sure that we can track locked objects.</p>
<p>If nr is non-zero then it is used as the initial objects table size.
In either case, the table will grow (be re-allocated) on demand.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>finalize a drm_exec object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object to finalize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock all locked objects, drop the references to objects and free all memory
used for tracking the state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_cleanup">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_cleanup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_cleanup" title="Link to this definition">¶</a><br /></dt>
<dd><p>cleanup when contention is detected</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup the current state and return true if we should stay inside the retry
loop, false if there wasn’t any contention detected and we can keep the
objects locked.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_lock_obj">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_lock_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_lock_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>lock a GEM object for use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object with the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the GEM object to lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock a GEM object for use and grab a reference to it.</p>
<p><strong>Return</strong></p>
<p>-EDEADLK if a contention is detected, -EALREADY when object is
already locked (can be suppressed by setting the DRM_EXEC_IGNORE_DUPLICATES
flag), -ENOMEM when memory allocation failed and zero for success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_unlock_obj">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_unlock_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_unlock_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>unlock a GEM object in this exec context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object with the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the GEM object to unlock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock the GEM object and remove it from the collection of locked objects.
Should only be used to unlock the most recently locked objects. It’s not time
efficient to unlock objects locked long ago.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_prepare_obj">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_prepare_obj</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_prepare_obj" title="Link to this definition">¶</a><br /></dt>
<dd><p>prepare a GEM object for use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object with the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the GEM object to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>how many fences to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare a GEM object for use by locking it and reserving fence slots.</p>
<p><strong>Return</strong></p>
<p>-EDEADLK if a contention is detected, -EALREADY when object is
already locked, -ENOMEM when memory allocation failed and zero for success.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_exec_prepare_array">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_exec_prepare_array</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_exec" title="drm_exec"><span class="n"><span class="pre">drm_exec</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exec</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">objects</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_objects</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_fences</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_exec_prepare_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>helper to prepare an array of objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_exec</span> <span class="pre">*exec</span></code></dt><dd><p>the drm_exec object with the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">**objects</span></code></dt><dd><p>array of GEM object to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_objects</span></code></dt><dd><p>number of GEM objects in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>number of fences to reserve on each GEM object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares all GEM objects in an array, aborts on first error.
Reserves <strong>num_fences</strong> on each GEM object after locking it.</p>
<p><strong>Return</strong></p>
<p>-EDEADLOCK on contention, -EALREADY when object is already locked,
-ENOMEM when memory allocation failed and zero for success.</p>
</div>
</section>
<section id="gpu-scheduler">
<h2>GPU Scheduler<a class="headerlink" href="#gpu-scheduler" title="Link to this heading">¶</a></h2>
<section id="id5">
<h3>Overview<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p>The GPU scheduler provides entities which allow userspace to push jobs
into software queues which are then scheduled on a hardware run queue.
The software queues have a priority among them. The scheduler selects the entities
from the run queue using a FIFO. The scheduler provides dependency handling
features among jobs. The driver is supposed to provide callback functions for
backend operations to the scheduler like submitting a job to hardware run queue,
returning the dependencies of a job etc.</p>
<p>The organisation of the scheduler is the following:</p>
<ol class="arabic simple">
<li><p>Each hw run queue has one scheduler</p></li>
<li><p>Each scheduler has multiple run queues with different priorities
(e.g., HIGH_HW,HIGH_SW, KERNEL, NORMAL)</p></li>
<li><p>Each scheduler run queue has a queue of entities to schedule</p></li>
<li><p>Entities themselves maintain a queue of jobs that will be scheduled on
the hardware.</p></li>
</ol>
<p>The jobs in a entity are always scheduled in the order that they were pushed.</p>
<p>Note that once a job was taken from the entities queue and pushed to the
hardware, i.e. the pending queue, the entity must not be referenced anymore
through the jobs entity pointer.</p>
</section>
<section id="flow-control">
<h3>Flow Control<a class="headerlink" href="#flow-control" title="Link to this heading">¶</a></h3>
<p>The DRM GPU scheduler provides a flow control mechanism to regulate the rate
in which the jobs fetched from scheduler entities are executed.</p>
<p>In this context the <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpu_scheduler</span></code></a> keeps track of a driver specified
credit limit representing the capacity of this scheduler and a credit count;
every <a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_job</span></code></a> carries a driver specified number of credits.</p>
<p>Once a job is executed (but not yet finished), the job’s credits contribute
to the scheduler’s credit count until the job is finished. If by executing
one more job the scheduler’s credit count would exceed the scheduler’s
credit limit, the job won’t be executed. Instead, the scheduler will wait
until the credit count has decreased enough to not overflow its credit limit.
This implies waiting for previously executed jobs.</p>
<p>Optionally, drivers may register a callback (update_job_credits) provided by
<a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_backend_ops</span></code></a> to update the job’s credits dynamically. The
scheduler executes this callback every time the scheduler considers a job for
execution and subsequently checks whether the job fits the scheduler’s credit
limit.</p>
</section>
<section id="scheduler-function-references">
<h3>Scheduler Function References<a class="headerlink" href="#scheduler-function-references" title="Link to this heading">¶</a></h3>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_SCHED_FENCE_DONT_PIPELINE">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_SCHED_FENCE_DONT_PIPELINE</span></span></span><a class="headerlink" href="#c.DRM_SCHED_FENCE_DONT_PIPELINE" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_SCHED_FENCE_DONT_PIPELINE</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>Prefent dependency pipelining</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Setting this flag on a scheduler fence prevents pipelining of jobs depending
on this fence. In other words we always insert a full CPU round trip before
dependen jobs are pushed to the hw queue.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.DRM_SCHED_FENCE_FLAG_HAS_DEADLINE_BIT">
<span class="sig-name descname"><span class="n"><span class="pre">DRM_SCHED_FENCE_FLAG_HAS_DEADLINE_BIT</span></span></span><a class="headerlink" href="#c.DRM_SCHED_FENCE_FLAG_HAS_DEADLINE_BIT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">DRM_SCHED_FENCE_FLAG_HAS_DEADLINE_BIT</span> <span class="pre">()</span></code></p>
<blockquote>
<div><p>A fence deadline hint has been set</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Because we could have a deadline hint can be set before the backing hw
fence is created, we need to keep track of whether a deadline has already
been set.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_sched_entity">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity</span></span></span><a class="headerlink" href="#c.drm_sched_entity" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper around a job queue (typically attached to the DRM file_priv).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_sched_entity {
    struct list_head                list;
    struct drm_sched_rq             *rq;
    struct drm_gpu_scheduler        **sched_list;
    unsigned int                    num_sched_list;
    enum drm_sched_priority         priority;
    spinlock_t rq_lock;
    struct spsc_queue               job_queue;
    atomic_t fence_seq;
    uint64_t fence_context;
    struct dma_fence                *dependency;
    struct dma_fence_cb             cb;
    atomic_t *guilty;
    struct dma_fence __rcu          *last_scheduled;
    struct task_struct              *last_user;
    bool stopped;
    struct completion               entity_idle;
    ktime_t oldest_job_waiting;
    struct rb_node                  rb_tree_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Used to append this struct to the list of entities in the runqueue
<strong>rq</strong> under <a class="reference internal" href="#c.drm_sched_rq" title="drm_sched_rq"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_rq.entities</span></code></a>.</p>
<p>Protected by <a class="reference internal" href="#c.drm_sched_rq" title="drm_sched_rq"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_rq.lock</span></code></a> of <strong>rq</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rq</span></code></dt><dd><p>Runqueue on which this entity is currently scheduled.</p>
<p>FIXME: Locking is very unclear for this. Writers are protected by
<strong>rq_lock</strong>, but readers are generally lockless and seem to just race
with not even a READ_ONCE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_list</span></code></dt><dd><p>A list of schedulers (<a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span></code></a>).  Jobs from this entity can
be scheduled on any scheduler on this list.</p>
<p>This can be modified by calling <a class="reference internal" href="#c.drm_sched_entity_modify_sched" title="drm_sched_entity_modify_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_modify_sched()</span></code></a>.
Locking is entirely up to the driver, see the above function for more
details.</p>
<p>This will be set to NULL if <code class="xref c c-type docutils literal notranslate"><span class="pre">num_sched_list</span></code> equals 1 and <strong>rq</strong> has been
set already.</p>
<p>FIXME: This means priority changes through
<a class="reference internal" href="#c.drm_sched_entity_set_priority" title="drm_sched_entity_set_priority"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_set_priority()</span></code></a> will be lost henceforth in this case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sched_list</span></code></dt><dd><p>Number of drm_gpu_schedulers in the <strong>sched_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>Priority of the entity. This can be modified by calling
<a class="reference internal" href="#c.drm_sched_entity_set_priority" title="drm_sched_entity_set_priority"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_set_priority()</span></code></a>. Protected by <code class="xref c c-type docutils literal notranslate"><span class="pre">rq_lock</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rq_lock</span></code></dt><dd><p>Lock to modify the runqueue to which this entity belongs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_queue</span></code></dt><dd><p>the list of jobs of this entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_seq</span></code></dt><dd><p>A linearly increasing seqno incremented with each new
<a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence</span></code></a> which is part of the entity.</p>
<p>FIXME: Callers of <a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a> need to ensure correct locking,
this doesn’t need to be atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_context</span></code></dt><dd><p>A unique context for all the fences which belong to this entity.  The
<a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence.scheduled</span></code></a> uses the fence_context but
<a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence.finished</span></code></a> uses fence_context + 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dependency</span></code></dt><dd><p>The dependency fence of the job which is on the top of the job queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>Callback for the dependency fence above.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">guilty</span></code></dt><dd><p>Points to entities’ guilty.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_scheduled</span></code></dt><dd><p>Points to the finished fence of the last scheduled job. Only written
by the scheduler thread, can be accessed locklessly from
<a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a> iff the queue is empty.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_user</span></code></dt><dd><p>last group leader pushing a job into the entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stopped</span></code></dt><dd><p>Marks the enity as removed from rq and destined for
termination. This is set by calling <a class="reference internal" href="#c.drm_sched_entity_flush" title="drm_sched_entity_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_flush()</span></code></a> and by
<a class="reference internal" href="#c.drm_sched_fini" title="drm_sched_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_fini()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity_idle</span></code></dt><dd><p>Signals when entity is not in use, used to sequence entity cleanup in
<a class="reference internal" href="#c.drm_sched_entity_fini" title="drm_sched_entity_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_fini()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oldest_job_waiting</span></code></dt><dd><p>Marks earliest job waiting in SW queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb_tree_node</span></code></dt><dd><p>The node used to insert this entity into time based priority queue</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Entities will emit jobs in order to their corresponding hardware
ring, and the scheduler will alternate between entities based on
scheduling policy.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_sched_rq">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_rq</span></span></span><a class="headerlink" href="#c.drm_sched_rq" title="Link to this definition">¶</a><br /></dt>
<dd><p>queue of entities to be scheduled.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_sched_rq {
    spinlock_t lock;
    struct drm_gpu_scheduler        *sched;
    struct list_head                entities;
    struct drm_sched_entity         *current_entity;
    struct rb_root_cached           rb_tree_root;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>to modify the entities list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched</span></code></dt><dd><p>the scheduler to which this rq belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entities</span></code></dt><dd><p>list of the entities to be scheduled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_entity</span></code></dt><dd><p>the entity which is to be scheduled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rb_tree_root</span></code></dt><dd><p>root of time based priory queue of entities for FIFO scheduling</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Run queue is a set of entities scheduling command submissions for
one specific ring. It implements the scheduling policy that selects
the next entity to emit commands from.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_sched_fence">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_fence</span></span></span><a class="headerlink" href="#c.drm_sched_fence" title="Link to this definition">¶</a><br /></dt>
<dd><p>fences corresponding to the scheduling of a job.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_sched_fence {
    struct dma_fence                scheduled;
    struct dma_fence                finished;
    ktime_t deadline;
    struct dma_fence                *parent;
    struct drm_gpu_scheduler        *sched;
    spinlock_t lock;
    void *owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">scheduled</span></code></dt><dd><p>this fence is what will be signaled by the scheduler
when the job is scheduled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">finished</span></code></dt><dd><p>this fence is what will be signaled by the scheduler
when the job is completed.</p>
<p>When setting up an out fence for the job, you should use
this, since it’s available immediately upon
<a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_init()</span></code></a>, and the fence returned by the driver
from run_job() won’t be created until the dependencies have
resolved.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deadline</span></code></dt><dd><p>deadline set on <a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence.finished</span></code></a> which
potentially needs to be propagated to <a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence.parent</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>the fence returned by <a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_backend_ops.run_job</span></code></a>
when scheduling the job on hardware. We signal the
<a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_fence.finished</span></code></a> fence once parent is signalled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched</span></code></dt><dd><p>the scheduler instance to which the job having this struct
belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>the lock used by the scheduled and the finished fences.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>job owner for debugging</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_sched_job">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job</span></span></span><a class="headerlink" href="#c.drm_sched_job" title="Link to this definition">¶</a><br /></dt>
<dd><p>A job to be run by an entity.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_sched_job {
    struct spsc_node                queue_node;
    struct list_head                list;
    struct drm_gpu_scheduler        *sched;
    struct drm_sched_fence          *s_fence;
    u32 credits;
    union {
        struct dma_fence_cb             finish_cb;
        struct work_struct              work;
    };
    uint64_t id;
    atomic_t karma;
    enum drm_sched_priority         s_priority;
    struct drm_sched_entity         *entity;
    struct dma_fence_cb             cb;
    struct xarray                   dependencies;
    unsigned long                   last_dependency;
    ktime_t submit_ts;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">queue_node</span></code></dt><dd><p>used to append this struct to the queue of jobs in an entity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>a job participates in a “pending” and “done” lists.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched</span></code></dt><dd><p>the scheduler instance on which this job is scheduled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_fence</span></code></dt><dd><p>contains the fences for the scheduling of job.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">credits</span></code></dt><dd><p>the number of credits this job contributes to the scheduler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">finish_cb</span></code></dt><dd><p>the callback for the finished fence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Helper to reschdeule job kill to different context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>a unique id assigned to each job scheduled on the scheduler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">karma</span></code></dt><dd><p>increment on every hang caused by this job. If this exceeds the hang
limit of the scheduler then the job is marked guilty and will not
be scheduled further.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_priority</span></code></dt><dd><p>the priority of the job.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>the entity to which this job belongs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>the callback for the parent fence in s_fence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dependencies</span></code></dt><dd><p>Contains the dependencies as <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a> for this job, see
<a class="reference internal" href="#c.drm_sched_job_add_dependency" title="drm_sched_job_add_dependency"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_add_dependency()</span></code></a> and
<a class="reference internal" href="#c.drm_sched_job_add_implicit_dependencies" title="drm_sched_job_add_implicit_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_add_implicit_dependencies()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_dependency</span></code></dt><dd><p>tracks <strong>dependencies</strong> as they signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">submit_ts</span></code></dt><dd><p>When the job was pushed into the entity queue.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A job is created by the driver using <a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_init()</span></code></a>, and
should call <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_push_job()</span></code></a> once it wants the scheduler
to schedule the job.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_sched_backend_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_backend_ops</span></span></span><a class="headerlink" href="#c.drm_sched_backend_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Define the backend operations called by the scheduler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_sched_backend_ops {
    struct dma_fence *(*prepare_job)(struct drm_sched_job *sched_job, struct drm_sched_entity *s_entity);
    struct dma_fence *(*run_job)(struct drm_sched_job *sched_job);
    enum drm_gpu_sched_stat (*timedout_job)(struct drm_sched_job *sched_job);
    void (*free_job)(struct drm_sched_job *sched_job);
    u32 (*update_job_credits)(struct drm_sched_job *sched_job);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_job</span></code></dt><dd><p>Called when the scheduler is considering scheduling this job next, to
get another <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a> for this job to block on.  Once it
returns NULL, run_job() may be called.</p>
<p>Can be NULL if no additional preparation to the dependencies are
necessary. Skipped when jobs are killed instead of run.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">run_job</span></code></dt><dd><p>Called to execute the job once all of the dependencies
have been resolved.  This may be called multiple times, if
timedout_job() has happened and drm_sched_job_recovery()
decides to try it again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timedout_job</span></code></dt><dd><p>Called when a job has taken too long to execute,
to trigger GPU recovery.</p>
<p>This method is called in a workqueue context.</p>
<p>Drivers typically issue a reset to recover from GPU hangs, and this
procedure usually follows the following workflow:</p>
<ol class="arabic simple">
<li><p>Stop the scheduler using <a class="reference internal" href="#c.drm_sched_stop" title="drm_sched_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_stop()</span></code></a>. This will park the
scheduler thread and cancel the timeout work, guaranteeing that
nothing is queued while we reset the hardware queue</p></li>
<li><p>Try to gracefully stop non-faulty jobs (optional)</p></li>
<li><p>Issue a GPU reset (driver-specific)</p></li>
<li><p>Re-submit jobs using <a class="reference internal" href="#c.drm_sched_resubmit_jobs" title="drm_sched_resubmit_jobs"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_resubmit_jobs()</span></code></a></p></li>
<li><p>Restart the scheduler using <a class="reference internal" href="#c.drm_sched_start" title="drm_sched_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_start()</span></code></a>. At that point, new
jobs can be queued, and the scheduler thread is unblocked</p></li>
</ol>
<p>Note that some GPUs have distinct hardware queues but need to reset
the GPU globally, which requires extra synchronization between the
timeout handler of the different <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gpu_scheduler</span></code></a>. One way to
achieve this synchronization is to create an ordered workqueue
(using <a class="reference internal" href="../core-api/workqueue.html#c.alloc_ordered_workqueue" title="alloc_ordered_workqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_ordered_workqueue()</span></code></a>) at the driver level, and pass this
queue to <a class="reference internal" href="#c.drm_sched_init" title="drm_sched_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_init()</span></code></a>, to guarantee that timeout handlers are
executed sequentially. The above workflow needs to be slightly
adjusted in that case:</p>
<ol class="arabic simple">
<li><p>Stop all schedulers impacted by the reset using <a class="reference internal" href="#c.drm_sched_stop" title="drm_sched_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_stop()</span></code></a></p></li>
<li><p>Try to gracefully stop non-faulty jobs on all queues impacted by
the reset (optional)</p></li>
<li><p>Issue a GPU reset on all faulty queues (driver-specific)</p></li>
<li><p>Re-submit jobs on all schedulers impacted by the reset using
<a class="reference internal" href="#c.drm_sched_resubmit_jobs" title="drm_sched_resubmit_jobs"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_resubmit_jobs()</span></code></a></p></li>
<li><p>Restart all schedulers that were stopped in step #1 using
<a class="reference internal" href="#c.drm_sched_start" title="drm_sched_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_start()</span></code></a></p></li>
</ol>
<p>Return DRM_GPU_SCHED_STAT_NOMINAL, when all is normal,
and the underlying driver has started or completed recovery.</p>
<p>Return DRM_GPU_SCHED_STAT_ENODEV, if the device is no longer
available, i.e. has been unplugged.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_job</span></code></dt><dd><p>Called once the job’s finished fence has been signaled
and it’s time to clean it up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update_job_credits</span></code></dt><dd><p>Called when the scheduler is considering this
job for execution.</p>
<p>This callback returns the number of credits the job would take if
pushed to the hardware. Drivers may use this to dynamically update
the job’s credit count. For instance, deduct the number of credits
for already signalled native fences.</p>
<p>This callback is optional.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These functions should be implemented in the driver side.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.drm_gpu_scheduler">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></span><a class="headerlink" href="#c.drm_gpu_scheduler" title="Link to this definition">¶</a><br /></dt>
<dd><p>scheduler instance-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_gpu_scheduler {
    const struct drm_sched_backend_ops      *ops;
    u32 credit_limit;
    atomic_t credit_count;
    long timeout;
    const char                      *name;
    u32 num_rqs;
    struct drm_sched_rq             **sched_rq;
    wait_queue_head_t job_scheduled;
    atomic64_t job_id_count;
    struct workqueue_struct         *submit_wq;
    struct workqueue_struct         *timeout_wq;
    struct work_struct              work_run_job;
    struct work_struct              work_free_job;
    struct delayed_work             work_tdr;
    struct list_head                pending_list;
    spinlock_t job_list_lock;
    int hang_limit;
    atomic_t *score;
    atomic_t _score;
    bool ready;
    bool free_guilty;
    bool pause_submit;
    bool own_submit_wq;
    struct device                   *dev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>backend operations provided by the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">credit_limit</span></code></dt><dd><p>the credit limit of this scheduler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">credit_count</span></code></dt><dd><p>the current credit count of this scheduler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>the time after which a job is removed from the scheduler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the ring for which this scheduler is being used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rqs</span></code></dt><dd><p>Number of run-queues. This is at most DRM_SCHED_PRIORITY_COUNT,
as there’s usually one run-queue per priority, but could be less.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched_rq</span></code></dt><dd><p>An allocated array of run-queues of size <strong>num_rqs</strong>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_scheduled</span></code></dt><dd><p>once <strong>drm_sched_entity_do_release</strong> is called the scheduler
waits on this wait queue until all the scheduled jobs are
finished.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_id_count</span></code></dt><dd><p>used to assign unique id to the each job.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">submit_wq</span></code></dt><dd><p>workqueue used to queue <strong>work_run_job</strong> and <strong>work_free_job</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout_wq</span></code></dt><dd><p>workqueue used to queue <strong>work_tdr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_run_job</span></code></dt><dd><p>work which calls run_job op of each scheduler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_free_job</span></code></dt><dd><p>work which calls free_job op of each scheduler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_tdr</span></code></dt><dd><p>schedules a delayed call to <strong>drm_sched_job_timedout</strong> after the
timeout interval is over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pending_list</span></code></dt><dd><p>the list of jobs which are currently in the job queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">job_list_lock</span></code></dt><dd><p>lock to protect the pending_list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hang_limit</span></code></dt><dd><p>once the hangs by a job crosses this limit then it is marked
guilty and it will no longer be considered for scheduling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">score</span></code></dt><dd><p>score to help loadbalancer pick a idle sched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_score</span></code></dt><dd><p>score used when the driver doesn’t provide one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ready</span></code></dt><dd><p>marks if the underlying HW is ready to work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_guilty</span></code></dt><dd><p>A hit to time out handler to free the guilty job.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause_submit</span></code></dt><dd><p>pause queuing of <strong>work_run_job</strong> on <strong>submit_wq</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">own_submit_wq</span></code></dt><dd><p>scheduler owns allocation of <strong>submit_wq</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>system <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>One scheduler is implemented for each hardware ring.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_tdr_queue_imm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_tdr_queue_imm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_tdr_queue_imm" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>immediately start job timeout handler</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler for which the timeout handling should be started.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start timeout handling immediately for the named scheduler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_fault">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_fault</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_fault" title="Link to this definition">¶</a><br /></dt>
<dd><p>immediately start timeout handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler where the timeout handling should be started.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start timeout handling immediately when the driver detects a hardware fault.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_suspend_timeout">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_suspend_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_suspend_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Suspend scheduler job timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance for which to suspend the timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Suspend the delayed work timeout for the scheduler. This is done by
modifying the delayed work timeout to an arbitrary large value,
MAX_SCHEDULE_TIMEOUT in this case.</p>
<p>Returns the timeout remaining</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_resume_timeout">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_resume_timeout</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">remaining</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_resume_timeout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Resume scheduler job timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance for which to resume the timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">remaining</span></code></dt><dd><p>remaining timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume the delayed work timeout for the scheduler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_stop">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_stop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bad</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop the scheduler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*bad</span></code></dt><dd><p>job which caused the time out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop the scheduler and also removes and frees all completed jobs.</p>
<p><strong>Note</strong></p>
<p>bad job will not be freed as it might be used later and so it’s
callers responsibility to release it manually if it’s not part of the
pending list any more.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_start">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">full_recovery</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>recover jobs after a reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">full_recovery</span></code></dt><dd><p>proceed with complete sched restart</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_resubmit_jobs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_resubmit_jobs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_resubmit_jobs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Deprecated, don’t use in new code!</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Re-submitting jobs was a concept AMD came up as cheap way to implement
recovery after a job timeout.</p>
<p>This turned out to be not working very well. First of all there are many
problem with the dma_fence implementation and requirements. Either the
implementation is risking deadlocks with core memory management or violating
documented implementation details of the dma_fence object.</p>
<p>Drivers can still save and restore their state for recovery operations, but
we shouldn’t make this a general scheduler feature around the dma_fence
interface.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">credits</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">owner</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>init a scheduler job</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">credits</span></code></dt><dd><p>the number of credits this job contributes to the schedulers
credit limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*owner</span></code></dt><dd><p>job owner for debugging</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refer to <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_push_job()</span></code></a> documentation
for locking considerations.</p>
<p>Drivers must make sure <a class="reference internal" href="#c.drm_sched_job_cleanup" title="drm_sched_job_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_cleanup()</span></code></a> if this function returns
successfully, even when <strong>job</strong> is aborted before <a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a> is called.</p>
<p>WARNING: amdgpu abuses <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched.ready</span></code> to signal when the hardware
has died, which can mean that there’s no valid runqueue for a <strong>entity</strong>.
This function returns -ENOENT in this case (which probably should be -EIO as
a more meanigful return value).</p>
<p>Returns 0 for success, negative error code otherwise.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_arm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_arm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_arm" title="Link to this definition">¶</a><br /></dt>
<dd><p>arm a scheduler job for execution</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to arm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This arms a scheduler job for execution. Specifically it initializes the
<a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_job.s_fence</span></code></a> of <strong>job</strong>, so that it can be attached to <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a>
or other places that need to track the completion of this job.</p>
<p>Refer to <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_push_job()</span></code></a> documentation for locking
considerations.</p>
<p>This can only be called if <a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_init()</span></code></a> succeeded.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_add_dependency">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_add_dependency</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><span class="n"><span class="pre">dma_fence</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fence</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_add_dependency" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds the fence as a job dependency</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to add the dependencies to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence to add to the list of dependencies.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>fence</strong> is consumed in both the success and error cases.</p>
<p><strong>Return</strong></p>
<p>0 on success, or an error on failing to expand the array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_add_syncobj_dependency">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_add_syncobj_dependency</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><span class="n"><span class="pre">drm_file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">handle</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">point</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_add_syncobj_dependency" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds a syncobj’s fence as a job dependency</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to add the dependencies to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>drm file private pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">handle</span></code></dt><dd><p>syncobj handle to lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">point</span></code></dt><dd><p>timeline point</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the fence matching the given syncobj to <strong>job</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, or an error on failing to expand the array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_add_resv_dependencies">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_add_resv_dependencies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv" title="dma_resv"><span class="n"><span class="pre">dma_resv</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">resv</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><span class="n"><span class="pre">dma_resv_usage</span></span></a><span class="w"> </span><span class="n"><span class="pre">usage</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_add_resv_dependencies" title="Link to this definition">¶</a><br /></dt>
<dd><p>add all fences from the resv to the job</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to add the dependencies to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*resv</span></code></dt><dd><p>the dma_resv object to get the fences from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>the dma_resv_usage to use to filter the fences</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds all fences matching the given usage from <strong>resv</strong> to <strong>job</strong>.
Must be called with the <strong>resv</strong> lock held.</p>
<p><strong>Return</strong></p>
<p>0 on success, or an error on failing to expand the array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_add_implicit_dependencies">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_add_implicit_dependencies</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><span class="n"><span class="pre">drm_gem_object</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n"><span class="pre">write</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_add_implicit_dependencies" title="Link to this definition">¶</a><br /></dt>
<dd><p>adds implicit dependencies as job dependencies</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to add the dependencies to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*obj</span></code></dt><dd><p>the gem object to add new dependencies from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>whether the job might write the object (so we need to depend on
shared fences in the reservation object).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called after <a class="reference internal" href="#c.drm_gem_lock_reservations" title="drm_gem_lock_reservations"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_lock_reservations()</span></code></a> on your array of
GEM objects used in the job but before updating the reservations with your
own fences.</p>
<p><strong>Return</strong></p>
<p>0 on success, or an error on failing to expand the array.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_job_cleanup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_job_cleanup</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">job</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_cleanup" title="Link to this definition">¶</a><br /></dt>
<dd><p>clean up scheduler job resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*job</span></code></dt><dd><p>scheduler job to clean up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the resources allocated with <a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_init()</span></code></a>.</p>
<p>Drivers should call this from their error unwind code if <strong>job</strong> is aborted
before <a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a> is called.</p>
<p>After that point of no return <strong>job</strong> is committed to be executed by the
scheduler, and this function should be called from the
<a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_sched_backend_ops.free_job</span></code></a> callback.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_pick_best">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_pick_best</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched_list</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_sched_list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_pick_best" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get a drm sched from a sched_list with the least load</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">**sched_list</span></code></dt><dd><p>list of drm_gpu_schedulers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_sched_list</span></code></dt><dd><p>number of drm_gpu_schedulers in the sched_list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer of the sched with the least load or NULL if none of the
drm_gpu_schedulers are ready</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops"><span class="n"><span class="pre">drm_sched_backend_ops</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ops</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">submit_wq</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">num_rqs</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">credit_limit</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">hang_limit</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">workqueue_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">timeout_wq</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">score</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="n"><span class="pre">device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">dev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Init a gpu scheduler instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_sched_backend_ops</span> <span class="pre">*ops</span></code></dt><dd><p>backend operations for this scheduler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*submit_wq</span></code></dt><dd><p>workqueue to use for submission. If NULL, an ordered wq is
allocated and used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">num_rqs</span></code></dt><dd><p>number of runqueues, one for each priority, up to DRM_SCHED_PRIORITY_COUNT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">credit_limit</span></code></dt><dd><p>the number of credits this scheduler can hold from all jobs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hang_limit</span></code></dt><dd><p>number of times to allow a job to hang before dropping it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies for the scheduler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*timeout_wq</span></code></dt><dd><p>workqueue to use for timeout work. If NULL, the system_wq is
used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*score</span></code></dt><dd><p>optional score atomic shared with other schedulers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name used for debugging</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>target <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, otherwise error code.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy a gpu scheduler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down and cleans up the scheduler.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_increase_karma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_increase_karma</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">bad</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_increase_karma" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update sched_entity guilty flag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*bad</span></code></dt><dd><p>The job guilty of time out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increment on every hang caused by the ‘bad’ job. If this exceeds the hang
limit of the scheduler then the respective sched entity is marked guilty and
jobs from it will not be scheduled further</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_wqueue_ready">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_wqueue_ready</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_wqueue_ready" title="Link to this definition">¶</a><br /></dt>
<dd><p>Is the scheduler ready for submission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if submission is ready</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_wqueue_stop">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_wqueue_stop</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_wqueue_stop" title="Link to this definition">¶</a><br /></dt>
<dd><p>stop scheduler submission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_wqueue_start">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_wqueue_start</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_wqueue_start" title="Link to this definition">¶</a><br /></dt>
<dd><p>start scheduler submission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*sched</span></code></dt><dd><p>scheduler instance</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_init">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">drm_sched_priority</span></span><span class="w"> </span><span class="n"><span class="pre">priority</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched_list</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_sched_list</span></span>, <span class="n"><span class="pre">atomic_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">guilty</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Init a context entity used by scheduler when submit to HW ring.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_sched_priority</span> <span class="pre">priority</span></code></dt><dd><p>priority of the entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">**sched_list</span></code></dt><dd><p>the list of drm scheds on which jobs from this
entity can be submitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_sched_list</span></code></dt><dd><p>number of drm sched in sched_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*guilty</span></code></dt><dd><p>atomic_t set to 1 when a job on this queue
is found to be guilty causing a timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the <code class="xref c c-type docutils literal notranslate"><span class="pre">sched_list</span></code> must have at least one element to schedule the entity.</p>
<p>For changing <strong>priority</strong> later on at runtime see
<a class="reference internal" href="#c.drm_sched_entity_set_priority" title="drm_sched_entity_set_priority"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_set_priority()</span></code></a>. For changing the set of schedulers
<strong>sched_list</strong> at runtime see <a class="reference internal" href="#c.drm_sched_entity_modify_sched" title="drm_sched_entity_modify_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_modify_sched()</span></code></a>.</p>
<p>An entity is cleaned up by callind <a class="reference internal" href="#c.drm_sched_entity_fini" title="drm_sched_entity_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_fini()</span></code></a>. See also
<a class="reference internal" href="#c.drm_sched_entity_destroy" title="drm_sched_entity_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_destroy()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_modify_sched">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_modify_sched</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler"><span class="n"><span class="pre">drm_gpu_scheduler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched_list</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_sched_list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_modify_sched" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modify sched of an entity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">**sched_list</span></code></dt><dd><p>the list of new drm scheds which will replace
existing entity-&gt;sched_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_sched_list</span></code></dt><dd><p>number of drm sched in sched_list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this must be called under the same common lock for <strong>entity</strong> as
<a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a> and <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_push_job()</span></code></a>, or the driver needs to
guarantee through some other means that this is never called while new jobs
can be pushed to <strong>entity</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_error">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>return error of last scheduled job</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Opportunistically return the error of the last scheduled job. Result can
change any time when new jobs are pushed to the hw.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_flush">
<span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_flush</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">timeout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_flush" title="Link to this definition">¶</a><br /></dt>
<dd><p>Flush a context entity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>time to wait in for Q to become empty in jiffies.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Splitting <a class="reference internal" href="#c.drm_sched_entity_fini" title="drm_sched_entity_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_fini()</span></code></a> into two functions, The first one does the
waiting, removes the entity from the runqueue and returns an error when the
process was killed.</p>
<p>Returns the remaining time in jiffies left from the input timeout</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_fini">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_fini</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_fini" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy a context entity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanups up <strong>entity</strong> which has been initialized by <a class="reference internal" href="#c.drm_sched_entity_init" title="drm_sched_entity_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_init()</span></code></a>.</p>
<p>If there are potentially job still in flight or getting newly queued
<a class="reference internal" href="#c.drm_sched_entity_flush" title="drm_sched_entity_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_flush()</span></code></a> must be called first. This function then goes over
the entity and signals all jobs with an error code if the process was killed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_destroy">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_destroy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_destroy" title="Link to this definition">¶</a><br /></dt>
<dd><p>Destroy a context entity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_sched_entity_flush" title="drm_sched_entity_flush"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_flush()</span></code></a> and <a class="reference internal" href="#c.drm_sched_entity_fini" title="drm_sched_entity_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_entity_fini()</span></code></a> as a
convenience wrapper.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_set_priority">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_set_priority</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><span class="n"><span class="pre">drm_sched_entity</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entity</span></span>, <span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">drm_sched_priority</span></span><span class="w"> </span><span class="n"><span class="pre">priority</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_set_priority" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets priority of the entity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*entity</span></code></dt><dd><p>scheduler entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_sched_priority</span> <span class="pre">priority</span></code></dt><dd><p>scheduler priority</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the priority of runqueus used for the entity.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.drm_sched_entity_push_job">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">drm_sched_entity_push_job</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job"><span class="n"><span class="pre">drm_sched_job</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sched_job</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_push_job" title="Link to this definition">¶</a><br /></dt>
<dd><p>Submit a job to the entity’s job queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*sched_job</span></code></dt><dd><p>job to submit</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>To guarantee that the order of insertion to queue matches the job’s
fence sequence number this function should be called with <a class="reference internal" href="#c.drm_sched_job_arm" title="drm_sched_job_arm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_arm()</span></code></a>
under common lock for the <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span></code></a> that was set up for
<strong>sched_job</strong> in <a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sched_job_init()</span></code></a>.</p>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code otherwise.</p>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/drm-mm.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>