
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Design &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="API Reference" href="api.html" />
    <link rel="prev" title="Frequently Asked Questions" href="faq.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.5.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../networking/index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../wmi/index.html">WMI Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/mm/damon/design.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="design">
<h1>Design<a class="headerlink" href="#design" title="Permalink to this heading">¶</a></h1>
<section id="overall-architecture">
<h2>Overall Architecture<a class="headerlink" href="#overall-architecture" title="Permalink to this heading">¶</a></h2>
<p>DAMON subsystem is configured with three layers including</p>
<ul class="simple">
<li><p>Operations Set: Implements fundamental operations for DAMON that depends on
the given monitoring target address-space and available set of
software/hardware primitives,</p></li>
<li><p>Core: Implements core logics including monitoring overhead/accurach control
and access-aware system operations on top of the operations set layer, and</p></li>
<li><p>Modules: Implements kernel modules for various purposes that provides
interfaces for the user space, on top of the core layer.</p></li>
</ul>
<section id="configurable-operations-set">
<h3>Configurable Operations Set<a class="headerlink" href="#configurable-operations-set" title="Permalink to this heading">¶</a></h3>
<p>For data access monitoring and additional low level work, DAMON needs a set of
implementations for specific operations that are dependent on and optimized for
the given target address space.  On the other hand, the accuracy and overhead
tradeoff mechanism, which is the core logic of DAMON, is in the pure logic
space.  DAMON separates the two parts in different layers, namely DAMON
Operations Set and DAMON Core Logics Layers, respectively.  It further defines
the interface between the layers to allow various operations sets to be
configured with the core logic.</p>
<p>Due to this design, users can extend DAMON for any address space by configuring
the core logic to use the appropriate operations set.  If any appropriate set
is unavailable, users can implement one on their own.</p>
<p>For example, physical memory, virtual memory, swap space, those for specific
processes, NUMA nodes, files, and backing memory devices would be supportable.
Also, if some architectures or devices supporting special optimized access
check primitives, those will be easily configurable.</p>
</section>
<section id="programmable-modules">
<h3>Programmable Modules<a class="headerlink" href="#programmable-modules" title="Permalink to this heading">¶</a></h3>
<p>Core layer of DAMON is implemented as a framework, and exposes its application
programming interface to all kernel space components such as subsystems and
modules.  For common use cases of DAMON, DAMON subsystem provides kernel
modules that built on top of the core layer using the API, which can be easily
used by the user space end users.</p>
</section>
</section>
<section id="operations-set-layer">
<h2>Operations Set Layer<a class="headerlink" href="#operations-set-layer" title="Permalink to this heading">¶</a></h2>
<p>The monitoring operations are defined in two parts:</p>
<ol class="arabic simple">
<li><p>Identification of the monitoring target address range for the address space.</p></li>
<li><p>Access check of specific address range in the target space.</p></li>
</ol>
<p>DAMON currently provides the implementations of the operations for the physical
and virtual address spaces. Below two subsections describe how those work.</p>
<section id="vma-based-target-address-range-construction">
<h3>VMA-based Target Address Range Construction<a class="headerlink" href="#vma-based-target-address-range-construction" title="Permalink to this heading">¶</a></h3>
<p>This is only for the virtual address space monitoring operations
implementation.  That for the physical address space simply asks users to
manually set the monitoring target address ranges.</p>
<p>Only small parts in the super-huge virtual address space of the processes are
mapped to the physical memory and accessed.  Thus, tracking the unmapped
address regions is just wasteful.  However, because DAMON can deal with some
level of noise using the adaptive regions adjustment mechanism, tracking every
mapping is not strictly required but could even incur a high overhead in some
cases.  That said, too huge unmapped areas inside the monitoring target should
be removed to not take the time for the adaptive mechanism.</p>
<p>For the reason, this implementation converts the complex mappings to three
distinct regions that cover every mapped area of the address space.  The two
gaps between the three regions are the two biggest unmapped areas in the given
address space.  The two biggest unmapped areas would be the gap between the
heap and the uppermost mmap()-ed region, and the gap between the lowermost
mmap()-ed region and the stack in most of the cases.  Because these gaps are
exceptionally huge in usual address spaces, excluding these will be sufficient
to make a reasonable trade-off.  Below shows this in detail:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;heap&gt;
&lt;BIG UNMAPPED REGION 1&gt;
&lt;uppermost mmap()-ed region&gt;
(small mmap()-ed regions and munmap()-ed regions)
&lt;lowermost mmap()-ed region&gt;
&lt;BIG UNMAPPED REGION 2&gt;
&lt;stack&gt;
</pre></div>
</div>
</section>
<section id="pte-accessed-bit-based-access-check">
<h3>PTE Accessed-bit Based Access Check<a class="headerlink" href="#pte-accessed-bit-based-access-check" title="Permalink to this heading">¶</a></h3>
<p>Both of the implementations for physical and virtual address spaces use PTE
Accessed-bit for basic access checks.  Only one difference is the way of
finding the relevant PTE Accessed bit(s) from the address.  While the
implementation for the virtual address walks the page table for the target task
of the address, the implementation for the physical address walks every page
table having a mapping to the address.  In this way, the implementations find
and clear the bit(s) for next sampling target address and checks whether the
bit(s) set again after one sampling period.  This could disturb other kernel
subsystems using the Accessed bits, namely Idle page tracking and the reclaim
logic.  DAMON does nothing to avoid disturbing Idle page tracking, so handling
the interference is the responsibility of sysadmins.  However, it solves the
conflict with the reclaim logic using <code class="docutils literal notranslate"><span class="pre">PG_idle</span></code> and <code class="docutils literal notranslate"><span class="pre">PG_young</span></code> page flags,
as Idle page tracking does.</p>
</section>
</section>
<section id="core-logics">
<h2>Core Logics<a class="headerlink" href="#core-logics" title="Permalink to this heading">¶</a></h2>
<section id="monitoring">
<h3>Monitoring<a class="headerlink" href="#monitoring" title="Permalink to this heading">¶</a></h3>
<p>Below four sections describe each of the DAMON core mechanisms and the five
monitoring attributes, <code class="docutils literal notranslate"><span class="pre">sampling</span> <span class="pre">interval</span></code>, <code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">interval</span></code>,
<code class="docutils literal notranslate"><span class="pre">update</span> <span class="pre">interval</span></code>, <code class="docutils literal notranslate"><span class="pre">minimum</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">regions</span></code>, and <code class="docutils literal notranslate"><span class="pre">maximum</span> <span class="pre">number</span> <span class="pre">of</span>
<span class="pre">regions</span></code>.</p>
<section id="access-frequency-monitoring">
<h4>Access Frequency Monitoring<a class="headerlink" href="#access-frequency-monitoring" title="Permalink to this heading">¶</a></h4>
<p>The output of DAMON says what pages are how frequently accessed for a given
duration.  The resolution of the access frequency is controlled by setting
<code class="docutils literal notranslate"><span class="pre">sampling</span> <span class="pre">interval</span></code> and <code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">interval</span></code>.  In detail, DAMON checks
access to each page per <code class="docutils literal notranslate"><span class="pre">sampling</span> <span class="pre">interval</span></code> and aggregates the results.  In
other words, counts the number of the accesses to each page.  After each
<code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">interval</span></code> passes, DAMON calls callback functions that previously
registered by users so that users can read the aggregated results and then
clears the results.  This can be described in below simple pseudo-code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while monitoring_on:
    for page in monitoring_target:
        if accessed(page):
            nr_accesses[page] += 1
    if time() % aggregation_interval == 0:
        for callback in user_registered_callbacks:
            callback(monitoring_target, nr_accesses)
        for page in monitoring_target:
            nr_accesses[page] = 0
    sleep(sampling interval)
</pre></div>
</div>
<p>The monitoring overhead of this mechanism will arbitrarily increase as the
size of the target workload grows.</p>
</section>
<section id="region-based-sampling">
<h4>Region Based Sampling<a class="headerlink" href="#region-based-sampling" title="Permalink to this heading">¶</a></h4>
<p>To avoid the unbounded increase of the overhead, DAMON groups adjacent pages
that assumed to have the same access frequencies into a region.  As long as the
assumption (pages in a region have the same access frequencies) is kept, only
one page in the region is required to be checked.  Thus, for each <code class="docutils literal notranslate"><span class="pre">sampling</span>
<span class="pre">interval</span></code>, DAMON randomly picks one page in each region, waits for one
<code class="docutils literal notranslate"><span class="pre">sampling</span> <span class="pre">interval</span></code>, checks whether the page is accessed meanwhile, and
increases the access frequency of the region if so.  Therefore, the monitoring
overhead is controllable by setting the number of regions.  DAMON allows users
to set the minimum and the maximum number of regions for the trade-off.</p>
<p>This scheme, however, cannot preserve the quality of the output if the
assumption is not guaranteed.</p>
</section>
<section id="adaptive-regions-adjustment">
<h4>Adaptive Regions Adjustment<a class="headerlink" href="#adaptive-regions-adjustment" title="Permalink to this heading">¶</a></h4>
<p>Even somehow the initial monitoring target regions are well constructed to
fulfill the assumption (pages in same region have similar access frequencies),
the data access pattern can be dynamically changed.  This will result in low
monitoring quality.  To keep the assumption as much as possible, DAMON
adaptively merges and splits each region based on their access frequency.</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">aggregation</span> <span class="pre">interval</span></code>, it compares the access frequencies of
adjacent regions and merges those if the frequency difference is small.  Then,
after it reports and clears the aggregated access frequency of each region, it
splits each region into two or three regions if the total number of regions
will not exceed the user-specified maximum number of regions after the split.</p>
<p>In this way, DAMON provides its best-effort quality and minimal overhead while
keeping the bounds users set for their trade-off.</p>
</section>
<section id="age-tracking">
<h4>Age Tracking<a class="headerlink" href="#age-tracking" title="Permalink to this heading">¶</a></h4>
<p>By analyzing the monitoring results, users can also find how long the current
access pattern of a region has maintained.  That could be used for good
understanding of the access pattern.  For example, page placement algorithm
utilizing both the frequency and the recency could be implemented using that.
To make such access pattern maintained period analysis easier, DAMON maintains
yet another counter called <code class="docutils literal notranslate"><span class="pre">age</span></code> in each region.  For each <code class="docutils literal notranslate"><span class="pre">aggregation</span>
<span class="pre">interval</span></code>, DAMON checks if the region's size and access frequency
(<code class="docutils literal notranslate"><span class="pre">nr_accesses</span></code>) has significantly changed.  If so, the counter is reset to
zero.  Otherwise, the counter is increased.</p>
</section>
<section id="dynamic-target-space-updates-handling">
<h4>Dynamic Target Space Updates Handling<a class="headerlink" href="#dynamic-target-space-updates-handling" title="Permalink to this heading">¶</a></h4>
<p>The monitoring target address range could dynamically changed.  For example,
virtual memory could be dynamically mapped and unmapped.  Physical memory could
be hot-plugged.</p>
<p>As the changes could be quite frequent in some cases, DAMON allows the
monitoring operations to check dynamic changes including memory mapping changes
and applies it to monitoring operations-related data structures such as the
abstracted monitoring target memory area only for each of a user-specified time
interval (<code class="docutils literal notranslate"><span class="pre">update</span> <span class="pre">interval</span></code>).</p>
</section>
</section>
<section id="operation-schemes">
<span id="damon-design-damos"></span><h3>Operation Schemes<a class="headerlink" href="#operation-schemes" title="Permalink to this heading">¶</a></h3>
<p>One common purpose of data access monitoring is access-aware system efficiency
optimizations.  For example,</p>
<blockquote>
<div><p>paging out memory regions that are not accessed for more than two minutes</p>
</div></blockquote>
<p>or</p>
<blockquote>
<div><p>using THP for memory regions that are larger than 2 MiB and showing a high
access frequency for more than one minute.</p>
</div></blockquote>
<p>One straightforward approach for such schemes would be profile-guided
optimizations.  That is, getting data access monitoring results of the
workloads or the system using DAMON, finding memory regions of special
characteristics by profiling the monitoring results, and making system
operation changes for the regions.  The changes could be made by modifying or
providing advice to the software (the application and/or the kernel), or
reconfiguring the hardware.  Both offline and online approaches could be
available.</p>
<p>Among those, providing advice to the kernel at runtime would be flexible and
effective, and therefore widely be used.   However, implementing such schemes
could impose unnecessary redundancy and inefficiency.  The profiling could be
redundant if the type of interest is common.  Exchanging the information
including monitoring results and operation advice between kernel and user
spaces could be inefficient.</p>
<p>To allow users to reduce such redundancy and inefficiencies by offloading the
works, DAMON provides a feature called Data Access Monitoring-based Operation
Schemes (DAMOS).  It lets users specify their desired schemes at a high
level.  For such specifications, DAMON starts monitoring, finds regions having
the access pattern of interest, and applies the user-desired operation actions
to the regions as soon as found.</p>
<section id="operation-action">
<span id="damon-design-damos-action"></span><h4>Operation Action<a class="headerlink" href="#operation-action" title="Permalink to this heading">¶</a></h4>
<p>The management action that the users desire to apply to the regions of their
interest.  For example, paging out, prioritizing for next reclamation victim
selection, advising <code class="docutils literal notranslate"><span class="pre">khugepaged</span></code> to collapse or split, or doing nothing but
collecting statistics of the regions.</p>
<p>The list of supported actions is defined in DAMOS, but the implementation of
each action is in the DAMON operations set layer because the implementation
normally depends on the monitoring target address space.  For example, the code
for paging specific virtual address ranges out would be different from that for
physical address ranges.  And the monitoring operations implementation sets are
not mandated to support all actions of the list.  Hence, the availability of
specific DAMOS action depends on what operations set is selected to be used
together.</p>
<p>Applying an action to a region is considered as changing the region's
characteristics.  Hence, DAMOS resets the age of regions when an action is
applied to those.</p>
</section>
<section id="target-access-pattern">
<span id="damon-design-damos-access-pattern"></span><h4>Target Access Pattern<a class="headerlink" href="#target-access-pattern" title="Permalink to this heading">¶</a></h4>
<p>The access pattern of the schemes' interest.  The patterns are constructed with
the properties that DAMON's monitoring results provide, specifically the size,
the access frequency, and the age.  Users can describe their access pattern of
interest by setting minimum and maximum values of the three properties.  If a
region's three properties are in the ranges, DAMOS classifies it as one of the
regions that the scheme is having an interest in.</p>
</section>
<section id="quotas">
<span id="damon-design-damos-quotas"></span><h4>Quotas<a class="headerlink" href="#quotas" title="Permalink to this heading">¶</a></h4>
<p>DAMOS upper-bound overhead control feature.  DAMOS could incur high overhead if
the target access pattern is not properly tuned.  For example, if a huge memory
region having the access pattern of interest is found, applying the scheme's
action to all pages of the huge region could consume unacceptably large system
resources.  Preventing such issues by tuning the access pattern could be
challenging, especially if the access patterns of the workloads are highly
dynamic.</p>
<p>To mitigate that situation, DAMOS provides an upper-bound overhead control
feature called quotas.  It lets users specify an upper limit of time that DAMOS
can use for applying the action, and/or a maximum bytes of memory regions that
the action can be applied within a user-specified time duration.</p>
<section id="prioritization">
<span id="damon-design-damos-quotas-prioritization"></span><h5>Prioritization<a class="headerlink" href="#prioritization" title="Permalink to this heading">¶</a></h5>
<p>A mechanism for making a good decision under the quotas.  When the action
cannot be applied to all regions of interest due to the quotas, DAMOS
prioritizes regions and applies the action to only regions having high enough
priorities so that it will not exceed the quotas.</p>
<p>The prioritization mechanism should be different for each action.  For example,
rarely accessed (colder) memory regions would be prioritized for page-out
scheme action.  In contrast, the colder regions would be deprioritized for huge
page collapse scheme action.  Hence, the prioritization mechanisms for each
action are implemented in each DAMON operations set, together with the actions.</p>
<p>Though the implementation is up to the DAMON operations set, it would be common
to calculate the priority using the access pattern properties of the regions.
Some users would want the mechanisms to be personalized for their specific
case.  For example, some users would want the mechanism to weigh the recency
(<code class="docutils literal notranslate"><span class="pre">age</span></code>) more than the access frequency (<code class="docutils literal notranslate"><span class="pre">nr_accesses</span></code>).  DAMOS allows users
to specify the weight of each access pattern property and passes the
information to the underlying mechanism.  Nevertheless, how and even whether
the weight will be respected are up to the underlying prioritization mechanism
implementation.</p>
</section>
</section>
<section id="watermarks">
<span id="damon-design-damos-watermarks"></span><h4>Watermarks<a class="headerlink" href="#watermarks" title="Permalink to this heading">¶</a></h4>
<p>Conditional DAMOS (de)activation automation.  Users might want DAMOS to run
only under certain situations.  For example, when a sufficient amount of free
memory is guaranteed, running a scheme for proactive reclamation would only
consume unnecessary system resources.  To avoid such consumption, the user would
need to manually monitor some metrics such as free memory ratio, and turn
DAMON/DAMOS on or off.</p>
<p>DAMOS allows users to offload such works using three watermarks.  It allows the
users to configure the metric of their interest, and three watermark values,
namely high, middle, and low.  If the value of the metric becomes above the
high watermark or below the low watermark, the scheme is deactivated.  If the
metric becomes below the mid watermark but above the low watermark, the scheme
is activated.  If all schemes are deactivated by the watermarks, the monitoring
is also deactivated.  In this case, the DAMON worker thread only periodically
checks the watermarks and therefore incurs nearly zero overhead.</p>
</section>
<section id="filters">
<span id="damon-design-damos-filters"></span><h4>Filters<a class="headerlink" href="#filters" title="Permalink to this heading">¶</a></h4>
<p>Non-access pattern-based target memory regions filtering.  If users run
self-written programs or have good profiling tools, they could know something
more than the kernel, such as future access patterns or some special
requirements for specific types of memory. For example, some users may know
only anonymous pages can impact their program's performance.  They can also
have a list of latency-critical processes.</p>
<p>To let users optimize DAMOS schemes with such special knowledge, DAMOS provides
a feature called DAMOS filters.  The feature allows users to set an arbitrary
number of filters for each scheme.  Each filter specifies the type of target
memory, and whether it should exclude the memory of the type (filter-out), or
all except the memory of the type (filter-in).</p>
<p>As of this writing, anonymous page type and memory cgroup type are supported by
the feature.  Some filter target types can require additional arguments.  For
example, the memory cgroup filter type asks users to specify the file path of
the memory cgroup for the filter.  Hence, users can apply specific schemes to
only anonymous pages, non-anonymous pages, pages of specific cgroups, all pages
excluding those of specific cgroups, and any combination of those.</p>
</section>
</section>
<section id="application-programming-interface">
<h3>Application Programming Interface<a class="headerlink" href="#application-programming-interface" title="Permalink to this heading">¶</a></h3>
<p>The programming interface for kernel space data access-aware applications.
DAMON is a framework, so it does nothing by itself.  Instead, it only helps
other kernel components such as subsystems and modules building their data
access-aware applications using DAMON's core features.  For this, DAMON exposes
its all features to other kernel components via its application programming
interface, namely <code class="docutils literal notranslate"><span class="pre">include/linux/damon.h</span></code>.  Please refer to the API
<a class="reference internal" href="api.html"><span class="doc">document</span></a> for details of the interface.</p>
</section>
</section>
<section id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this heading">¶</a></h2>
<p>Because the core of DAMON is a framework for kernel components, it doesn't
provide any direct interface for the user space.  Such interfaces should be
implemented by each DAMON API user kernel components, instead.  DAMON subsystem
itself implements such DAMON API user modules, which are supposed to be used
for general purpose DAMON control and special purpose data access-aware system
operations, and provides stable application binary interfaces (ABI) for the
user space.  The user space can build their efficient data access-aware
applications using the interfaces.</p>
<section id="general-purpose-user-interface-modules">
<h3>General Purpose User Interface Modules<a class="headerlink" href="#general-purpose-user-interface-modules" title="Permalink to this heading">¶</a></h3>
<p>DAMON modules that provide user space ABIs for general purpose DAMON usage in
runtime.</p>
<p>DAMON user interface modules, namely 'DAMON sysfs interface' and 'DAMON debugfs
interface' are DAMON API user kernel modules that provide ABIs to the
user-space.  Please note that DAMON debugfs interface is currently deprecated.</p>
<p>Like many other ABIs, the modules create files on sysfs and debugfs, allow
users to specify their requests to and get the answers from DAMON by writing to
and reading from the files.  As a response to such I/O, DAMON user interface
modules control DAMON and retrieve the results as user requested via the DAMON
API, and return the results to the user-space.</p>
<p>The ABIs are designed to be used for user space applications development,
rather than human beings' fingers.  Human users are recommended to use such
user space tools.  One such Python-written user space tool is available at
Github (<a class="reference external" href="https://github.com/awslabs/damo">https://github.com/awslabs/damo</a>), Pypi
(<a class="reference external" href="https://pypistats.org/packages/damo">https://pypistats.org/packages/damo</a>), and Fedora
(<a class="reference external" href="https://packages.fedoraproject.org/pkgs/python-damo/damo/">https://packages.fedoraproject.org/pkgs/python-damo/damo/</a>).</p>
<p>Please refer to the ABI <a class="reference internal" href="../../admin-guide/mm/damon/usage.html"><span class="doc">document</span></a> for
details of the interfaces.</p>
</section>
<section id="special-purpose-access-aware-kernel-modules">
<h3>Special-Purpose Access-aware Kernel Modules<a class="headerlink" href="#special-purpose-access-aware-kernel-modules" title="Permalink to this heading">¶</a></h3>
<p>DAMON modules that provide user space ABI for specific purpose DAMON usage.</p>
<p>DAMON sysfs/debugfs user interfaces are for full control of all DAMON features
in runtime.  For each special-purpose system-wide data access-aware system
operations such as proactive reclamation or LRU lists balancing, the interfaces
could be simplified by removing unnecessary knobs for the specific purpose, and
extended for boot-time and even compile time control.  Default values of DAMON
control parameters for the usage would also need to be optimized for the
purpose.</p>
<p>To support such cases, yet more DAMON API user kernel modules that provide more
simple and optimized user space interfaces are available.  Currently, two
modules for proactive reclamation and LRU lists manipulation are provided.  For
more detail, please read the usage documents for those
(<a class="reference internal" href="../../admin-guide/mm/damon/reclaim.html"><span class="doc">DAMON-based Reclamation</span></a> and
<a class="reference internal" href="../../admin-guide/mm/damon/lru_sort.html"><span class="doc">DAMON-based LRU-lists Sorting</span></a>).</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/mm/damon/design.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>