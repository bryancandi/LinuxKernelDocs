
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Landlock LSM: kernel documentation &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Secrets documentation" href="secrets/index.html" />
    <link rel="prev" title="Digital Signature Verification API" href="digsig.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.5.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">A guide to the Kernel Development Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Kernel subsystem documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../networking/index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l3"><a class="reference internal" href="../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../wmi/index.html">WMI Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking in the kernel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user's and administrator's guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">The kernel build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">User-space tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  sbar.scrollTop = currents[currents.length - 1].offsetTop;
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/security/landlock.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="landlock-lsm-kernel-documentation">
<h1>Landlock LSM: kernel documentation<a class="headerlink" href="#landlock-lsm-kernel-documentation" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mickaël Salaün</p>
</dd>
<dt class="field-even">Date<span class="colon">:</span></dt>
<dd class="field-even"><p>December 2022</p>
</dd>
</dl>
<p>Landlock's goal is to create scoped access-control (i.e. sandboxing).  To
harden a whole system, this feature should be available to any process,
including unprivileged ones.  Because such process may be compromised or
backdoored (i.e. untrusted), Landlock's features must be safe to use from the
kernel and other processes point of view.  Landlock's interface must therefore
expose a minimal attack surface.</p>
<p>Landlock is designed to be usable by unprivileged processes while following the
system security policy enforced by other access control mechanisms (e.g. DAC,
LSM).  Indeed, a Landlock rule shall not interfere with other access-controls
enforced on the system, only add more restrictions.</p>
<p>Any user can enforce Landlock rulesets on their processes.  They are merged and
evaluated according to the inherited ones in a way that ensures that only more
constraints can be added.</p>
<p>User space documentation can be found here:
<a class="reference internal" href="../userspace-api/landlock.html"><span class="doc">Landlock: unprivileged access control</span></a>.</p>
<section id="guiding-principles-for-safe-access-controls">
<h2>Guiding principles for safe access controls<a class="headerlink" href="#guiding-principles-for-safe-access-controls" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>A Landlock rule shall be focused on access control on kernel objects instead
of syscall filtering (i.e. syscall arguments), which is the purpose of
seccomp-bpf.</p></li>
<li><p>To avoid multiple kinds of side-channel attacks (e.g. leak of security
policies, CPU-based attacks), Landlock rules shall not be able to
programmatically communicate with user space.</p></li>
<li><p>Kernel access check shall not slow down access request from unsandboxed
processes.</p></li>
<li><p>Computation related to Landlock operations (e.g. enforcing a ruleset) shall
only impact the processes requesting them.</p></li>
<li><p>Resources (e.g. file descriptors) directly obtained from the kernel by a
sandboxed process shall retain their scoped accesses (at the time of resource
acquisition) whatever process use them.
Cf. <a class="reference internal" href="#file-descriptor-access-rights">File descriptor access rights</a>.</p></li>
</ul>
</section>
<section id="design-choices">
<h2>Design choices<a class="headerlink" href="#design-choices" title="Permalink to this heading">¶</a></h2>
<section id="inode-access-rights">
<h3>Inode access rights<a class="headerlink" href="#inode-access-rights" title="Permalink to this heading">¶</a></h3>
<p>All access rights are tied to an inode and what can be accessed through it.
Reading the content of a directory does not imply to be allowed to read the
content of a listed inode.  Indeed, a file name is local to its parent
directory, and an inode can be referenced by multiple file names thanks to
(hard) links.  Being able to unlink a file only has a direct impact on the
directory, not the unlinked inode.  This is the reason why
<code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACCESS_FS_REMOVE_FILE</span></code> or <code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACCESS_FS_REFER</span></code> are not
allowed to be tied to files but only to directories.</p>
</section>
<section id="file-descriptor-access-rights">
<h3>File descriptor access rights<a class="headerlink" href="#file-descriptor-access-rights" title="Permalink to this heading">¶</a></h3>
<p>Access rights are checked and tied to file descriptors at open time.  The
underlying principle is that equivalent sequences of operations should lead to
the same results, when they are executed under the same Landlock domain.</p>
<p>Taking the <code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACCESS_FS_TRUNCATE</span></code> right as an example, it may be
allowed to open a file for writing without being allowed to
<em class="manpage">ftruncate</em> the resulting file descriptor if the related file
hierarchy doesn't grant such access right.  The following sequences of
operations have the same semantic and should then have the same result:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">truncate(path);</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span> <span class="pre">=</span> <span class="pre">open(path,</span> <span class="pre">O_WRONLY);</span> <span class="pre">ftruncate(fd);</span> <span class="pre">close(fd);</span></code></p></li>
</ul>
<p>Similarly to file access modes (e.g. <code class="docutils literal notranslate"><span class="pre">O_RDWR</span></code>), Landlock access rights
attached to file descriptors are retained even if they are passed between
processes (e.g. through a Unix domain socket).  Such access rights will then be
enforced even if the receiving process is not sandboxed by Landlock.  Indeed,
this is required to keep a consistent access control over the whole system, and
this avoids unattended bypasses through file descriptor passing (i.e. confused
deputy attack).</p>
</section>
</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this heading">¶</a></h2>
<p>Userspace tests for backward compatibility, ptrace restrictions and filesystem
support can be found here: <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/landlock/">tools/testing/selftests/landlock/</a>.</p>
</section>
<section id="kernel-structures">
<h2>Kernel structures<a class="headerlink" href="#kernel-structures" title="Permalink to this heading">¶</a></h2>
<section id="object">
<h3>Object<a class="headerlink" href="#object" title="Permalink to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_object_underops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_object_underops</span></span></span><a class="headerlink" href="#c.landlock_object_underops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Operations on an underlying object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_object_underops {
    void (*release)(struct landlock_object *const object) __releases(object-&gt;lock);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Releases the underlying object (e.g. <a class="reference internal" href="../filesystems/api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> for an inode).</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_object">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_object</span></span></span><a class="headerlink" href="#c.landlock_object" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Security blob tied to a kernel object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_object {
    refcount_t usage;
    spinlock_t lock;
    void *underobj;
    union {
        struct rcu_head rcu_free;
        const struct landlock_object_underops *underops;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>This counter is used to tie an object to the rules matching
it or to keep it alive while adding a new rule.  If this counter
reaches zero, this struct must not be modified, but this counter can
still be read from within an RCU read-side critical section.  When
adding a new rule to an object with a usage counter of zero, we must
wait until the pointer to this object is set to NULL (or recycled).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Protects against concurrent modifications.  This lock must be
held from the time <strong>usage</strong> drops to zero until any weak references
from <strong>underobj</strong> to this object have been cleaned up.</p>
<p>Lock ordering: inode-&gt;i_lock nests inside this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">underobj</span></code></dt><dd><p>Used when cleaning up an object and to mark an object as
tied to its underlying kernel structure.  This pointer is protected
by <strong>lock</strong>.  Cf. landlock_release_inodes() and release_inode().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_free</span></code></dt><dd><p>Enables lockless use of <strong>usage</strong>, <strong>lock</strong> and
<strong>underobj</strong> from within an RCU read-side critical section.
<strong>rcu_free</strong> and <strong>underops</strong> are only used by
landlock_put_object().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">underops</span></code></dt><dd><p>Enables landlock_put_object() to release the
underlying object (e.g. inode).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The goal of this structure is to enable to tie a set of ephemeral access
rights (pertaining to different domains) to a kernel object (e.g an inode)
in a safe way.  This implies to handle concurrent use and modification.</p>
<p>The lifetime of a <a class="reference internal" href="#c.landlock_object" title="landlock_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_object</span></code></a> depends on the rules referring to
it.</p>
</section>
<section id="filesystem">
<h3>Filesystem<a class="headerlink" href="#filesystem" title="Permalink to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_inode_security">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_inode_security</span></span></span><a class="headerlink" href="#c.landlock_inode_security" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inode security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_inode_security {
    struct landlock_object __rcu *object;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">object</span></code></dt><dd><p>Weak pointer to an allocated object.  All assignments of a
new object are protected by the underlying inode-&gt;i_lock.  However,
atomically disassociating <strong>object</strong> from the inode is only protected
by <strong>object-&gt;lock</strong>, from the time <strong>object</strong>'s usage refcount drops to
zero to the time this pointer is nulled out (cf. release_inode() and
hook_sb_delete()).  Indeed, such disassociation doesn't require
inode-&gt;i_lock thanks to the careful <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_access_pointer()</span></code></a> check
performed by get_inode_object().</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Enable to reference a <a class="reference internal" href="#c.landlock_object" title="landlock_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_object</span></code></a> tied to an inode (i.e.
underlying object).</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_file_security">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_file_security</span></span></span><a class="headerlink" href="#c.landlock_file_security" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>File security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_file_security {
    access_mask_t allowed_access;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">allowed_access</span></code></dt><dd><p>Access rights that were available at the time of
opening the file. This is not necessarily the full set of access
rights available at that time, but it's the necessary subset as
needed to authorize later operations on the open file.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This information is populated when opening a file in hook_file_open, and
tracks the relevant Landlock access rights that were available at the time
of opening the file. Other LSM hooks use these rights in order to authorize
operations on already opened files.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_superblock_security">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_superblock_security</span></span></span><a class="headerlink" href="#c.landlock_superblock_security" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Superblock security blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_superblock_security {
    atomic_long_t inode_refs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">inode_refs</span></code></dt><dd><p>Number of pending inodes (from this superblock) that
are being released by release_inode().
Cf. struct super_block-&gt;s_fsnotify_inode_refs .</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Enable hook_sb_delete() to wait for concurrent calls to release_inode().</p>
</section>
<section id="ruleset-and-domain">
<h3>Ruleset and domain<a class="headerlink" href="#ruleset-and-domain" title="Permalink to this heading">¶</a></h3>
<p>A domain is a read-only ruleset tied to a set of subjects (i.e. tasks'
credentials).  Each time a ruleset is enforced on a task, the current domain is
duplicated and the ruleset is imported as a new layer of rules in the new
domain.  Indeed, once in a domain, each rule is tied to a layer level.  To
grant access to an object, at least one rule of each layer must allow the
requested action on the object.  A task can then only transit to a new domain
that is the intersection of the constraints from the current domain and those
of a ruleset provided by the task.</p>
<p>The definition of a subject is implicit for a task sandboxing itself, which
makes the reasoning much easier and helps avoid pitfalls.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_layer">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_layer</span></span></span><a class="headerlink" href="#c.landlock_layer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Access rights for a given layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_layer {
    u16 level;
    access_mask_t access;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">level</span></code></dt><dd><p>Position of this layer in the layer stack.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access</span></code></dt><dd><p>Bitfield of allowed actions on the kernel object.  They are
relative to the object type (e.g. <code class="docutils literal notranslate"><span class="pre">LANDLOCK_ACTION_FS_READ</span></code>).</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_rule">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_rule</span></span></span><a class="headerlink" href="#c.landlock_rule" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Access rights tied to an object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_rule {
    struct rb_node node;
    struct landlock_object *object;
    u32 num_layers;
    struct landlock_layer layers[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>Node in the ruleset's red-black tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object</span></code></dt><dd><p>Pointer to identify a kernel object (e.g. an inode).  This
is used as a key for this ruleset element.  This pointer is set once
and never modified.  It always points to an allocated object because
each rule increments the refcount of its object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_layers</span></code></dt><dd><p>Number of entries in <strong>layers</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layers</span></code></dt><dd><p>Stack of layers, from the latest to the newest, implemented
as a flexible array member (FAM).</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_hierarchy">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_hierarchy</span></span></span><a class="headerlink" href="#c.landlock_hierarchy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Node in a ruleset hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_hierarchy {
    struct landlock_hierarchy *parent;
    refcount_t usage;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Pointer to the parent node, or NULL if it is a root
Landlock domain.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>Number of potential children domains plus their parent
domain.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.landlock_ruleset">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">landlock_ruleset</span></span></span><a class="headerlink" href="#c.landlock_ruleset" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Landlock ruleset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct landlock_ruleset {
    struct rb_root root;
    struct landlock_hierarchy *hierarchy;
    union {
        struct work_struct work_free;
        struct {
            struct mutex lock;
            refcount_t usage;
            u32 num_rules;
            u32 num_layers;
            access_mask_t fs_access_masks[];
        };
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">root</span></code></dt><dd><p>Root of a red-black tree containing <a class="reference internal" href="#c.landlock_rule" title="landlock_rule"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">landlock_rule</span></code></a>
nodes.  Once a ruleset is tied to a process (i.e. as a domain), this
tree is immutable until <strong>usage</strong> reaches zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hierarchy</span></code></dt><dd><p>Enables hierarchy identification even when a parent
domain vanishes.  This is needed for the ptrace protection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work_free</span></code></dt><dd><p>Enables to free a ruleset within a lockless
section.  This is only used by
landlock_put_ruleset_deferred() when <strong>usage</strong> reaches zero.
The fields <strong>lock</strong>, <strong>usage</strong>, <strong>num_rules</strong>, <strong>num_layers</strong> and
<strong>fs_access_masks</strong> are then unused.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Protects against concurrent modifications of
<strong>root</strong>, if <strong>usage</strong> is greater than zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>Number of processes (i.e. domains) or file
descriptors referencing this ruleset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rules</span></code></dt><dd><p>Number of non-overlapping (i.e. not for
the same object) rules in this ruleset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_layers</span></code></dt><dd><p>Number of layers that are used in this
ruleset.  This enables to check that all the layers
allow an access request.  A value of 0 identifies a
non-merged ruleset (i.e. not a domain).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_access_masks</span></code></dt><dd><p>Contains the subset of filesystem
actions that are restricted by a ruleset.  A domain
saves all layers of merged rulesets in a stack
(FAM), starting from the first layer to the last
one.  These layers are used when merging rulesets,
for user space backward compatibility (i.e.
future-proof), and to properly handle merged
rulesets without overlapping access rights.  These
layers are set once and never changed for the
lifetime of the ruleset.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This data structure must contain unique entries, be updatable, and quick to
match an object.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/security/landlock.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>