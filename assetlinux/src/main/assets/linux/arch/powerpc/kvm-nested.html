<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Nested KVM on POWER &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a152c8ac" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Hypercall Op-codes (hcalls)" href="papr_hcalls.html" />
    <link rel="prev" title="Linux 2.6.x on MPC52xx family" href="mpc52xx.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.14.0</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><!-- SPDX-License-Identifier: GPL-2.0 -->

<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">CPU architectures</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../arc/index.html">ARC architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../loongarch/index.html">LoongArch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">powerpc</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="associativity.html">NUMA resource associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="booting.html">DeviceTree Booting</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootwrapper.html">The PowerPC boot wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_families.html">CPU Families</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_features.html">CPU Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="cxl.html">Coherent Accelerator Interface (CXL)</a></li>
<li class="toctree-l3"><a class="reference internal" href="cxlflash.html">Coherent Accelerator (CXL) Flash</a></li>
<li class="toctree-l3"><a class="reference internal" href="dawr-power9.html">DAWR issues on POWER9</a></li>
<li class="toctree-l3"><a class="reference internal" href="dexcr.html">DEXCR (Dynamic Execution Control Register)</a></li>
<li class="toctree-l3"><a class="reference internal" href="dscr.html">DSCR (Data Stream Control Register)</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeh-pci-error-recovery.html">PCI Bus EEH Error Recovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="elf_hwcaps.html">POWERPC ELF HWCAPs</a></li>
<li class="toctree-l3"><a class="reference internal" href="elfnote.html">ELF Note PowerPC Namespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware-assisted-dump.html">Firmware-Assisted Dump</a></li>
<li class="toctree-l3"><a class="reference internal" href="hvcs.html">HVCS IBM “Hypervisor Virtual Console Server” Installation Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="imc.html">IMC (In-Memory Collection Counters)</a></li>
<li class="toctree-l3"><a class="reference internal" href="isa-versions.html">CPU to ISA Version Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="kaslr-booke32.html">KASLR for Freescale BookE32</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpc52xx.html">Linux 2.6.x on MPC52xx family</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Nested KVM on POWER</a></li>
<li class="toctree-l3"><a class="reference internal" href="papr_hcalls.html">Hypercall Op-codes (hcalls)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pci_iov_resource_on_powernv.html">PCI Express I/O Virtualization Resource on Powerenv</a></li>
<li class="toctree-l3"><a class="reference internal" href="pmu-ebb.html">PMU Event Based Branches</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptrace.html">Ptrace</a></li>
<li class="toctree-l3"><a class="reference internal" href="qe_firmware.html">Freescale QUICC Engine Firmware Uploading</a></li>
<li class="toctree-l3"><a class="reference internal" href="syscall64-abi.html">Power Architecture 64-bit Linux system call ABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="transactional_memory.html">Transactional Memory support</a></li>
<li class="toctree-l3"><a class="reference internal" href="ultravisor.html">Protected Execution Facility</a></li>
<li class="toctree-l3"><a class="reference internal" href="vas-api.html">Virtual Accelerator Switchboard (VAS) userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="vcpudispatch_stats.html">VCPU Dispatch Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="vmemmap_dedup.html">Device DAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="features.html">Feature status on powerpc architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/arch/powerpc/kvm-nested.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-- SPDX-License-Identifier: GPL-2.0 -->
<!-- Copyright © 2023, Oracle and/or its affiliates. -->


<section id="nested-kvm-on-power">
<h1>Nested KVM on POWER<a class="headerlink" href="#nested-kvm-on-power" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document explains how a guest operating system can act as a
hypervisor and run nested guests through the use of hypercalls, if the
hypervisor has implemented them. The terms L0, L1, and L2 are used to
refer to different software entities. L0 is the hypervisor mode entity
that would normally be called the “host” or “hypervisor”. L1 is a
guest virtual machine that is directly run under L0 and is initiated
and controlled by L0. L2 is a guest virtual machine that is initiated
and controlled by L1 acting as a hypervisor.</p>
</section>
<section id="existing-api">
<h2>Existing API<a class="headerlink" href="#existing-api" title="Link to this heading">¶</a></h2>
<p>Linux/KVM has had support for Nesting as an L0 or L1 since 2018</p>
<p>The L0 code was added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>commit 8e3f5fc1045dc49fd175b978c5457f5f51e7a2ce
Author: Paul Mackerras &lt;paulus@ozlabs.org&gt;
Date:   Mon Oct 8 16:31:03 2018 +1100
KVM: PPC: Book3S HV: Framework and hcall stubs for nested virtualization
</pre></div>
</div>
<p>The L1 code was added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>commit 360cae313702cdd0b90f82c261a8302fecef030a
Author: Paul Mackerras &lt;paulus@ozlabs.org&gt;
Date:   Mon Oct 8 16:31:04 2018 +1100
KVM: PPC: Book3S HV: Nested guest entry via hypercall
</pre></div>
</div>
<p>This API works primarily using a single hcall h_enter_nested(). This
call made by the L1 to tell the L0 to start an L2 vCPU with the given
state. The L0 then starts this L2 and runs until an L2 exit condition
is reached. Once the L2 exits, the state of the L2 is given back to
the L1 by the L0. The full L2 vCPU state is always transferred from
and to L1 when the L2 is run. The L0 doesn’t keep any state on the L2
vCPU (except in the short sequence in the L0 on L1 -&gt; L2 entry and L2
-&gt; L1 exit).</p>
<p>The only state kept by the L0 is the partition table. The L1 registers
it’s partition table using the h_set_partition_table() hcall. All
other state held by the L0 about the L2s is cached state (such as
shadow page tables).</p>
<p>The L1 may run any L2 or vCPU without first informing the L0. It
simply starts the vCPU using h_enter_nested(). The creation of L2s and
vCPUs is done implicitly whenever h_enter_nested() is called.</p>
<p>In this document, we call this existing API the v1 API.</p>
</section>
<section id="new-papr-api">
<h2>New PAPR API<a class="headerlink" href="#new-papr-api" title="Link to this heading">¶</a></h2>
<p>The new PAPR API changes from the v1 API such that the creating L2 and
associated vCPUs is explicit. In this document, we call this the v2
API.</p>
<p>h_enter_nested() is replaced with H_GUEST_VCPU_RUN().  Before this can
be called the L1 must explicitly create the L2 using h_guest_create()
and any associated vCPUs() created with h_guest_create_vCPU(). Getting
and setting vCPU state can also be performed using h_guest_{g|s}et
hcall.</p>
<p>The basic execution flow is for an L1 to create an L2, run it, and
delete it is:</p>
<ul class="simple">
<li><p>L1 and L0 negotiate capabilities with H_GUEST_{G,S}ET_CAPABILITIES()
(normally at L1 boot time).</p></li>
<li><p>L1 requests the L0 create an L2 with H_GUEST_CREATE() and receives a token</p></li>
<li><p>L1 requests the L0 create an L2 vCPU with H_GUEST_CREATE_VCPU()</p></li>
<li><p>L1 and L0 communicate the vCPU state using the H_GUEST_{G,S}ET() hcall</p></li>
<li><p>L1 requests the L0 runs the vCPU running H_GUEST_VCPU_RUN() hcall</p></li>
<li><p>L1 deletes L2 with H_GUEST_DELETE()</p></li>
</ul>
<p>More details of the individual hcalls follows:</p>
</section>
<section id="hcall-details">
<h2>HCALL Details<a class="headerlink" href="#hcall-details" title="Link to this heading">¶</a></h2>
<p>This documentation is provided to give an overall understating of the
API. It doesn’t aim to provide all the details required to implement
an L1 or L0. Latest version of PAPR can be referred to for more details.</p>
<p>All these HCALLs are made by the L1 to the L0.</p>
<section id="h-guest-get-capabilities">
<h3>H_GUEST_GET_CAPABILITIES()<a class="headerlink" href="#h-guest-get-capabilities" title="Link to this heading">¶</a></h3>
<p>This is called to get the capabilities of the L0 nested
hypervisor. This includes capabilities such the CPU versions (eg
POWER9, POWER10) that are supported as L2s:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_GET_CAPABILITIES(uint64 flags)

Parameters:
  Input:
    flags: Reserved
  Output:
    R3: Return code
    R4: Hypervisor Supported Capabilities bitmap 1
</pre></div>
</div>
</section>
<section id="h-guest-set-capabilities">
<h3>H_GUEST_SET_CAPABILITIES()<a class="headerlink" href="#h-guest-set-capabilities" title="Link to this heading">¶</a></h3>
<p>This is called to inform the L0 of the capabilities of the L1
hypervisor. The set of flags passed here are the same as
H_GUEST_GET_CAPABILITIES()</p>
<p>Typically, GET will be called first and then SET will be called with a
subset of the flags returned from GET. This process allows the L0 and
L1 to negotiate an agreed set of capabilities:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_SET_CAPABILITIES(uint64 flags,
                         uint64 capabilitiesBitmap1)
Parameters:
  Input:
    flags: Reserved
    capabilitiesBitmap1: Only capabilities advertised through
                         H_GUEST_GET_CAPABILITIES
  Output:
    R3: Return code
    R4: If R3 = H_P2: The number of invalid bitmaps
    R5: If R3 = H_P2: The index of first invalid bitmap
</pre></div>
</div>
</section>
<section id="h-guest-create">
<h3>H_GUEST_CREATE()<a class="headerlink" href="#h-guest-create" title="Link to this heading">¶</a></h3>
<p>This is called to create an L2. A unique ID of the L2 created
(similar to an LPID) is returned, which can be used on subsequent HCALLs to
identify the L2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_CREATE(uint64 flags,
               uint64 continueToken);
Parameters:
  Input:
    flags: Reserved
    continueToken: Initial call set to -1. Subsequent calls,
                   after H_Busy or H_LongBusyOrder has been
                   returned, value that was returned in R4.
  Output:
    R3: Return code. Notable:
      H_Not_Enough_Resources: Unable to create Guest VCPU due to not
      enough Hypervisor memory. See H_GUEST_CREATE_GET_STATE(flags =
      takeOwnershipOfVcpuState)
    R4: If R3 = H_Busy or_H_LongBusyOrder -&gt; continueToken
</pre></div>
</div>
</section>
<section id="h-guest-create-vcpu">
<h3>H_GUEST_CREATE_VCPU()<a class="headerlink" href="#h-guest-create-vcpu" title="Link to this heading">¶</a></h3>
<p>This is called to create a vCPU associated with an L2. The L2 id
(returned from H_GUEST_CREATE()) should be passed it. Also passed in
is a unique (for this L2) vCPUid. This vCPUid is allocated by the
L1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_CREATE_VCPU(uint64 flags,
                    uint64 guestId,
                    uint64 vcpuId);
Parameters:
  Input:
    flags: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU to be created. This must be within the
            range of 0 to 2047
  Output:
    R3: Return code. Notable:
      H_Not_Enough_Resources: Unable to create Guest VCPU due to not
      enough Hypervisor memory. See H_GUEST_CREATE_GET_STATE(flags =
      takeOwnershipOfVcpuState)
</pre></div>
</div>
</section>
<section id="h-guest-get-state">
<h3>H_GUEST_GET_STATE()<a class="headerlink" href="#h-guest-get-state" title="Link to this heading">¶</a></h3>
<p>This is called to get state associated with an L2 (Guest-wide or vCPU specific).
This info is passed via the Guest State Buffer (GSB), a standard format as
explained later in this doc, necessary details below:</p>
<p>This can get either L2 wide or vcpu specific information. Examples of
L2 wide is the timebase offset or process scoped page table
info. Examples of vCPU specific are GPRs or VSRs. A bit in the flags
parameter specifies if this call is L2 wide or vCPU specific and the
IDs in the GSB must match this.</p>
<p>The L1 provides a pointer to the GSB as a parameter to this call. Also
provided is the L2 and vCPU IDs associated with the state to set.</p>
<p>The L1 writes only the IDs and sizes in the GSB.  L0 writes the
associated values for each ID in the GSB:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_GET_STATE(uint64 flags,
                         uint64 guestId,
                         uint64 vcpuId,
                         uint64 dataBuffer,
                         uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: getGuestWideState: Request state of the Guest instead
         of an individual VCPU.
       Bit 1: takeOwnershipOfVcpuState Indicate the L1 is taking
         over ownership of the VCPU state and that the L0 can free
         the storage holding the state. The VCPU state will need to
         be returned to the Hypervisor via H_GUEST_SET_STATE prior
         to H_GUEST_RUN_VCPU being called for this VCPU. The data
         returned in the dataBuffer is in a Hypervisor internal
         format.
       Bits 2-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
    dataBuffer: A L1 real address of the GSB.
      If takeOwnershipOfVcpuState, size must be at least the size
      returned by ID=0x0001
    dataBufferSizeInBytes: Size of dataBuffer
  Output:
    R3: Return code
    R4: If R3 = H_Invalid_Element_Id: The array index of the bad
          element ID.
        If R3 = H_Invalid_Element_Size: The array index of the bad
           element size.
        If R3 = H_Invalid_Element_Value: The array index of the bad
           element value.
</pre></div>
</div>
</section>
<section id="h-guest-set-state">
<h3>H_GUEST_SET_STATE()<a class="headerlink" href="#h-guest-set-state" title="Link to this heading">¶</a></h3>
<p>This is called to set L2 wide or vCPU specific L2 state. This info is
passed via the Guest State Buffer (GSB), necessary details below:</p>
<p>This can set either L2 wide or vcpu specific information. Examples of
L2 wide is the timebase offset or process scoped page table
info. Examples of vCPU specific are GPRs or VSRs. A bit in the flags
parameter specifies if this call is L2 wide or vCPU specific and the
IDs in the GSB must match this.</p>
<p>The L1 provides a pointer to the GSB as a parameter to this call. Also
provided is the L2 and vCPU IDs associated with the state to set.</p>
<p>The L1 writes all values in the GSB and the L0 only reads the GSB for
this call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_SET_STATE(uint64 flags,
                  uint64 guestId,
                  uint64 vcpuId,
                  uint64 dataBuffer,
                  uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: getGuestWideState: Request state of the Guest instead
         of an individual VCPU.
       Bit 1: returnOwnershipOfVcpuState Return Guest VCPU state. See
         GET_STATE takeOwnershipOfVcpuState
       Bits 2-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
    dataBuffer: A L1 real address of the GSB.
      If takeOwnershipOfVcpuState, size must be at least the size
      returned by ID=0x0001
    dataBufferSizeInBytes: Size of dataBuffer
  Output:
    R3: Return code
    R4: If R3 = H_Invalid_Element_Id: The array index of the bad
          element ID.
        If R3 = H_Invalid_Element_Size: The array index of the bad
           element size.
        If R3 = H_Invalid_Element_Value: The array index of the bad
           element value.
</pre></div>
</div>
</section>
<section id="h-guest-run-vcpu">
<h3>H_GUEST_RUN_VCPU()<a class="headerlink" href="#h-guest-run-vcpu" title="Link to this heading">¶</a></h3>
<p>This is called to run an L2 vCPU. The L2 and vCPU IDs are passed in as
parameters. The vCPU runs with the state set previously using
H_GUEST_SET_STATE(). When the L2 exits, the L1 will resume from this
hcall.</p>
<p>This hcall also has associated input and output GSBs. Unlike
H_GUEST_{S,G}ET_STATE(), these GSB pointers are not passed in as
parameters to the hcall (This was done in the interest of
performance). The locations of these GSBs must be preregistered using
the H_GUEST_SET_STATE() call with ID 0x0c00 and 0x0c01 (see table
below).</p>
<p>The input GSB may contain only VCPU specific elements to be set. This
GSB may also contain zero elements (ie 0 in the first 4 bytes of the
GSB) if nothing needs to be set.</p>
<p>On exit from the hcall, the output buffer is filled with elements
determined by the L0. The reason for the exit is contained in GPR4 (ie
NIP is put in GPR4).  The elements returned depend on the exit
type. For example, if the exit reason is the L2 doing a hcall (GPR4 =
0xc00), then GPR3-12 are provided in the output GSB as this is the
state likely needed to service the hcall. If additional state is
needed, H_GUEST_GET_STATE() may be called by the L1.</p>
<p>To synthesize interrupts in the L2, when calling H_GUEST_RUN_VCPU()
the L1 may set a flag (as a hcall parameter) and the L0 will
synthesize the interrupt in the L2. Alternatively, the L1 may
synthesize the interrupt itself using H_GUEST_SET_STATE() or the
H_GUEST_RUN_VCPU() input GSB to set the state appropriately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_RUN_VCPU(uint64 flags,
                 uint64 guestId,
                 uint64 vcpuId,
                 uint64 dataBuffer,
                 uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: generateExternalInterrupt: Generate an external interrupt
       Bit 1: generatePrivilegedDoorbell: Generate a Privileged Doorbell
       Bit 2: sendToSystemReset”: Generate a System Reset Interrupt
       Bits 3-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
  Output:
    R3: Return code
    R4: If R3 = H_Success: The reason L1 VCPU exited (ie. NIA)
          0x000: The VCPU stopped running for an unspecified reason. An
            example of this is the Hypervisor stopping a VCPU running
            due to an outstanding interrupt for the Host Partition.
          0x980: HDEC
          0xC00: HCALL
          0xE00: HDSI
          0xE20: HISI
          0xE40: HEA
          0xF80: HV Fac Unavail
        If R3 = H_Invalid_Element_Id, H_Invalid_Element_Size, or
          H_Invalid_Element_Value: R4 is offset of the invalid element
          in the input buffer.
</pre></div>
</div>
</section>
<section id="h-guest-delete">
<h3>H_GUEST_DELETE()<a class="headerlink" href="#h-guest-delete" title="Link to this heading">¶</a></h3>
<p>This is called to delete an L2. All associated vCPUs are also
deleted. No specific vCPU delete call is provided.</p>
<p>A flag may be provided to delete all guests. This is used to reset the
L0 in the case of kdump/kexec:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_DELETE(uint64 flags,
               uint64 guestId)
Parameters:
  Input:
    flags:
       Bit 0: deleteAllGuests: deletes all guests
       Bits 1-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
  Output:
    R3: Return code
</pre></div>
</div>
</section>
</section>
<section id="guest-state-buffer">
<h2>Guest State Buffer<a class="headerlink" href="#guest-state-buffer" title="Link to this heading">¶</a></h2>
<p>The Guest State Buffer (GSB) is the main method of communicating state
about the L2 between the L1 and L0 via H_GUEST_{G,S}ET() and
H_GUEST_VCPU_RUN() calls.</p>
<p>State may be associated with a whole L2 (eg timebase offset) or a
specific L2 vCPU (eg. GPR state). Only L2 VCPU state maybe be set by
H_GUEST_VCPU_RUN().</p>
<p>All data in the GSB is big endian (as is standard in PAPR)</p>
<p>The Guest state buffer has a header which gives the number of
elements, followed by the GSB elements themselves.</p>
<p>GSB header:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset
Bytes</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>4</p></td>
<td><p>Number of elements</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td></td>
<td><p>Guest state buffer elements</p></td>
</tr>
</tbody>
</table>
<p>GSB element:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset
Bytes</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>ID</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>Size of Value</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>As above</p></td>
<td><p>Value</p></td>
</tr>
</tbody>
</table>
<p>The ID in the GSB element specifies what is to be set. This includes
archtected state like GPRs, VSRs, SPRs, plus also some meta data about
the partition like the timebase offset and partition scoped page
table information.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ID</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>RW</p></th>
<th class="head"><p>Thread
Guest
Scope</p></th>
<th class="head"><p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0000</p></td>
<td></td>
<td><p>RW</p></td>
<td><p>TG</p></td>
<td><p>NOP element</p></td>
</tr>
<tr class="row-odd"><td><p>0x0001</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>G</p></td>
<td><p>Size of L0 vCPU state. See:
H_GUEST_GET_STATE:
flags = takeOwnershipOfVcpuState</p></td>
</tr>
<tr class="row-even"><td><p>0x0002</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>G</p></td>
<td><p>Size Run vCPU out buffer</p></td>
</tr>
<tr class="row-odd"><td><p>0x0003</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Logical PVR</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>TB Offset (L1 relative)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0005</p></td>
<td><p>0x18</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Partition scoped page tbl info:</p>
<ul class="simple">
<li><p>0x00 Addr part scope table</p></li>
<li><p>0x08 Num addr bits</p></li>
<li><p>0x10 Size root dir</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>0x0006</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Process Table Information:</p>
<ul class="simple">
<li><p>0x0 Addr proc scope table</p></li>
<li><p>0x8 Table size.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0x0007-
0x0BFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x0C00</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>Run vCPU Input Buffer:</p>
<ul class="simple">
<li><p>0x0 Addr of buffer</p></li>
<li><p>0x8 Buffer Size.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0x0C01</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>Run vCPU Output Buffer:</p>
<ul class="simple">
<li><p>0x0 Addr of buffer</p></li>
<li><p>0x8 Buffer Size.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>0x0C02</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>vCPU VPA Address</p></td>
</tr>
<tr class="row-odd"><td><p>0x0C03-
0x0FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x1000-
0x101F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>GPR 0-31</p></td>
</tr>
<tr class="row-odd"><td><p>0x1020</p></td>
<td><p>0x08</p></td>
<td><p>T</p></td>
<td><p>T</p></td>
<td><p>HDEC expiry TB</p></td>
</tr>
<tr class="row-even"><td><p>0x1021</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>NIA</p></td>
</tr>
<tr class="row-odd"><td><p>0x1022</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MSR</p></td>
</tr>
<tr class="row-even"><td><p>0x1023</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>LR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1024</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>XER</p></td>
</tr>
<tr class="row-even"><td><p>0x1025</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CTR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1026</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CFAR</p></td>
</tr>
<tr class="row-even"><td><p>0x1027</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SRR0</p></td>
</tr>
<tr class="row-odd"><td><p>0x1028</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SRR1</p></td>
</tr>
<tr class="row-even"><td><p>0x1029</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x102A</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DEC expiry TB</p></td>
</tr>
<tr class="row-even"><td><p>0x102B</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VTB</p></td>
</tr>
<tr class="row-odd"><td><p>0x102C</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>LPCR</p></td>
</tr>
<tr class="row-even"><td><p>0x102D</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HFSCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x102E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>FSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x102F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>FPSCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1030</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWR0</p></td>
</tr>
<tr class="row-even"><td><p>0x1031</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWR1</p></td>
</tr>
<tr class="row-odd"><td><p>0x1032</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CIABR</p></td>
</tr>
<tr class="row-even"><td><p>0x1033</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PURR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1034</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SPURR</p></td>
</tr>
<tr class="row-even"><td><p>0x1035</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>IC</p></td>
</tr>
<tr class="row-odd"><td><p>0x1036-
0x1039</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SPRG 0-3</p></td>
</tr>
<tr class="row-even"><td><p>0x103A</p></td>
<td><p>0x08</p></td>
<td><p>W</p></td>
<td><p>T</p></td>
<td><p>PPR</p></td>
</tr>
<tr class="row-odd"><td><p>0x103B
0x103E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MMCR 0-3</p></td>
</tr>
<tr class="row-even"><td><p>0x103F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MMCRA</p></td>
</tr>
<tr class="row-odd"><td><p>0x1040</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER</p></td>
</tr>
<tr class="row-even"><td><p>0x1041</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER 2</p></td>
</tr>
<tr class="row-odd"><td><p>0x1042</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER 3</p></td>
</tr>
<tr class="row-even"><td><p>0x1043</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>BESCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1044</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>EBBHR</p></td>
</tr>
<tr class="row-even"><td><p>0x1045</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>EBBRR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1046</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>AMR</p></td>
</tr>
<tr class="row-even"><td><p>0x1047</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>IAMR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1048</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>AMOR</p></td>
</tr>
<tr class="row-even"><td><p>0x1049</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>UAMOR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104A</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SDAR</p></td>
</tr>
<tr class="row-even"><td><p>0x104B</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104C</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x104D</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>TAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DEXCR</p></td>
</tr>
<tr class="row-even"><td><p>0x104F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HDEXCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1050</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HASHKEYR</p></td>
</tr>
<tr class="row-even"><td><p>0x1051</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HASHPKEYR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1052</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CTRL</p></td>
</tr>
<tr class="row-even"><td><p>0x1053</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DPDES</p></td>
</tr>
<tr class="row-odd"><td><p>0x1054-
0x1FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x2000</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CR</p></td>
</tr>
<tr class="row-odd"><td><p>0x2001</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PIDR</p></td>
</tr>
<tr class="row-even"><td><p>0x2002</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DSISR</p></td>
</tr>
<tr class="row-odd"><td><p>0x2003</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x2004</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VRSAVE</p></td>
</tr>
<tr class="row-odd"><td><p>0x2005</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWRX0</p></td>
</tr>
<tr class="row-even"><td><p>0x2006</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWRX1</p></td>
</tr>
<tr class="row-odd"><td><p>0x2007-
0x200c</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PMC 1-6</p></td>
</tr>
<tr class="row-even"><td><p>0x200D</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>WORT</p></td>
</tr>
<tr class="row-odd"><td><p>0x200E</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PSPB</p></td>
</tr>
<tr class="row-even"><td><p>0x200F-
0x2FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0x3000-
0x303F</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VSR 0-63</p></td>
</tr>
<tr class="row-even"><td><p>0x3040-
0xEFFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0xF000</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HDAR</p></td>
</tr>
<tr class="row-even"><td><p>0xF001</p></td>
<td><p>0x04</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HDSISR</p></td>
</tr>
<tr class="row-odd"><td><p>0xF002</p></td>
<td><p>0x04</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HEIR</p></td>
</tr>
<tr class="row-even"><td><p>0xF003</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>ASDR</p></td>
</tr>
</tbody>
</table>
</section>
<section id="miscellaneous-info">
<h2>Miscellaneous info<a class="headerlink" href="#miscellaneous-info" title="Link to this heading">¶</a></h2>
<section id="state-not-in-ptregs-hvregs">
<h3>State not in ptregs/hvregs<a class="headerlink" href="#state-not-in-ptregs-hvregs" title="Link to this heading">¶</a></h3>
<p>In the v1 API, some state is not in the ptregs/hvstate. This includes
the vector register and some SPRs. For the L1 to set this state for
the L2, the L1 loads up these hardware registers before the
h_enter_nested() call and the L0 ensures they end up as the L2 state
(by not touching them).</p>
<p>The v2 API removes this and explicitly sets this state via the GSB.</p>
</section>
<section id="l1-implementation-details-caching-state">
<h3>L1 Implementation details: Caching state<a class="headerlink" href="#l1-implementation-details-caching-state" title="Link to this heading">¶</a></h3>
<p>In the v1 API, all state is sent from the L1 to the L0 and vice versa
on every h_enter_nested() hcall. If the L0 is not currently running
any L2s, the L0 has no state information about them. The only
exception to this is the location of the partition table, registered
via h_set_partition_table().</p>
<p>The v2 API changes this so that the L0 retains the L2 state even when
it’s vCPUs are no longer running. This means that the L1 only needs to
communicate with the L0 about L2 state when it needs to modify the L2
state, or when it’s value is out of date. This provides an opportunity
for performance optimisation.</p>
<p>When a vCPU exits from a H_GUEST_RUN_VCPU() call, the L1 internally
marks all L2 state as invalid. This means that if the L1 wants to know
the L2 state (say via a kvm_get_one_reg() call), it needs call
H_GUEST_GET_STATE() to get that state. Once it’s read, it’s marked as
valid in L1 until the L2 is run again.</p>
<p>Also, when an L1 modifies L2 vcpu state, it doesn’t need to write it
to the L0 until that L2 vcpu runs again. Hence when the L1 updates
state (say via a kvm_set_one_reg() call), it writes to an internal L1
copy and only flushes this copy to the L0 when the L2 runs again via
the H_GUEST_VCPU_RUN() input buffer.</p>
<p>This lazy updating of state by the L1 avoids unnecessary
H_GUEST_{G|S}ET_STATE() calls.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/arch/powerpc/kvm-nested.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>